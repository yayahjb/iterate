#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 1)."
# Contents:  ITERATE.cmn MANIFEST Makefile README ciftbx.cmf ciftbx.cmn
#   ciftbx.cmv ciftbx.f ciftbx.sys clearfp.f clearfp_sun.f
#   cryst1-2-cif.awk hash_funcs.f iterate.csh.m4 iterate.f
#   iterate.html.m4 lgpl.txt
# Wrapped by bernsteh@arcib on Sat Sep 27 21:50:02 2008
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'ITERATE.cmn' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ITERATE.cmn'\"
else
echo shar: Extracting \"'ITERATE.cmn'\" \(319 characters\)
sed "s/^X//" >'ITERATE.cmn' <<'END_OF_FILE'
X      common /files/ iunt0,iunt1,iunt2,iunt3,iunt10
X      common /qenv/ querst,ostyle,istyle
X      common /qcifl/ cifres
X      common /qcifs/ cifeid,cifsgs,hm
X      character*80 querst,ostyle,istyle
X      character*4 cifeid
X      character*11 cifsgs
X      character*1 hm
X      logical cifres
X      include 'ciftbx.cmv'
END_OF_FILE
if test 319 -ne `wc -c <'ITERATE.cmn'`; then
    echo shar: \"'ITERATE.cmn'\" unpacked with wrong size!
fi
# end of 'ITERATE.cmn'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(1081 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X ITERATE.cmn                1	include file for iterate.f
X MANIFEST                   1	This file
X Makefile                   1	Command file for make
X README                     1	Instructions on installtion and use
X ciftbx.cmf                 1	functions include file used by ciftbx
X ciftbx.cmn                 1	include file used by ciftbx (=.cmf+.cmv)
X ciftbx.cmv                 1	variables file used by ciftbx
X ciftbx.f                   1	CIF toolbox used by iterate.f
X ciftbx.sys                 1	include file used by ciftbx
X clearfp.f                  1	dummy routine called by ciftbx
X clearfp_sun.f              1	alternative to clearfp.f for SUN
X cryst1-2-cif.awk           1	awk script to extract cells from PDB
X hash_funcs.f               1	subroutines used by ciftbx
X iterate.csh.m4             1	m4 source of iterate.csh
X iterate.f                  1	source of program iterate
X iterate.html.m4            1	m4 source of iterate.html
X lgpl.txt                   1	license
END_OF_FILE
if test 1081 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(3903 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X#
X#  Makefile for ITERATE
X#
X#  Herbert J. Bernstein
X#  Lawrence C. Andrews
X#
X#  29 Sep 1996
X#  Rev 25 Sep 2008
X#
X#
X#  Modify the following definitions for your system
X#
X#  HTTPDSERVER is the name of the server on which the
X#  installation is being made
X#
X#  *************************************************
X#  *** YOU MUST CHANGE THIS DEFINITION TO PERMIT ***
X#  ***              REMOTE ACCESS                ***
X#  *************************************************
X#
XHTTPDSERVER	=	localhost
X#  The following are normal defaults for a system manager
X#  installation assuming an NCSA httpd default installation
X#
X#  BINDEST is the installation directory for the executable
X#  of ITERATE
XBINDEST		=	/usr/local/bin
X#
X#  CGIBIN is the installation directory for the cgi-bin script
X#  iterate.csh
XCGIBIN		=	/usr/local/etc/httpd/cgi-bin
X#
X#  CGIBINEXT is the external name of the directory for the
X#  cgi-bin script iterate.csh
XCGIBINEXT	=	/cgi-bin
X#
X#  HTDOCS is the installation directory for the HTML document
X#  iterate.html
XHTDOCS		=	/usr/local/etc/httpd/htdocs
X#
X#  For a user installation you need the system manager to have
X#  permitted cgi-bin execution from the directory given
X#  The following lines, with the $(USER) replaced by a valid
X#  user name are a possible start on user installation definitions
X#
X#USERNAME	=	$(USER)
X#BINDEST	=	/home/$(USERNAME)/bin
X#CGIBIN		=	/home/$(USERNAME)/public_html/cgi-bin
X#CGIBINEXT	=	/~$(USERNAME)/cgi-bin
X#HTDOCS		=	/home/$(USERNAME)/public_html
X#
X#  Default compile flag definition to select debug mode under unix
XFFLAGS	=	-g
X#
X#  For IBM AIX xlf compilation with full optimization try this
X#FFLAGS	=	-O3 -qstrict
X#FC	=	xlf
X#
XHTFLAGS 	=	-DFULLHTDOCS=$(CGIPATH)
X#
X#  For use of wwwcount2.3
X#HTFLAGS	=	-DFULLHTDOCS=$(CGIPATH) -DWWWCOUNT=TRUE
X#
X#
X#  You should not have to edit below this line
X#********************************************************************
X#
X#
XCGIPATH	=	http://$(HTTPDSERVER)$(CGIBINEXT)/iterate.csh
XBINPATH	=	$(BINDEST)/ITERATE
X#
Xall:		edit 
X#
Xedit:	
X		@/bin/echo "**************************************"
X		@/bin/echo "* You must edit Makefile before      *"
X		@/bin/echo "* installing ITERATE                 *"
X		@/bin/echo "* Then:                              *"
X		@/bin/echo "*     make edit_done                 *"
X		@/bin/echo "*     make all                       *"
X		@/bin/echo "**************************************"
X#
Xedit_done:	ITERATE iterate.html iterate.csh
X		touch edit
X#
Xclean:
X		-rm edit
X		-rm iterate.html
X		-rm ITERATE
X		-rm iterate.csh
X		-rm *.bak
X
X#
Xiterate.html:	iterate.html.m4 Makefile
X		m4 $(HTFLAGS) < iterate.html.m4 > iterate.html
X#
Xiterate.csh:	iterate.csh.m4 Makefile
X		m4 -DBINPATH=$(BINPATH) < iterate.csh.m4 > iterate.csh
X#
Xinstall:	ITERATE iterate.csh iterate.html iterate.cshar iterate.shar
X		-mkdir -p $(BINDEST)
X		-mkdir -p $(CGIBIN)
X		-mkdir -p $(HTDOCS)
X		chmod 755 ITERATE
X		chmod 755 iterate.csh
X		cp ITERATE $(BINDEST)
X		cp iterate.csh $(CGIBIN)
X		cp iterate.html $(HTDOCS)
X		cp iterate.cshar $(HTDOCS)
X		cp iterate.shar $(HTDOCS)
X#		
Xciftbx.o:	ciftbx.f ciftbx.sys ciftbx.cmn ciftbx.cmf ciftbx.cmv clearfp.f
Xhash_funcs.o:	hash_funcs.f
Xiterate.o:	iterate.f ITERATE.cmn ciftbx.cmn ciftbx.cmf ciftbx.cmv
XITERATE:	ITERATE.cmn iterate.o ciftbx.o hash_funcs.o 
X	$(FC) $(FFLAGS) -o ITERATE iterate.o ciftbx.o hash_funcs.o
X
Xiterate.shar:	MANIFEST README Makefile  iterate.f ITERATE.cmn \
X	ciftbx.f ciftbx.cmn ciftbx.sys ciftbx.cmf ciftbx.cmv hash_funcs.f \
X	iterate.html.m4 iterate.csh.m4 cryst1-2-cif.awk clearfp.f \
X        clearfp_sun.f lgpl.txt
X	-rm iterate.shar
X	makekit -s5000k -m
X	mv Part01 iterate.shar
X
Xiterate.cshar:	MANIFEST README Makefile  iterate.f ITERATE.cmn \
X	ciftbx.f ciftbx.cmn ciftbx.sys ciftbx.cmf ciftbx.cmv hash_funcs.f \
X	iterate.html.m4 iterate.csh.m4 cryst1-2-cif.awk clearfp.f \
X	clearfp_sun.f lgpl.txt
X	-rm iterate.cshar
X	makekit -c -s5000k -m
X	mv Part01 iterate.cshar
END_OF_FILE
if test 3903 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(14837 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
XREADME for ITERATE 29 Sep 96
X
XHerbert J. Bernstein, Bernstein + Sons
XLawrence C. Andrews, Thuridion, Inc.
X
XNOTICE
X
XSome of the software and documents included within this software
Xpackage are the intellectual property of various parties, and
Xplacement in this package does not in anyway imply that any such
Xrights have in any way been waived or diminished.
X
XWith respect to any software or documents for which a copyright
Xexists, ALL RIGHTS ARE RESERVED TO THE OWNERS OF SUCH COPYRIGHT.
X
XEven though the authors of the various documents and software found
Xhere have made a good faith effort to ensure that the documents are
Xcorrect and that the software performs according to its documentation,
Xand we would greatly appreciate hearing of any problems you may
Xencounter, the programs and documents any files created by the
Xprograms are provided **AS IS** without any warrantee as to
Xcorrectness, merchantability or fitness for any particular or general
Xuse.
X
XTHE RESPONSIBILITY FOR ANY ADVERSE CONSEQUENCES FROM THE USE OF
XPROGRAMS OR DOCUMENTS OR ANY FILE OR FILES CREATED BY USE OF THE
XPROGRAMS OR DOCUMENTS LIES SOLELY WITH THE USERS OF THE PROGRAMS OR
XDOCUMENTS OR FILE OR FILES AND NOT WITH AUTHORS OF THE PROGRAMS OR
XDOCUMENTS. 
X
X
X
XINSTALLATION
X
XBefore installation, ensure that you have a complete kit as
Xshown in the file MANIFEST.  If you think Makefile has been
Xcorrupted, make a fresh copy from Makefile_save.  The files
Xciftbx.f, ciftbx.cmn, ciftbx.cmf, ciftbx.cmv, ciftbx.sys and 
Xhash_funcs.f are from the CIFtbx2 kit.  They are needed in 
Xorder to read and write CIFs.  If you need an update to 
XCIFtbx2, see
X  http://ndbserver.rutgers.edu/software/ciftbx
X
XThe complete ITERATE suite consists of a the fortran
Xprogram ITERATE, an html web page iterate.html, and
Xa cgi-bin script iterate.csh.  The web page and script
Xneed some definitions for each system.  They are built
Xfrom m4 macro documents by make, using a command file
XMakefile, which must contain the appropriate definitions.
X
XIn order to install the program, you need to edit the file
XMakefile, setting the following parameters appropriately for
Xyour system:
X
XHTTPDSERVER is the name of the server on which the installation 
Xis being made.  YOU MUST CHANGE THIS DEFINITION TO PERMIT 
XREMOTE ACCESS.  The default definition is:
X
XHTTPDSERVER	=	localhost
X
XBINDEST is the installation directory for the executable of ITERATE.
XCGIBIN is the installation directory for the cgi-bin script iterate.csh
XCGIBINEXT is the external name of the directory for the cgi-bin 
Xscript iterate.csh. HTDOCS is the installation directory for the 
XHTML document iterate.html.  The following are normal defaults 
Xfor a system manager installation assuming an NCSA httpd default 
Xinstallation.
X
XBINDEST		=	/usr/local/bin
XCGIBIN		=	/usr/local/etc/httpd/cgi-bin
XCGIBINEXT	=	/cgi-bin
XHTDOCS		=	/usr/local/etc/httpd/htdocs
X
XFor a user installation you need the system manager to have permitted 
Xcgi-bin execution from the directory given.  The following lines, with 
Xthe "??????" replaced by a valid user name are a possible start on 
Xuser installation definitions
X
XUSERNAME	=	??????
XBINDEST		=	/home/$(USERNAME)/bin
XCGIBIN		=	/home/$(USERNAME)/public_html/cgi-bin
XCGIBINEXT	=	/~$(USERNAME)/cgi-bin
XHTDOCS		=	/home/$(USERNAME)/public_html
X
XThe default compile flag definition to select debug mode under unix is
X
XFFLAGS	=	-g
X
XFor IBM AIX xlf compilation with full optimization try this
X
XFFLAGS	=	-O3 -qstrict
XFC	=	xlf
X
XThe following flag normally does not need to be changed.
X
XHTFLAGS 	=	-DFULLHTDOCS=$(CGIPATH)
X
XHowever, for use with wwwcount2.3
X
XHTFLAGS	=	-DFULLHTDOCS=$(CGIPATH) -DWWWCOUNT=TRUE
X
XOnce you have completed your edit, then
X
X      make edit_done
X      make all
X
XIf you are the system manager and have set the definitions
Xappropriately, then you can use
X
X      make install
X
Xto install the program, web page and cgi-bin script.
X
XOPERATION
X
XThe program may be operated as a stand-alone program, reading
Xdata from stdin, writing output to stdout and messages to stderr.
XThree environment variables control the operation of the program
Xin stand-alone mode:
X
XITERATE_QUERY           set to NO if the program is to run a single pass
XOUTPUT_STYLE            set to CIF if the output is to be a CIF
XINPUT_STYLE             set to CIF if the input is to be a CIF
X
XIf the input is a CIF, the following tokens are expected:
X
X    _cell.entry_id           a character string to associate with the cell
X    _cell.space_group_name_H-M
X                             a space group symbol (used only for centering)
X    _cell.length_a           the length in Angstroms of cell edge a with esd
X    _cell.length_b           the length in Angstroms of cell edge b with esd
X    _cell.length_c           the length in Angstroms of cell edge c with esd
X    _cell.angle_alpha        the cell angle alpha in degrees with esd
X    _cell.angle_beta         the cell angle beta in degrees with esd
X    _cell.angle_gamma        the cell angle gamma in degrees with esd
X
XWhen esd's are given they should be given as parenthesized digits, as
Xin
X    _cell.length_a    100.5(3)
Xfor a cell edge of 100.5 +/- .3
X
XWhen no esd's are given the program forces in minimal defaults.
X
XIf the input is not a CIF, then the information to be provided is
Xa lattice centering symbol (P, F, etc.), then a line with three
Xcell edge lengths and angles, and finally a line with with three
Xedge length esd's in Angstroms (not final digits) and cell angle esd's
Xin degrees.
X
XIf the output is a cif, the following tokens are used:
X
X        data_G6_SEARCH
X        loop_
X        _cell.entry_id
X        _cell.id
X        _cell.space_group_name_H-M
X        _cell.Bravais_lattice_symbol
X        _cell.length_a
X        _cell.length_b
X        _cell.length_c
X        _cell.angle_alpha
X        _cell.angle_beta
X        _cell.angle_gamma
X        _cell.unreduced_length_a
X        _cell.unreduced_length_b
X        _cell.unreduced_length_c
X        _cell.unreduced_angle_alpha
X        _cell.unreduced_angle_beta
X        _cell.unreduced_angle_gamma
X
XThe last six are used to report the centered, rather than primitive
Xcell.
X
X
XSAMPLE WEB PAGE
X   
XG6 Bravais Lattice Determination Interface 
X
X   
X   
X   by
X   
X   Lawrence C. Andrews, Thuridion, Inc., andrews@thuridion.com and
X   Herbert J. Bernstein, Bernstein+Sons, yaya@aip.org
X   ______ _____
X   Output Style: [text]
X   
X  Select the crystal lattice centering:[P (primitive)...........]
X  
X  Specify the cell edge lengths and angles:
X  
X   
X   _cell.length_a _________ _cell.angle_alpha _________
X   _cell.length_b _________ _cell.angle_beta _________
X   _cell.length_c _________ _cell.angle_gamma _________
X   
X  Specify the cell edge length esd's and angle esd's:
X  
X   
X   _cell.length_a_esd _________ _cell.angle_alpha_esd _________
X   _cell.length_b_esd _________ _cell.angle_beta_esd _________
X   _cell.length_c_esd _________ _cell.angle_gamma_esd _________
X   
X     _________________________________________________________________
X     _________________________________________________________________
X   
XWhat Does This Web Page Do? 
X
X   
X   
X   In simple terms, what this page does is to find the cells which are
X   "close" to the cell given, in order to help find the Bravais lattice
X   of highest symmetry consistent with the cell.
X   
X   A central problem in the solution of every crystal structure is to
X   determine the correct Bravais lattice of the crystal. The Bravais
X   lattices as they are usually listed are:
X   
X   aP triclinic (anorthic) primitive
X   mP monoclinic primitive
X   mS monoclinic side-centered (usually C-centered)
X   oP orthorhombic primitive
X   oS orthorhombic side-centered
X   oF orthorhombic face-centered
X   oI orthorhombic body-centered
X   hP hexagonal primitive
X   hR hexagonal rhombohedrally-centered
X   tP tetragonal primitive
X   tI tetragonal body-centered
X   cP cubic primitive
X   cF cubic face-centered
X   cI cubic body-centered
X   
X   
X   Failure to find the highest correct symmetry has several consequences,
X   the worst of which is that the structure may not be solved. The least
X   of the consequences is that Richard Marsh may publish a paper that
X   points out the error, corrects it, and finds a better solution to the
X   structure. Many methods have been described for finding the correct
X   Bravais lattice. A summary of the published methods was published in
X   the paper that described the G6 formalism (which is used in the
X   program on this web page).
X   
X   "Lattices and Reduced Cells as Points in 6-Space and Selection of
X   Bravais Lattice Type by Projections." Lawrence C. Andrews and Herbert
X   J. Bernstein, Acta Crystallographica, A44, 1009-1018 (1988).
X   
X   The program on this Web page implements a search in G6 for the various
X   Bravais lattices that the user's cell may fit. For each lattice type,
X   the best metric match is reported. If the higher symmetry type is
X   actually correct, then that is likely to be the best cell from which
X   to start further refinement. However, the possibility exists that one
X   of the rejected cells (which did not match as well) was actually the
X   correct one to use. The reason for this ambiguity is experimental
X   error and its propagation in the transformations of the lattices in
X   the program. Fortunately, the rejected cells are usually quite similar
X   to the accepted one.
X   
X   A note on standard deviations: First, even in the best of
X   circumstances, standard deviations of unit cell dimensions from
X   4-circle diffractometer data are always underestimated (by at least a
X   factor of 2). In addition, the points chosen for the determination are
X   often not well distributed (for example all in the first octant of
X   orthorhombic lattices). These less than optimal choices cause
X   substantial systematic error. The experimental errors are amplified in
X   the mathematical conversions between various lattices that any lattice
X   search program must perform. It is not a rare occurrence for angles to
X   be incorrect by 0.5 degrees in initial unit cell determinations.
X   
X   Note: Even in most well determined unit cells, the actual errors in
X   the edge lengths is 0.2 to 0.5 parts per thousand. (Note that
X   reproducibility of the measurements is substantially better, leading
X   to the illusion that diffractometers produce excellent unit cell
X   parameters). Use of standard deviations that are too small is a common
X   reason for failure of Bravais lattice searches. For small molecules,
X   0.1 Angstroms is a reasonable error for the edge lengths, for
X   proteins, 0.4 to 0.5 (or even more for preliminary measurements).
X   Accurate unit cell parameters must by determined by a number of more
X   complex methods and must include extrapolation to remove systematic
X   effects. For an excellent summary, see "Xray Structure Determination",
X   G.H.Stout and L.H.Jensen, Wiley, 1989.
X
X
X
XSAMPLE TEXT OUTPUT
X
X
X  # G6 Lattice Identification
X  
X   
X   
X   # Centering: P
X   
X   # Cell: 10. 10. 10. 90. 90. 90.
X   
X   # Sigmas: .15 .15 .15 .2 .2 .2
X   
X  # Results of ITERATE Run
X
X  # Input Lattice Symbol  P
X
X  # INPUT CELL AND ERRORS       INPUT VECTOR AND ERRORS
X
X  #      10.000       .150           100.000       3.00
X  #      10.000       .150           100.000       3.00
X  #      10.000       .150           100.000       3.00
X  #      90.000       .200              .000        .70
X  #      90.000       .200              .000        .70
X  #      90.000       .200              .000        .70
X
X
X  # INPUT VECTOR SIZE AND ERROR AND RATIO     173.21      5.33       .03
X
X  # REDUCED CELL
X  # Red. Cell       10.000    10.000    10.000    90.000    90.000    90.000
X  # Red. Vector    100.00   100.00   100.00      .00      .00      .00
X
X
X   1   cP #     .00 = Distance Projected    Internat. Tables#( 3)
X  #    Vector          100.0   100.0   100.0      .0      .0      .0
X  #    cell
X               10.00   10.00   10.00    90.00   90.00   90.00
X  #  primitive         10.000
X
X  #    transformation from 3-space original cell
X  #    to final primitive cell
X  #           1.000   .000   .000
X  #            .000  1.000   .000
X  #            .000   .000  1.000
X
X
X
X   4   tP #     .00 = Distance Projected    Internat. Tables#(11)
X  #    Vector          100.0   100.0   100.0      .0      .0      .0
X  #    cell
X               10.00   10.00   10.00    90.00   90.00   90.00
X  #  primitive         10.000    10.000
X
X  #    transformation from 3-space original cell
X  #    to final primitive cell
X  #           1.000   .000   .000
X  #            .000  1.000   .000
X  #            .000   .000  1.000
X
X
X
X  10   hR #     .00 = Distance Projected    Internat. Tables#( 2)
X  #    Vector          100.0   100.0   100.0      .0      .0      .0
X  #    cell
X               10.00   10.00   10.00    90.00   90.00   90.00
X  #  as rhomboh.       10.000   alpha      90.000
X
X  #    transformation from 3-space original cell
X  #    to final primitive cell
X  #           1.000 -1.000   .000
X  #          -1.000   .000  1.000
X  #          -1.000 -1.000 -1.000
X
X
X
X  12   oP #     .00 = Distance Projected    Internat. Tables#(32)
X  #    Vector          100.0   100.0   100.0      .0      .0      .0
X  #    cell
X               10.00   10.00   10.00    90.00   90.00   90.00
X  #  primitive         10.000    10.000    10.000
X
X  #    transformation from 3-space original cell
X  #    to final primitive cell
X  #           1.000   .000   .000
X  #            .000  1.000   .000
X  #            .000   .000  1.000
X
X
X
X  14   oS #     .00 = Distance Projected    Internat. Tables#(13)
X  #    Vector          100.0   100.0   100.0      .0      .0      .0
X  #    cell
X               10.00   10.00   10.00    90.00   90.00   90.00
X  #  side-centered     14.142    14.142    10.000
X
X  #    transformation from 3-space original cell
X  #    to final centered cell
X  #           1.000  1.000   .000
X  #          -1.000  1.000   .000
X  #            .000   .000  1.000
X
X
X
X  20   mP #     .00 = Distance Projected    Internat. Tables#(33)
X  #    Vector          100.0   100.0   100.0      .0      .0      .0
X  #    cell
X               10.00   10.00   10.00    90.00   90.00   90.00
X  #  primitive         10.000    10.000    10.000   beta       90.000
X
X  #    transformation from 3-space original cell
X  #    to final primitive cell
X  #           1.000   .000   .000
X  #            .000  1.000   .000
X  #            .000   .000  1.000
X
X
X
X  22   mS #     .00 = Distance Projected    Internat. Tables#(10)
X  #    Vector          100.0   100.0   100.0      .0      .0      .0
X  #    cell
X               10.00   10.00   10.00    90.00   90.00   90.00
X  #  side-centered     14.142    14.142    10.000   beta       90.000
X
X  #    transformation from 3-space original cell
X  #    to final centered cell
X  #           1.000  1.000   .000
X  #          -1.000  1.000   .000
X  #            .000   .000  1.000
END_OF_FILE
if test 14837 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'ciftbx.cmf' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ciftbx.cmf'\"
else
echo shar: Extracting \"'ciftbx.cmf'\" \(3675 characters\)
sed "s/^X//" >'ciftbx.cmf' <<'END_OF_FILE'
XC
XC >>>>>> Function declararations 'ciftbx.cmf'
XC
XC
XC        These external declarations are needed complete
XC        the user definitions in ciftbx.cmn
XC           
XC
XC                                 Logical function init_
X         logical   init_
XC                                 Logical function dict_
X         logical   dict_
XC                                 Logical function ocif_
X         logical   ocif_
XC                                 Logical function data_
X         logical   data_
XC                                 Logical function test_
X         logical   test_
XC                                 Logical function bkmrk_
X         logical   bkmrk_
XC                                 Logical function find_
X         logical   find_
XC                                 Logical function name_
X         logical   name_
XC                                 Logical function numb_
X         logical   numb_
XC                                 Logical function numd_
X         logical   numd_
XC                                 Logical function char_
X         logical   char_
XC                                 Logical function cmnt_
X         logical   cmnt_
XC                                 Logical function pfile_
X         logical   pfile_
XC                                 Logical function pdata_
X         logical   pdata_
XC                                 Logical function pchar_
X         logical   pchar_
XC                                 Logical function pcmnt_
X         logical   pcmnt_
XC                                 Logical function pnumb_
X         logical   pnumb_
XC                                 Logical function pnumd_
X         logical   pnumd_
XC                                 Logical function ptext_
X         logical   ptext_
XC                                 Logical function ploop_
X         logical   ploop_
XC                                 Logical function prefx_
X         logical   prefx_
XC
XC                                 logical function init_
X         external   init_
XC                                 logical function dict_
X         external   dict_
XC                                 logical function ocif_
X         external   ocif_
XC                                 logical function data_
X         external   data_
XC                                 logical function test_
X         external   test_
XC                                 logical function bkmrk_
X         external   bkmrk_
XC                                 logical function find_
X         external   find_
XC                                 logical function name_
X         external   name_
XC                                 logical function numb_
X         external   numb_
XC                                 logical function numd_
X         external   numd_
XC                                 logical function char_
X         external   char_
XC                                 logical function cmnt_
X         external   cmnt_
XC                                 logical function pfile_
X         external   pfile_
XC                                 logical function pdata_
X         external   pdata_
XC                                 logical function pchar_
X         external   pchar_
XC                                 logical function pcmnt_
X         external   pcmnt_
XC                                 logical function pnumb_
X         external   pnumb_
XC                                 logical function pnumd_
X         external   pnumd_
XC                                 logical function ptext_
X         external   ptext_
XC                                 logical function ploop_
X         external   ploop_
XC                                 logical function prefx_
X         external   prefx_
END_OF_FILE
if test 3675 -ne `wc -c <'ciftbx.cmf'`; then
    echo shar: \"'ciftbx.cmf'\" unpacked with wrong size!
fi
# end of 'ciftbx.cmf'
fi
if test -f 'ciftbx.cmn' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ciftbx.cmn'\"
else
echo shar: Extracting \"'ciftbx.cmn'\" \(203 characters\)
sed "s/^X//" >'ciftbx.cmn' <<'END_OF_FILE'
X
XC
XC >>>>>> Common and Function declararations 'ciftbx.cmn'
XC
XC        These declarations must be included in ciftbx user
XC        applications.
XC
X      include  'ciftbx.cmv'
X      include  'ciftbx.cmf'
END_OF_FILE
if test 203 -ne `wc -c <'ciftbx.cmn'`; then
    echo shar: \"'ciftbx.cmn'\" unpacked with wrong size!
fi
# end of 'ciftbx.cmn'
fi
if test -f 'ciftbx.cmv' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ciftbx.cmv'\"
else
echo shar: Extracting \"'ciftbx.cmv'\" \(4220 characters\)
sed "s/^X//" >'ciftbx.cmv' <<'END_OF_FILE'
XC
XC >>>>>> Common declararations 'ciftbx.cmn'
XC
XC        These declarations must be included in ciftbx user
XC        applications.
XC
XC
XC        Parameters to control sizes
XC
XC                                 Maximum number of characters in
XC                                 data names
X         integer NUMCHAR
X         PARAMETER (NUMCHAR=48)
XC                                 Maximum number of characters in
XC                                 a line
X         integer MAXBUF
X         PARAMETER (MAXBUF=200)
XC           
XC
XC                                 Align loop active flag (true/false)
X         logical   align_
XC                                 Set loop tabs flag (true/false)
X         logical   tabl_
XC                                 Input tab expansion flag (true/false)
X         logical   tabx_
XC                                 Output tab expansion flag (true/false)
X         logical   ptabx_
XC                                 Text active flag (true/false)
X         logical   text_
XC                                 Loop active flag (true/false)
X         logical   loop_
XC                                 Save frame active flag (true/false)
X         logical   save_
XC                                 Save frame output flag (true/false)
X         logical   saveo_
XC                                 Alias use flag (true/false)
X         logical   alias_
XC                                 Alias output mapping flag (true/false)
X         logical   aliaso_
XC                                 Length of current data item in strg_
X         integer   long_
XC                                 Loop block number of current item    
X         integer   list_
XC                                 Length of current filename in file_
X         integer   longf_
XC                                 Integer limit on esd's (9, 19, 29, etc.)
X         integer   esdlim_
XC                                 User setable input line value
X         integer   line_
XC                                 Record number of last input line
X         integer   recn_
XC                                 Record number of last last line
X         integer   precn_
XC                                 Character position of data name
X         integer   posnam_
XC                                 Character position of data value
X         integer   posval_
XC                                 Character position of decimal point
X         integer   posdec_
XC                                 Character position of end of field
X         integer   posend_
XC                                 Character position of output data name
X         integer   pposnam_
XC                                 Character position of output data value
X         integer   pposval_
XC                                 Character position of output decimal point
X         integer   pposdec_
XC                                 Character position of end of output field
X         integer   pposend_
XC                                 Name of current data block
X         character bloc_*(NUMCHAR)
XC                                 Character image of current data item
X         character strg_*(MAXBUF)
XC                                 File name of current CIF
X         character file_*(MAXBUF)
XC                                 Data item type
X         character type_*4
XC                                 Data type (May be more precise than type_)
X         character*(NUMCHAR) dictype_
XC                                 Data category
X         character*(NUMCHAR) diccat_
XC                                 Data alias root name
X         character*(NUMCHAR) dicname_
XC                                 Input CIF tag name
X         character*(NUMCHAR) tagname_
XC                                 Quoted input string flag
X         character quote_*1
XC                                 Quoted output string flag
X         character pquote_*1
XC
X         common/tbuc/ strg_,bloc_,file_,type_,dictype_,diccat_,
X     *     dicname_,tagname_,quote_,pquote_
XC
X         common/tbui/ list_,long_,longf_,line_,esdlim_,recn_,precn_,
X     *     posnam_,posval_,posdec_,posend_,
X     *     pposnam_,pposval_,pposdec_,pposend_
XC
X         common/tbul/ loop_,text_,align_,save_,saveo_,aliaso_,alias_,
X     *     tabl_,tabx_,ptabx_
END_OF_FILE
if test 4220 -ne `wc -c <'ciftbx.cmv'`; then
    echo shar: \"'ciftbx.cmv'\" unpacked with wrong size!
fi
# end of 'ciftbx.cmv'
fi
if test -f 'ciftbx.f' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ciftbx.f'\"
else
echo shar: Extracting \"'ciftbx.f'\" \(125819 characters\)
sed "s/^X//" >'ciftbx.f' <<'END_OF_FILE'
XC
XC
XC    \ | /            /##|    @@@@  @   @@@@@   |      |              @@@
XC     \|/ STAR       /###|   @      @   @     __|__    |             @   @
XC  ----*----        /####|  @       @   @@@@    |      |___  __  __     @
XC     /|\          /#####|   @      @   @       |      |   \   \/      @
XC    / | \         |#####|    @@@@  @   @       \___/  \___/ __/\__  @@@@@
XC                  |#####|________________________________________________
XC                 ||#####|                 ___________________            |
XC        __/|_____||#####|________________|&&&&&&&&&&&&&&&&&&&||          |
XC<\\\\\\\\_ |_____________________________|&&&& Sep 26 96 &&&&||          |
XC          \|     ||#####|________________|&&&&&&&&&&&&&&&&&&&||__________|
XC                  |#####|
XC                  |#####|                Version 2.5.1 Release
XC                  |#####|
XC                 /#######\ 
XC                |#########|
XC                    ====
XC                     ||
XC           An extended tool box of fortran routines for manipulating CIF data.
XC                     ||
XC                     ||  CIFtbx Version 2
XC                     ||        by
XC                     ||
XC                     ||  Sydney R. Hall (syd@crystal.uwa.edu.au)
XC                     ||  Crystallography Centre
XC                     ||  University of Western Australia
XC                     ||  Nedlands 6009, AUSTRALIA
XC                     ||
XC                     ||       and
XC                     ||
XC                     ||  Herbert J. Bernstein (yaya@bernstein-plus-sons.com)
XC                     ||  Bernstein + Sons
XC                     ||  5 Brewster Lane
XC                     ||  Bellport, NY 11713, U.S.A.
XC                     ||
XC The latest program source and information is available from:
XC                     ||
XC Em: syd@crystal.uwa.edu.au       ,-_|\      Sydney R. Hall
XC sendcif@crystal.uwa.edu.au      /     \     Crystallography Centre
XC Fx: +61 9 380 1118  ||      --> *_,-._/     University of Western Australia
XC Ph: +61 9 380 2725  ||               v      Nedlands 6009, AUSTRALIA
XC                     ||
XC                     ||
XC_____________________||_____________________________________________________
XC
XC This is a version of CIFtbx which has been extended to work with DDL 2
XC and mmCIF as well as with DDL 1.4 and core CIF dictionaries.  CIFtbx
XC version 1 was written by Sydney R. Hall (see Hall, S. R., "CIF Applications
XC IV.  CIFtbx: a Tool Box for Manipulating CIFs,"  J. Appl. Cryst (1993). 26,
XC 482-494.  The revisions for version 2 were done by Herbert J. Bernstein
XC and Sydney R. Hall (see Hall, S. R. and Bernstein, H. J., "CIFtbx 2:
XC Extended Tool Box for Manipulating CIFs," J. Appl. Cryst., to appear.) 
XC
XC___________________________________________________________________________
XC
XC
XC    GENERAL TOOLS
XC
XC
XC    init_      Sets the device numbers of files.   (optional)
XC               [logical function always returned .true.]
XC
XC               <input CIF dev number> Set input CIF device     (def=1)
XC
XC               <output CIF dev number>Set output CIF device    (def=2)
XC
XC               <diracc dev number>    Set direct access formatted
XC                                      scratch device number    (def=3)
XC
XC               <error  dev number>    Set error message device (def=6)
XC
XC
XC
XC    dict_      Requests a CIF dictionary be used for various data checks.
XC               [logical function returned as .true. if the name dictionary
XC               was opened; and if the check codes are recognisable.  The
XC               data item names used in the first dictionary loaded are
XC               considered to be preferred by the user to aliases found
XC               in dictionaries loaded in later calls]
XC
XC               <dictionary filename>  A CIF dictionary in DDL format
XC                                      or blank if just setting flags
XC                                      or resetting the dictionary
XC
XC               <check code string>    The codes specifying the types of 
XC                                      checks to be applied to the CIF.
XC
XC                                      'valid'  data name validation check.
XC                                      'dtype'  data item data type check.
XC                                      'reset'  switch off checking flags
XC                                      'close'  close existing dictionaries
XC
XC___________________________________________________________________________
XC
XC
XC   CIF ACCESS TOOLS  ("the get_ing commands")
XC
XC
XC
XC    ocif_      Opens the CIF containing the required data.
XC               [logical function returned .true. if CIF opened]
XC
XC               <CIF filename>        A blank name signals that the
XC                                     currently open input CIF file
XC                                     will be read.
XC
XC
XC
XC    data_      Identifies the data block containing the data to be requested. 
XC               [logical function returned .true. if block found]
XC
XC               <data block name>     A blank name signals that the next
XC                                     encountered block is used (the block
XC                                     name is stored in the variable bloc_).
XC
XC
XC    bkmrk_     Saves or restores the current position so that data from 
XC               elsewhere in the cif can be examined.
XC               [logical function returned as .true. on save if there was
XC               room in internal storage to hold the current position, .true.
XC               on restore if the bookmark number used was valid.  If the
XC               argument is zero, the call is to save the position and return
XC               the bookmark number in the argument.  If the argument is
XC               non-zero, the call is to restore the position saved for the
XC               bookmark number given.  The bookmark and the argument are
XC               cleared.  The position set on return allow reprocessing of
XC               the data item or loop row last processed when the bookmark
XC               was placed.
XC
XC               NOTE:  All bookmarks are cleared by a call to data_]
XC
XC               <integer variable>    Bookmark number
XC
XC
XC    find_      Find the location of the requested item in the CIF.
XC               [The argument "name" may be a data item name, blank
XC               for the next such item.  The argument "type" may be
XC               blank for unrestricted acceptance of any non-comment
XC               string (use cmnt_ to see comments), including loop headers,
XC               "name" to accept only the name itself and "valu"
XC               to accept only the value, or "head" to position to the
XC               head of the CIF.  Except when the "head" is requested,
XC               the position is left after the data item provided.  If the
XC               item found is of type "name", posnam_ is set, otherwise, 
XC               posval_]
XC
XC               <data item name>      A blank name signals that the next
XC                                     item of the type specified is needed
XC
XC               <data item type>      blank, 'head', 'name' or 'valu'
XC
XC               <character variable>  Returned string is of length long_.
XC
XC
XC
XC    test_      Identify the data attributes of the named data item.
XC               [logical function returned as .true. if the item is present or
XC               .false. if it is not. The data attributes are stored in the
XC               common variables list_, type_, dictype_, diccat_ and dicname_. 
XC               The values in dictype_, diccat_ and dicname_ are valid
XC               whether or not the data item is found in the input CIF, as
XC               long as the named data item is found in the dictionaries
XC               declared by calls to dict_.  The data item name found
XC               in the input CIF is stored in tagname_.  The appropriate
XC               column numbers are stored in posnam_, posval_, posend_ and (for
XC               numbers) in posdec_.  The quoation mark, if any, used is
XC               stored in quote_.
XC
XC               list_ is an integer variable containing the sequential number
XC               of the loop block in the data block. If the item is not within
XC               a loop structure this value will be zero.
XC
XC               type_ is a character*4 variable with the possible values:
XC                      'numb'  for number data
XC                      'char'  for character data
XC                      'text'  for text data
XC                      'null'  if data missing or '?' or '.'
XC
XC               dictype_ is a character*(NUMCHAR) variable with the type code
XC               given in the dictionary entry for the named data item.  If
XC               no dictionary was used, or no type code was specified, this
XC               field will simply agree with type_.  If a dictionary was used,
XC               this type may be more specific than the one given by type_.
XC
XC               diccat_ is a character*(NUMCHAR) variable with the category
XC               of the named data item, or '(none)'
XC
XC               dicname_ is a character*(NUMCHAR) variable with the name of
XC               the data item which is found in the dictionary for the
XC               named data item.  If alias_ is .true., this name may
XC               differ from the name given in the call to test_.  If alias_
XC               is .false. or no preferred alias is found, dicname_ agrees with
XC               the data item name.
XC
XC               tagname_ is a character*(NUMCHAR) variable with the name
XC               of the data item as found in the input CIF.  It will be
XC               blank if the data item name requested is not found in the
XC               input CIF and may differ from the data item name provided
XC               by the user if the name used in the input CIF is an
XC               alias of the data item name and alias_ is .true.
XC
XC               posnam_, posval_, posend_  and posdec_ are integer variables
XC               which may be examined if information about the horizontal
XC               position of the name and data read are needed.  posnam_ is the
XC               starting column of the data name found (most often 1).
XC               posval_ is the starting column of the data value.  If the
XC               field is numeric, then posdec_ will contain the effective
XC               column number of the decimal point.  For whole numbers, the
XC               effective position of the decimal point is one column to the
XC               right of the field.  posend_ contains the ending column of the
XC               data value.
XC
XC               quote_ is a character*1 varibale which may be examined to
XC               determine if a quotation character was used on character data.]
XC
XC               <data name>           Name of the data item to be tested.
XC
XC
XC
XC    name_      Get the NEXT data name in the current data block.
XC               [logical function returned as .true. if a new data name exists
XC               in the current data block, and .false. when the end of the data
XC               block is reached.]
XC
XC               <data name>           Returned name of next data item in block.
XC
XC
XC
XC    numb_      Extracts the number and its standard deviation (if appended).
XC               [logical function returned as .true. if number present. If
XC               .false. arguments 2 and 3 are unaltered. If the esd is not
XC               attached to the number argument 3 is unaltered.]
XC
XC               <data name>           Name of the number sought.
XC
XC               <real variable>       Returned number.
XC
XC               <real variable>       Returned standard deviation.
XC
XC
XC
XC    numd_      Extracts the number and its standard deviation (if appended)
XC               as double precision variables.
XC               [logical function returned as .true. if number present. If
XC               .false. arguments 2 and 3 are unaltered. If the esd is not
XC               attached to the number argument 3 is unaltered.]
XC
XC               <data name>           Name of the number sought.
XC
XC               <double precision variable>
XC                                     Returned number.
XC
XC               <double precision variable>
XC                                     Returned standard deviation.
XC
XC
XC
XC    char_      Extracts character and text strings.
XC               [logical function returned as .true. if the string is present.
XC               Note that if the character string is text this function is 
XC               called repeatedly until the logical variable text_ is .false.]
XC
XC               <data name>           Name of the string sought.
XC
XC               <character variable>  Returned string is of length long_.
XC
XC
XC    cmnt_      Extracts the next comment from the data block.
XC               [logical function returned as .true. if a comment is present.
XC               The initial comment character "#" is _not_ included in the
XC               returned string.  A completely blank line is treated as
XC               a comment.]
XC
XC               <character variable>  Returned string is of length long_.
XC
XC
XC
XC    purge_     Closes existing data files and clears tables and pointers.
XC               [subroutine call]        
XC
XC____________________________________________________________________________
XC
XC
XC
XC   CIF CREATION TOOLS ("the put_ing commands")
XC
XC
XC
XC    pfile_     Create a file with the specified file name.
XC               [logical function returned as .true. if the file is opened.
XC               The value will be .false. if the file already exists.]
XC
XC               <file name>           Blank for use of currently open file
XC
XC
XC
XC    pdata_     Put a data block command into the created CIF. 
XC               [logical function returned as .true. if the block is created.
XC               The value will be .false. if the block name already exists.
XC               Produces a save frame instead of a data block if the
XC               variable saveo_ is true during the call.  No block duplicate
XC               check is made for a save frame.]
XC
XC               <block name>
XC
XC
XC
XC    ploop_     Put a loop_ data name into the created CIF.             
XC               [logical function returned as .true. if the invocation 
XC               conforms with the CIF logical structure.  If pposval_ 
XC               is non-zero, the "loop_" header is positioned to 
XC               that column.  If pposnam_ is non-zero, the data name is 
XC               positioned to that column.]
XC
XC               <data name>         If the name is blank on the first call
XC                                   of a loop, only the "loop_" is placed.
XC
XC
XC
XC    pchar_     Put a character string into the created CIF.             
XC               [logical function returned as .true. if the name is unique,
XC               AND, if dict_ is invoked, is a name defined in the dictionary, 
XC               AND, if the invocation conforms to the CIF logical structure.]
XC
XC               <data name>         If the name is blank, do not output name.
XC
XC               <character string>  A character string of MAXBUF chars or less.
XC
XC
XC
XC    pcmnt_     Puts a comment into the created CIF.
XC               [logical function returned as .true.  The comment character
XC               "#" should not be included in the string.  A blank comment
XC               is presented as a blank line without the leading "#"].
XC
XC               <character string>  A character string of MAXBUF chars or less.
XC
XC
XC    pnumb_     Put a single precision number and its esd into the created CIF.
XC               [logical function returned as .true. if the name is unique,
XC               AND, if dict_ is invoked, is a name defined in the dictionary, 
XC               AND, if the invocation conforms to the CIF logical structure.
XC               The number of esd digits is controlled by the variable
XC               esdlim_]
XC
XC               <data name>         If the name is blank, do not output name.
XC
XC               <real variable>     Number to be inserted.
XC
XC               <real variable>     Esd number to be appended in parentheses.
XC
XC
XC    pnumd_     Put a double precision number and its esd into the created CIF.
XC               [logical function returned as .true. if the name is unique,
XC               AND, if dict_ is invoked, is a name defined in the dictionary, 
XC               AND, if the invocation conforms to the CIF logical structure.
XC               The number of esd digits is controlled by the variable
XC               esdlim_]
XC
XC               <data name>         If the name is blank, do not output name.
XC
XC               <double precision variable>  
XC                                   Number to be inserted.
XC
XC               <double precision variable>  
XC                                   Esd number to be appended in parentheses.
XC
XC
XC
XC    ptext_     Put a character string into the created CIF.             
XC               [logical function returned as .true. if the name is unique,
XC               AND, if dict_ is invoked, is a name defined in the dictionary, 
XC               AND, if the invocation conforms to the CIF logical structure.]
XC               ptext_ is invoked repeatedly until the text is finished. Only
XC               the first invocation will insert a data name.
XC
XC               <data name>         If the name is blank, do not output name.
XC
XC               <character string>  A character string of MAXBUF chars or less.
XC
XC
XC    prefx_     Puts a prefix onto subsequent lines of the created CIF.
XC               [logical function returned as .true.  The second argument
XC               may be zero to suppress a previously used prefix, or
XC               greater than the non-blank length of the string to force
XC               a left margin.  Any change in the length of the prefix 
XC               string flushes pending partial output lines, but does _not_
XC               force completion of pending text blocks or loops.
XC               This function allows the CIF output functions to be used 
XC               within what appear to be text fields to support annotation 
XC               of a CIF. ]
XC
XC               <character string>  A character string of MAXBUF chars or less.
XC
XC               <integer variable>  The length of the prefix string to use.
XC
XC
XC
XC
XC    close_     Close the creation CIF. MUST be used if pfile_ is used.
XC               [subroutine call]
XC
XC
XC____________________________________________________________________________
XC
XC
XC
XC....The CIF tool box also provides variables for data access control:
XC 
XC
XC    alias_      Logical variable: if left .true. then all calls to
XC                CIFtbx functions may use aliases of data item names.
XC                The preferred synonym from the dictionary will be
XC                subsituted internally, provided aliased data names were
XC                supplied by an input dictionary (via dict_).  The
XC                default is .true., but alias_ may be set to .false.
XC                in an application.
XC
XC    aliaso_     Logical variable: if set .true. then cif output 
XC                routines will convert aliases to the names to preferred
XC                synonyms from the dictionary.  The default is .false., but
XC                aliaso_ may be set to .true. in an application.  The
XC                setting of aliaso_ is independent of the setting of
XC                alias_.
XC
XC    align_      Logical variable signals alignment of loop_ lists during
XC                the creation of a CIF. The default is .true.
XC
XC    bloc_       Character*(NUMCHAR) variable: the current block name.
XC
XC    dictype_    Character*(NUMCHAR) variable: the precise data type code
XC                (see test_)
XC
XC    diccat_     Character*(NUMCHAR) variable: the category (see test_)
XC
XC    dicname_    Character*(NUMCHAR) variable: the root alias (see test_)
XC
XC    esdlim_     Integer variable:  Specifies the upper limit of esd's
XC                produced by pnumb_, and, implicitly, the lower limit.
XC                The default value is 19, which limits esd's to the range
XC                2-19.  Typical values of esdlim_ might be 9 (limiting
XC                esd's to the range 1-9), 19, or 29 (limiting esd's
XC                to the range 3-29)
XC
XC    file_       Character*(MAXBUF) variable: the filename of the current file.
XC
XC    line_       Integer variable: Specifies the input/output line limit
XC                for processing a CIF. The default value is 80 characters.
XC                This may be set by the program. The max value is MAXBUF
XC                which has a default value of 200.
XC
XC    list_       Integer variable: the loop block number (see test_).
XC
XC    long_       Integer variable: the length of the data string in strg_.
XC
XC    longf_      Integer variable: the length of the filename in file_.
XC
XC    loop_       Logical variable signals if another loop packet is present.
XC
XC    pposdec_    Integer variable giving the position of the decimal point
XC                for the next number to be written.
XC
XC    pposend_    Integer variable giving the ending column of the next
XC                number or quoted character value to be written.  Used to
XC                pad with zeros or blanks.
XC
XC    pposnam_    Integer variable giving the starting column of the next
XC                name or comment or data block to be written.
XC
XC    pposval_    Integer variable giving the starting column of the next
XC                data value to be written by pchar_, pnumb_ or pnumd_.
XC                Also used to set the position of the initial "loop_"
XC                in a ploop_ call or to set the position of a terminal "save_"
XC                for a save frame in a pdata_ call for which saveo_ is .true.
XC
XC    posdec_     Integer variable giving the position of the decimal point
XC                for the last number read.
XC
XC    posend_     Integer variable giving the ending column of the last
XC                data value read, not including a terminal quote.
XC
XC    posnam_     Integer variable giving the starting column of the last
XC                name or comment or data block read.
XC
XC    posval_     Integer variable giving the starting column of the last
XC                data value read.  Also reports the column of the
XC                terminal "save_" of a save frame.
XC
XC    pquote_     Character variable giving the quotation symbol to be
XC                used for the next string written.
XC
XC    precn_      Integer variable:  Reports the record number of the last
XC                line written to the output cif.  Set to zero by init_.  Also
XC                set to zero by pfile_ and close_ if the output cif file name
XC                was not blank.
XC
XC    ptabx_      Logical variable signals tab character expansion to blanks 
XC                during the creation of a CIF. The default is .true.
XC
XC    quote_      Character variable giving the quotation symbol found
XC                delimiting the last string read.
XC
XC    recn_       Integer variable:  Reports the record number of the last
XC                line read from the direct access copy of the input cif.
XC
XC    save_       Logical variable signals that the current data block
XC                is actually a save-frame (.true. for a save-frame).
XC
XC    saveo_      Logical variable signals that the output data block from
XC                pdata_ is actually a save-frame (.true. for a save-frame).
XC
XC    strg_       Character*(MAXBUF) variable: the current data item.
XC
XC    tabl_       Logical variable signals tab-stop alignment of output 
XC                during the creation of a CIF. The default is .true.
XC
XC    tabx_       Logical variable signals tab character expansion to blanks 
XC                during the reading of a CIF. The default is .true.
XC
XC    text_       Logical variable signals if another text line is present.
XC
XC    type_       Character*4 variable: the data type code (see test_).
XC
XC
XC
XC_____________________________________________________________________________
XC
XC
XC >>>>>> Set the device numbers.
XC
X         function init_(devcif,devout,devdir,deverr)
XC
X         logical   init_
X         include   'ciftbx.sys'
X         integer   devcif,devout,devdir,deverr
X         integer   ii,kdig
X         real      ytest
X         double precision ztest         
XC
X         init_=.true.
X         cifdev=devcif
X         outdev=devout
X         dirdev=devdir
X         errdev=deverr
X         recn_=0
X         precn_=0
XC
XC        recompute decimal single precision precision
XC        This is found by computing the smallest power of
XC        10 which, when added to 1, produces a change
XC        and then backing off by 1
XC
X         decprc = .1
X         do ii = 1,6
X         ytest = 1.+decprc/10.
X         if (ytest.eq.1.) go to 100
X         decprc = decprc/10.
X         enddo
X100      continue
X         decprc=decprc*10.
XC
XC        recompute decimal double precision precision
XC
X         kdig = 1
X         dpprc = .1D0
X         do ii = 1,15
X         ztest = 1.D0+dpprc/10.
X         if (ztest.eq.1.D0) go to 200
X         dpprc = dpprc/10.D0
X         kdig = kdig+1
X         enddo
X200      continue
X         dpprc=dpprc*10.D0
X         write(ndpfmt,'(5h(d30.,i2,1h))') kdig-1
XC
XC        recompute decimal single precision minimum power of ten
XC
X         decmin = .1
X         do ii = 1,37
X         ytest = decmin/10.
X         if (ytest.eq.0.) go to 300
X         decmin = decmin/10.
X         enddo
X300      continue
XC
XC        recompute decimal double precision minimum power of 10
XC        and its log base 10 (minexp)
XC
X         dpmin = .1D0
X         minexp = -1
X         do ii = 1,307
X         ztest = dpmin/10.
X         if (ztest.eq.0.D0) go to 400
X         dpmin = dpmin/10.D0
X         minexp = minexp-1
X         enddo
X400      continue
X         call clearfp
X         return
X         end
XC
XC
XC
XC
XC
XC >>>>>> Read a CIF dictionary and prepare for checks
XC
X         function dict_(fname,checks)
XC
X         logical   dict_
X         logical   ocif_
X         logical   data_
X         logical   char_
X         integer   lastnb
X         include  'ciftbx.sys'
X         character locase*(MAXBUF)
X         character fname*(*),checks*(*)
X         character temp*24,codes(4)*5,name*(MAXBUF),bxname*(NUMCHAR)
X         character bcname*(NUMCHAR),biname*(NUMCHAR),bname*(NUMCHAR)
X         character baname*(NUMCHAR),ganame*(NUMCHAR),btname*(NUMCHAR)
X         character batag*(NUMCHAR)
X         integer   lbcname,lbaname,lbtname,lbname
X         integer   kdict,kadict,ifind,jfind,iafind
X         integer   i,j,nmatch,mycat,ksmatch,ii
XC
XC        Control flags for matching categories, names and types
XC
XC        icloop is the loop number of the block for the
XC        current category
XC        ictype is the type of the current category
XC          0 - none found yet
XC          1 - _item.category.id
XC          2 - _category
XC          3 - _category.id
XC        inloop is the loop number of the block for the
XC        current name
XC        intype is the type of the current name
XC          0 - none found yet
XC          1 - _item.name
XC          2 - _name
XC        ialoop is the loop number of the block for the
XC        current alias
XC        iatype is the type for the current alias
XC          0 - none found yet
XC          1 - _item_aliases.alias_name
XC        itloop is the loop number of the block for the
XC        current type
XC        ittype is the type of the current type
XC          0 - none found yet
XC          1 - _item_type.code
XC          2 - _type
XC
X         integer icloop,ictype,inloop,intype,ialoop,iatype,
X     * itloop,ittype
XC
X         character*4 map_type(12),map_to(12),mapped
X         character*(NUMCHAR) dt(2),ct(3),nt(2),at(1),tt(2)
X         data map_type
X     *   /'floa','int ','yyyy','symo','ucha','ucod','name','idna',
X     *    'any ','code','line','ulin'/
X         data map_to
X     *   /'numb','numb','char','char','char','char','char','char',
X     *    'char','char','char','char'/
X         data dt
X     *      /'_dictionary.title               ',
X     *       '_dictionary_name                '/
X         data ct
X     *      /'_item.category_id               ',
X     *       '_category                       ',
X     *       '_category.id                    '/
X         data nt
X     *      /'_item.name                      ',
X     *       '_name                           '/
X         data at
X     *      /'_item_aliases.alias_name        '/
X         data tt
X     *      /'_item_type.code                 ',
X     *       '_type                           '/
XC
X         data codes /'valid','dtype','reset','close'/
XC
XC....... Are the codes OK
XC
X         temp=checks
X         i=0         
X120      i=i+1
X         if(i.ge.24)                 goto 190
X         if(temp(i:i).eq.' ')        goto 120
X         do 150 j=1,4
X         if(temp(i:i+4).eq.codes(j)) goto 170
X150      continue
X         dict_=.false.
X         goto 500
X170      i=i+4
X         if(j.eq.1) vcheck='yes'
X         if(j.eq.2) tcheck='yes'
X         if(j.eq.3) then
X           vcheck = 'no '
X           tcheck = 'no '
X           goto 170
X         endif
X         if(j.eq.4) then
X           vcheck = 'no '
X           tcheck = 'no '
X           ndcname = 0
X           ndict = 0
X           if(nname.gt.0) then
X           do 180 i = 1,nname
X             dtype(i)=' '
X             dxtyp(i)=' '
X             cindex(i)=0
X             ddict(i)=0
X180        continue
X           endif
X           dict_=.true.
X           goto 500
X         endif
X         goto 120
XC
XC        if no category names have been loaded, clean up
XC        the hash table for dictionary category names
XC
X190      if(ndcname.eq.0) then
X           call hash_init(dcname,dcchain,NUMDICT,ndcname,dchash,
X     *     NUMHASH)
X         endif
XC
XC        if no dictionary names have been loaded, clean up
XC        the hash table for dictionary names
XC
X         if(ndict.eq.0) then
X           call hash_init(dicnam,dicchain,NUMDICT,ndict,dichash,
X     *     NUMHASH)
X         endif
XC
XC....... Open and store the dictionary
XC
X         dict_=.true.
X         if(fname.eq.' ')            goto 500
X         if(nname.gt.0) call err(' Dict_ must precede ocif_')
X         dict_=ocif_(fname)
X         if(.not.dict_)              goto 500
X         dictfl='yes'
XC
XC....... Loop over data blocks; extract _name's, _type etc.
XC
X200      if(.not.data_(' '))         goto 400
X         if(bloc_(1:1).eq.'_') then
X           bname=locase(bloc_)
X         else
X           bname='_'//locase(bloc_)
X         endif
X         lbname=lastnb(bname)
XC
XC        see if this is a dictionary defining block
XC
X         do i = 1,2
X           if(char_(dt(i),name)) goto 200
X         enddo
XC
XCdbg     WRITE(6,*) ndict,bloc_
XC
XC        Analyze loop structure for categories, names and types
XC
XC
XC        initalize loop info
XC
X         icloop = -1
X         inloop = -1
X         ialoop = -1
X         itloop = -1
X         ictype = 0
X         intype = 0
X         iatype = 0
X         ittype = 0
X         bcname = ' '
X         lbcname = 1
X         baname = ' '
X         batag = ' '
X         lbaname = 1
X         btname = ' '
X         lbtname = 1
X         biname=bloc_
X         mycat=0
X         loop_=.false.
X         loopnl=0
X         nmatch=0
X         ksmatch=0
XC
XC        Process categories
XC
X         do i = 1,3
X           if(char_(ct(i),name)) then
X             if(ictype.ne.0)
X     *         call warn(' Multiple DDL 1 and 2 category definitions ')
X             ictype = i
X             if(loop_) icloop = loopnl
X             bcname=locase(name(1:long_))
X             lbcname=long_
X             call hash_store(bcname,
X     *         dcname,dcchain,NUMDICT,ndcname,dchash,NUMHASH,mycat)
X             if(mycat.eq.0) then
X               call err(' Dictionary category names > NUMDICT ')
X             endif
XC
XC            if this is not a loop of categories, we expect a match
XC            against the block name
XC
X             if(.not.loop_) then
X               if(ictype.eq.1) then
X                 if(bname(1:lbcname+2).ne.
X     *            '_'//bcname(1:lbcname)//'.') then
X                 call warn(' Category id does not match block name')
X                 endif
X               else
X                 if(ictype.eq.2) then
X                   if(bcname.ne.'dictionary_definition') then
X                   if(bname(1:lbcname+2).ne.
X     *               '_'//bcname(1:lbcname)//'_') then
X                   if(bname(1:lbcname+2).ne.
X     *               '_'//bcname(1:lbcname)//' ') then
X                   call warn(' Category id does not match block name')
X                   endif
X                   endif
X                   endif
X                 endif
X               endif
X             endif
X           endif
X           loop_ = .false.
X           loopnl = 0
X         enddo
XC
XC        Process names
X         do i = 1,2
X         if(char_(nt(i),name)) then
X           if(intype.ne.0)
X     *       call warn(' Multiple DDL 1 and 2 name definitions ')
X           intype = i
X           bxname=locase(name(1:long_))
X           if(loop_) inloop = loopnl
X         endif
X         loop_ = .false.
X         loopnl=0
X         enddo
X         if(intype.eq.0.and.ictype.ne.3)
X     *     call warn (' No name defined in block')
X         loop_ = .false.
X         if(char_(at(1),name)) then
X           iatype=1
X           baname = locase(name(1:long_))
X           batag = name(1:long_)
X           lbaname = long_
X           if(loop_) ialoop = loopnl
X         endif
X         loop_ = .false.
X         loopnl=0
X         if(ictype.ne.3) then
X           do i=1,2
X             if(char_(tt(i),name)) then
X               if(ittype.ne.0)
X     *           call warn(' Multiple DDL 1 and 2 type definitions ')
X               ittype = i
X               btname = locase(name(1:long_))
X               if(loop_) itloop = loopnl
X             endif
X             loop_ = .false.
X             loopnl=0
X           enddo
X         endif
XC
XC        Now test for consistent combinations
XC
X         if(inloop.ne.-1) then
X           if(icloop.ne.-1.and.icloop.ne.inloop)
X     *       call warn(
X     *       ' Categories and names in different loops')
X           if(iatype.ne.0.and.ialoop.ne.inloop) then
X             if(ialoop.eq.-1) then
X               if(bxname.ne.bname)
X     *          call warn(
X     *         ' One alias, looped names, linking to first')
X             else
X               call warn(
X     *         ' Aliases and names in different loops '
X     *         //' only using first alias ')
X             endif
X           endif
X           if(itloop.ne.-1.and.itloop.ne.inloop)
X     *       call warn(
X     *       ' Types and names in different loops')
X         else
X           if(icloop.ne.-1)
X     *       call warn(
X     *         ' Multiple categories for one name')
X           if(itloop.ne.-1)
X     *       call warn(
X     *         ' Multiple types for one name')
X         endif
XC
XC        This is the main loop
XC
X         if(intype.eq.0) go to 200
X250      if(.not.char_(nt(intype),name)) goto 200
X         kdict=ndict+1
X         call hash_store(locase(name(1:long_)),dicnam,dicchain,
X     *     NUMDICT,ndict,dichash,NUMHASH,ifind)
X         if(ifind.eq.0) call err(' Cifdic names > NUMDICT')
X         if(ifind.eq.kdict)dictag(ifind)=name(1:long_)
X         if(dicnam(ifind).eq.bname) nmatch=ifind
X         if(dicnam(ifind)(1:lbname).eq.bname) ksmatch=ifind
XCdbg     if(dicnam(ifind).ne.bname)
XCdbg *   call warn (' Name mismatch: '//dicnam(ifind)//bname)
X         if(inloop.ge.0)then
XC
XC          We are in a loop of names.  If it is the same loop as
XC          for categories, we need to extract the matching category
XC
X           if(inloop.eq.icloop) then
X             mycat=0
X             if(char_(ct(ictype),name)) then
X               bcname=locase(name(1:long_))
X               lbcname=long_
X               call hash_store(bcname,
X     *         dcname,dcchain,NUMDICT,ndcname,dchash,NUMHASH,mycat)
X               if(mycat.eq.0) then
X                 call err(' Dictionary category names > NUMDICT ')
X               endif
X             endif
X           endif
XC
XC          If it is the same loop as for types, we need to extract
XC          the matching type
XC
X           if(inloop.eq.itloop) then
X             btname=' '
X             if(char_(ct(ittype),name)) then
X               btname=locase(name(1:long_))
X               lbtname=long_
X             endif
X           endif
XC
XC          If it is the same loop as for aliases, we need to extract
XC          the matching alias
XC
X           if(inloop.eq.ialoop) then
X             baname=' '
X             batag=' '
X             if(char_(at(1),name)) then
X               baname = locase(name(1:long_))
X               batag = name(1:long_)
X               lbaname = long_
X             endif
X           endif
X         endif
XC
XC        now we have a name stored in dicnam at location ifind
XC        the index of the category in mycat, the type in btname,
XC        the alias in baname
XC
XC        First verify match between the name and category, if
XC        we have one, or extract from the block name
XC
X         if (mycat.eq.0) then
X         if (dcindex(ifind).eq.0) then
X           if (dicnam(ifind).eq.bloc_) then
X             call excat(dicnam(ifind),bcname,lbcname)
XCdbg         call warn(' Extracting category name from block name '
XCdbg *       //bloc_(1:max(1,lastnb(bloc_))))
X             if(bcname(1:1).ne.' ') then
X               ictype = 1
X               call hash_store(bcname,
X     *         dcname,dcchain,NUMDICT,ndcname,dchash,NUMHASH,mycat)
X               if(mycat.eq.0) then
X                 call err(' Dictionary category names > NUMDICT ')
X               endif
X             else
X               call warn(' No category defined in block ' 
X     *       //bloc_(1:max(1,lastnb(bloc_)))//' and name '
X     *       //dicnam(ifind)(1:max(1,lastnb(dicnam(ifind))))
X     *       //' does not match')
X             endif
X           endif
X         endif
X         else
X         if (bcname(1:lbcname).ne.'dictionary_definition') then
X           if (dicnam(ifind)(1:lbcname+1).ne.'_'//bcname(1:lbcname)
X     *        .or.( dicnam(ifind)(lbcname+2:lbcname+2).ne.'_' .and.
X     *          dicnam(ifind)(lbcname+2:lbcname+2).ne.'.' .and.
X     *          dicnam(ifind)(lbcname+2:lbcname+2).ne.' ' )) then
X                call warn(' Item name '//
X     *          dicnam(ifind)(1:max(1,lastnb(dicnam(ifind))))//' '//
X     *       ' does not match category name '//bcname(1:lbcname))
X           endif
X         endif
X         endif
XC
XC        We will need the type in what follows.  cifdic.m96 defines
XC        some higher level types.  We map them to primitive types
XC
X         mapped = btname(1:4)
X         do i = 1,12
X           if (btname(1:4).eq.map_type(i)) mapped = map_to(i)
X         enddo
X         if (mapped.ne.'char' .and.
X     *       mapped.ne.'text' .and.
X     *       mapped.ne.'    ' .and.
X     *       mapped.ne.'null' .and.
X     *       mapped.ne.'numb' ) then
X             if (tcheck .eq. 'yes') call warn (' Item type '//
X     *       btname(1:max(1,lastnb(btname)))//' not recognized')
X         endif
XC
XC        There are two cases to consider, one if the name is new to
XC        the dictionary, the other, if it is not
XC
X         if(ifind.eq.kdict) then
X           aroot(ifind)=0
X           alias(ifind)=0
X           dcindex(ifind)=mycat
X           dictyp(ifind)=mapped
X           dicxtyp(ifind)=btname
X         else
X           if(dcindex(ifind).ne.mycat) then
X             if(dcindex(ifind).eq.0) then
X               jfind=ifind
X               if (aroot(ifind).ne.0) jfind=ifind
X255            continue
X               dcindex(jfind)=mycat
X               jfind=alias(jfind)
X               if(jfind.ne.0) goto 255
X             else
X               if(mycat.ne.0.and.
X     *           (vcheck.eq.'yes'.or.tcheck.eq.'yes'))
X     *           call warn(' Attempt to redefine category for item')
X             endif
X           endif
X           if(dictyp(ifind).ne.mapped .or.
X     *       dicxtyp(ifind).ne.btname) then
X             if(dictyp(ifind).eq.' ') then
X               jfind=ifind
X               if (aroot(ifind).ne.0) jfind=ifind
X256            continue
X               dictyp(jfind)=mapped
X               dicxtyp(jfind)=btname
X               jfind=alias(jfind)
X               if(jfind.ne.0) go to 256
X             else
X               if(mapped.ne.' '.and.tcheck.eq.'yes')
X     *           call warn(' Attempt to redefine type for item')
X             endif
X           endif
X         endif
XC
XC        now deal with alias, if any.
XC
X         if(baname.ne.' ') then
X           kadict=ndict+1
X           call hash_store(baname(1:lbaname),dicnam,dicchain,
X     *     NUMDICT,ndict,dichash,NUMHASH,iafind)
X           if(iafind.eq.0) call err(' Cifdic names > NUMDICT')
X           if(iafind.eq.kadict) then
X             dictag(iafind)    =batag
X             aroot(iafind)     =aroot(ifind)
X             if(aroot(iafind).eq.0) aroot(iafind)=ifind
X             alias(iafind)     =0
X             alias(ifind)      =iafind
X             dcindex(iafind)   =dcindex(ifind)
X             dictyp(iafind)    =dictyp(ifind)
X             dicxtyp(iafind)   =dicxtyp(ifind)
X           else
X             if(aroot(iafind).ne.0) then
X               if(aroot(iafind).eq.ifind .or.
X     *           aroot(iafind).eq.aroot(ifind)) then
X                 call warn(' Duplicate definition of same alias')
X               else
X                 call warn(' Conflicting definition of alias')
X               endif
X             else
X               if((dcindex(iafind).eq.0.or.
X     *           dcindex(iafind).eq.dcindex(ifind)).and.
X     *           (dictyp(iafind).eq.' '.or.
X     *           (dictyp(iafind).eq.dictyp(ifind) .and.
X     *            dicxtyp(iafind).eq.dicxtyp(ifind)))) then
X                 dcindex(iafind)   =dcindex(ifind)
X                 dictyp(iafind)    =dictyp(ifind)
X                 dicxtyp(iafind)   =dicxtyp(ifind)
X               endif
X               aroot(iafind)     =aroot(ifind)
X               if(aroot(iafind).eq.0) aroot(iafind)=ifind
X               alias(ifind)      =iafind
X             endif
X           endif
X         endif
X         if(inloop.ge.0) then
X           baname = ' '
X           batag = ' '
X         endif
XC
X         if(inloop.ge.0.and.loop_) go to 250
X         if(nmatch.eq.0) then
X         if (ksmatch.eq.0.or.inloop.lt.0) then
X         call warn(' No name in the block matches the block name')
X         endif
X         endif
XC
XC        check for aliases
XC        we execute this loop only in the case of unlooped name
XC        with looped alias
XC
X         if(inloop.lt.0.and.ialoop.ge.0) then
X           loop_=.false.
X           loopnl=0 
X           ganame=baname
X260        if(.not.char_(at(iatype),name)) goto 200
X           baname=locase(name(1:long_))
X           batag=name(1:long_)
X           lbaname=long_
X           if(baname.eq.ganame) then
X             if(loop_) go to 260
X             go to 200
X           endif
X           if(baname.ne.' ') then
X             kadict=ndict+1
X             call hash_store(baname(1:lbaname),dicnam,dicchain,
X     *       NUMDICT,ndict,dichash,NUMHASH,iafind)
X             if(iafind.eq.0) call err(' Cifdic names > NUMDICT')
X             if(iafind.eq.kadict) then
X               dictag(iafind)    =batag
X               aroot(iafind)     =aroot(ifind)
X               if(aroot(iafind).eq.0) aroot(iafind)=ifind
X               alias(iafind)     =0
X               alias(ifind)      =iafind
X               dcindex(iafind)   =dcindex(ifind)
X               dictyp(iafind)    =dictyp(ifind)
X               dicxtyp(iafind)   =dicxtyp(ifind)
X               ifind=iafind
X             else
X               if(aroot(iafind).ne.0) then
X                 if(aroot(iafind).eq.ifind .or.
X     *             aroot(iafind).eq.aroot(ifind)) then
X                   call warn(' Duplicate definition of same alias')
X                 else
X                   call warn(' Conflicting definition of alias')
X                 endif
X               else
X                 if((dcindex(iafind).eq.0.or.
X     *           dcindex(iafind).eq.dcindex(ifind)).and.
X     *           (dictyp(iafind).eq.' '.or.
X     *           (dictyp(iafind).eq.dictyp(ifind) .and.
X     *            dicxtyp(iafind).eq.dicxtyp(ifind)))) then
X                 dcindex(iafind)   =dcindex(ifind)
X                 dictyp(iafind)    =dictyp(ifind)
X                 dicxtyp(iafind)   =dicxtyp(ifind)
X                 ifind=iafind
X                 endif
X                 aroot(iafind)     =aroot(ifind)
X                 if(aroot(iafind).eq.0) aroot(iafind)=ifind
X                 alias(ifind)      =iafind
X               endif
X             endif
X           endif
X           if(loop_) go to 260
X         endif
X         go to 200
XC
X400      bloc_=' '
X         if (ndcname.ne.0) then
X         do ii = 1,ndict
X         if (aroot(ii).eq.0.and.dcindex(ii).eq.0)
X     *     call warn(' No category specified for name '//
X     *       dicnam(ii)(1:max(1,lastnb(dicnam(ii)))))
X         enddo
X         endif
X         do ii = 1,ndict
X         if (dicxtyp(ii).eq.' ') then
X           dicxtyp(ii) = 'null'
X           dictyp(ii) = 'null'
X           if (tcheck.eq.'yes')
X     *       call warn(' No type specified for name '//
X     *         dicnam(ii)(1:max(1,lastnb(dicnam(ii)))))
X         endif
X         enddo
X         close(dirdev)
X         nrecd=0
X         dictfl='no '
X500      continue
X         if(tcheck.eq.'yes') vcheck='yes'
XCdbg     WRITE(6,'(i5,3x,a,2x,a)') (i,dicnam(i),dictyp(i),i=1,ndict)
X         return
X         end
XC
XC
XC
XC
XC
XC >>>>>> Find position of last non_blank in a string
XC
X         function lastnb(str)
XC
X         integer    lastnb
X         include   'ciftbx.sys'
X         character*(*) str
X         integer lenn,ii
X         lenn = len(str)
X         do 100 ii=lenn,1,-1
X         if(str(ii:ii).eq.' ') goto 100
X         if(str(ii:ii).ne.tab) goto 120
X100      continue
X         ii=1
X120      lastnb = ii
X         return
X         end
XC
XC
XC
XC
XC
XC >>>>>> Extract the item.category_id from a save frame name
XC
X         subroutine excat(sfname,bcname,lbcname)
XC
X         character*(*) sfname,bcname
X         integer lbcname,ii,ic,lastnb,lenn
XC
XC        Note that this logic works only for item.category_id
XC        not for category.id
XC
X         lenn = lastnb(sfname)
X         bcname = ' '
X         lbcname = 1
X         if (lenn.eq.0.or.sfname(1:1).ne.'_') return
X         do ii = 1,lenn-2
X         ic = 1+lenn-ii
X         if (sfname(ic:ic).eq.'.') then
X           bcname = sfname(2:ic-1)
X           lbcname = ic-2
X           return
X         endif
X         enddo
X         return
X         end
XC
XC
XC
XC
XC
XC >>>>>> Open a CIF and copy its contents into a direct access file.
XC
X         function ocif_(fname)
XC
X         logical   ocif_
X         integer   lastnb
X         include  'ciftbx.sys'
X         logical   test
X         character fname*(*)
X         integer   case,i
XC
X         save_=.false.
X         jchar=MAXBUF
X         lastch=0
X         if(line_.gt.MAXBUF) call err(' Input line_ value > MAXBUF')
X         if(nrecd.ne.0) close(dirdev)
X         nrecd=0
X         lrecd=0
X         case=ichar('a')-ichar('A')
X         tab=char(05)
X         if(case.lt.0) goto 100
X         tab=char(09)
X         bloc_=' '
XC
XC....... Make sure the CIF is available to open
XC
X100      file_=fname
X         do 120 i=1,MAXBUF
X         if(file_(i:i).eq.' ') goto 140
X120      continue
X140      longf_=i-1
X         if (longf_.gt.0) then
X           inquire(file=file_(1:longf_),exist=test)
X           ocif_=test
X           if(.not.ocif_)      goto 200
X         else
X           file_ = ' '
X           longf_ = 1
X           ocif_ = .true.
X         endif
XC
XC....... Open up the CIF and a direct access formatted file as scratch
XC
X         if (file_(1:1).ne.' ')
X     *   open(unit=cifdev,file=fname,status='OLD',access='SEQUENTIAL',
X     *                    form='FORMATTED')
X         open(unit=dirdev,status='SCRATCH',access='DIRECT',
X     *                    form='FORMATTED',recl=MAXBUF)
XC
XC....... Copy the CIF to the direct access file
XC
X160      read(cifdev,'(a,a)',end=180) buffer
X         nrecd=nrecd+1
X         irecd=nrecd
X         if (lastnb(buffer(1:MAXBUF)).gt.line_)
X     *      call warn(' Input line length exceeds line_')
X         write(dirdev,'(a)',rec=nrecd) buffer
XCdbg     WRITE(6,'(i5,1x,a)') nrecd,buffer(1:70)
X         goto 160
XC
X180      lrecd=0
X         jrecd=0
X         jrect=-1
X         irecd=0
X         recn_=0
X         if (file_(1:1).ne.' ') close(cifdev)
X200      return
X         end
XC
XC
XC
XC
XC
XC >>>>>> Close off direct access file of the current CIF
XC         and reset all data name tables and pointers       
XC
X         subroutine purge_
XC
X         include   'ciftbx.sys'
XC
X         if(nrecd.ne.0) close(dirdev)
X         recn_=0
X         save_=.false.
X         jchar=MAXBUF
X         lastch=0
X         nrecd=0
X         lrecd=0
X         irecd=0
X         nname=0
X         nhash=0
X         iname=0
X         loopct=0
X         loopnl=0
X         loop_=.false.
X         text_=.false.
X         return
X         end
XC
XC
XC
XC
XC
XC >>>>>> Store the data names and pointers for the requested data block
XC
X         function data_(name) 
XC
X         logical   data_
X         integer   lastnb
X         include  'ciftbx.sys'
X         character name*(*),flag*4,temp*(NUMCHAR),ltype*4
X         character ctemp*(NUMCHAR)
X         character locase*(MAXBUF),isbuf*(MAXBUF)
X         integer   ndata,idata,nitem,npakt,i,ii,j,k,kchar,krecd
X         integer   fcatnum,lctemp,isrecd,isjchr,islast
X         integer   pnname,itpos,ipp,ipj
XC
X         jchar=MAXBUF
X         nname=0
X         ndata=0
X         nhash=0
X         nitem=0
X         idata=0
X         iname=0
X         loopct=0
X         loopnl=0
X         ltype=' '
X         posnam_=0
X         posval_=0
X         posdec_=0
X         posend_=0
X         data_=.false.
X         loop_=.false.
X         text_=.false.
X         do ii = 1,MAXBOOK
X         ibkmrk(1,ii)=-1
X         enddo
X         irecd=lrecd
X         lrecd=nrecd
X         if(name(1:1).ne.' ') irecd=0
X         call hash_init(dname,dchain,NUMBLOCK,nname,dhash,
X     *     NUMHASH)
X         call hash_init(cname,cchain,NUMBLOCK,ncname,chash,
X     *     NUMHASH)
X         isrecd=irecd
X         isjchr=jchar
X         islast=lastch
X         isbuf=' '
X         if(lastch.gt.0)isbuf(1:lastch)=buffer(1:lastch)
XC
XC....... Find the requested data block in the file
XC
X100      call getstr
X         isjchr=jchar
X         if(irecd.ne.isrecd) then
X           isrecd=irecd
X           islast=lastch
X           isbuf=' '
X           if(lastch.gt.0)isbuf(1:lastch)=buffer(1:lastch)
X         endif
X         if(type_.eq.'fini')           goto 500
X         if(type_.ne.'text')           goto 120
X110      call getlin(flag)       
X         if(buffer(1:1).ne.';')        goto 110
X         jchar=2
X         goto 100
X120      continue
X         if(type_.eq.'save') then
X           if(long_.lt.6) then
X             if(.not.save_)
X     *         call err(' Save frame terminator found out of context ')
X             save_=.false.
X             goto 100
X           else
X             if(save_)
X     *         call err(' Prior save frame not terminated ')
X             save_=.true.
X             if(name.eq.' ')          goto 150
X             if(strg_(6:long_).ne.name) goto 100
X             goto 150
X           endif
X         endif
X         if(type_.ne.'data')          goto 100
X         if(name.eq.' ')              goto 150
X         if(strg_(6:long_).ne.name)   goto 100
X150      data_=.true.
X         bloc_=strg_(6:long_)
X         itpos=jchar-long_
X         if(tabx_) then
X         itpos=0
X         do ipp=1,jchar-long_
X           itpos=itpos+1
X           if(buffer(ipp:ipp).eq.tab) itpos=((itpos+7)/8)*8
X         enddo
X         endif
X         posnam_=itpos
XC
XC....... Get the next token and identify
XC
X200      call getstr
XCdbg     if(dictfl.eq.'no ')
XCdbg *    WRITE(6,*) ltype,type_,loop_,nitem,ndata,idata,iname,nname
XC
X         if(ltype.ne.'name')                goto 201
X         if(type_.eq.'numb')                goto 203
X         if(type_.eq.'char')                goto 203
X         if(type_.eq.'text')                goto 203
X         if(type_.eq.'null')                goto 203
X         if(type_.eq.'name'.and.loop_)      goto 204
X         call err(' Illegal tag/value construction')
X201      if(ltype.ne.'valu')                goto 204
X         if(type_.eq.'numb')                goto 202
X         if(type_.eq.'char')                goto 202
X         if(type_.eq.'text')                goto 202
X         if(type_.eq.'null')                goto 202
X         goto 204
X202      if(nitem.gt.0)                     goto 205
X         call err(' Illegal tag/value construction')
X203      ltype='valu'
X         goto 205
X204      ltype=type_
XC
X205      if(type_.eq.'name')           goto 206
X         if(type_.eq.'loop')           goto 210
X         if(type_.eq.'data')           goto 210
X         if(type_.eq.'save')           goto 210
X         if(type_.ne.'fini')           goto 220
X206      if(loop_)                     goto 270
X210      if(nitem.eq.0)                goto 215
XC
XC....... End of loop detected; save pointers
XC
X         npakt=idata/nitem
X         if(npakt*nitem.ne.idata) call err(' Item miscount in loop')
X         loopni(loopct)=nitem
X         loopnp(loopct)=npakt
X         nitem=0
X         idata=0
X215      if(type_.eq.'name')           goto 270
X         if(type_.eq.'data')           goto 300
X         if(type_.eq.'save')           goto 300
X         if(type_.eq.'fini')           goto 300
XC
XC....... Loop_ line detected; incr loop block counter
XC
X         loop_=.true.
X         loopct=loopct+1
X         if(loopct.gt.NUMLOOP) call err(' Number of loop_s > NUMLOOP')
X         loorec(loopct)=irecd
X         loopos(loopct)=jchar-long_
X         if(quote_.ne.' ') loopos(loopct)=jchar-long_-1
X         itpos=0
X         do ipp=1,loopos(loopct)
X           itpos=itpos+1
X           if(buffer(ipp:ipp).eq.tab) itpos=((itpos+7)/8)*8
X         enddo
X         loopox(loopct)=itpos
X         goto 200
XC
XC....... This is the data item; store char position and length
XC
X220      if(loop_ .and. nitem.eq.0)
X     *   call err(' Illegal tag/value construction')
X         loop_=.false.
XC
X         i=nname
X         if(nitem.gt.0) i=i-nitem+mod(idata,nitem)+1
X         if(i.lt.1) call err(' Illegal tag/value construction')
X         if(dtype(i).ne.'test')       goto 223
X         if(dictfl.eq.'yes')          goto 223
X         if(tcheck.eq.'no ')          goto 223
XC>>>>    if(long_.eq.1.and.strg_(1:1).eq.'?') goto 223
XC>>>>    if(long_.eq.1.and.strg_(1:1).eq.'.') goto 223
X         if(type_.eq.'null')          goto 223
X         if(type_.eq.'numb')          goto 223
X         call warn( ' Numb type violated  '//dname(i))
X223      if(nitem.le.0)               goto 224
X         idata=idata+1
X         if(dtype(i).eq.'null') dtype(i)=type_
X         if(dtype(i).eq.'numb' .and.
X     *     (type_.eq.'char'.or.type_.eq.'text')) dtype(i)='char'
X224      if(nname.eq.ndata)           goto 230
X         ndata=ndata+1
X         if(iloop(ndata).gt.1)        goto 225
X         krecd=irecd
X         kchar=jchar-long_-1
X         if(quote_.ne.' ')kchar=kchar-1
X225      continue
X         if(dtype(ndata).eq.'    ') dtype(ndata)=type_
X         drecd(ndata)=krecd
X         dchar(ndata)=kchar
X         if(nloop(ndata).gt.0)        goto 230
X         nloop(ndata)=0
X         iloop(ndata)=long_
XC
XC....... Skip text lines if present
XC
X230      if(type_.ne.'text')           goto 200
X         if(nloop(ndata).eq.0) dchar(ndata)=0
X         if(nloop(ndata).eq.0) iloop(ndata)=long_
X250      call getlin(flag)
X         if(buffer(1:1).eq.';') then
X           jchar=2
X           goto 200
X         endif
X         if(flag.eq.'fini') call err(' Unexpected end of data')
X         goto 250
XC
XC....... This is a data name; store name and loop parameters
XC
X270      temp=locase(strg_(1:long_))
X         k=0
X         if(dictfl.ne.'yes' .and. ndict.gt.0) then
X           call hash_find(temp,
X     *       dicnam,dicchain,NUMDICT,ndict,dichash,NUMHASH,k)
X           if(k.ne.0) then
X             if(alias_ .and. aroot(k).ne.0) temp=dicnam(aroot(k))
X           endif
X         endif
X         pnname=nname
X         call hash_store(temp,
X     *   dname,dchain,NUMBLOCK,nname,dhash,
X     *     NUMHASH,j)
X         if(j.eq.pnname+1) then
X           dtag(j)=strg_(1:long_)
X           if(k.ne.0) dtag(j)=dictag(k)
X           trecd(j)=irecd
X           tchar(j)=jchar-long_
X           if(quote_.ne.' ') tchar(j)=jchar-long_-1
X           itpos=0
X           do ipp=1,tchar(j)
X             itpos=itpos+1
X             if(buffer(ipp:ipp).eq.tab) itpos=((itpos+7)/8)*8
X           enddo
X           xchar(j)=itpos
X         endif
X         if(j.eq.0)
X     *     call err(' Number of data names > NUMBLOCK')
X         if(k.ne.0)temp=dicnam(k)
X         if(j.ne.pnname+1) then
X           call warn(' Duplicate data item '//
X     *     temp(1:max(1,lastnb(temp))))
X           goto 200  
X         endif
X         dtype(nname)=' '
X         dxtyp(nname)=' '
X         cindex(nname)=0
X         ddict(nname)=0
X         ctemp='(none)'
X         lctemp=6
XC
X         if(dictfl.eq.'yes' .or. vcheck.eq.'no ') goto 290
X         j=k
X         if(j.ne.0) then
X           ddict(nname)=j
X           cindex(nname)=dcindex(j)
X           dxtyp(nname)=dicxtyp(j)
X           dtype(nname)=dictyp(j)
X           if(vcheck.eq.'no ')          goto 280
X           if(dictyp(j).eq.'numb') then
X             dtype(nname)='test'
X           endif
X           if(cindex(nname).ne.0) then 
X             ctemp=dcname(cindex(nname))
X             lctemp=lastnb(ctemp)
X             goto 290
X           endif   
X           goto  280
X         endif
X         call warn(' Data name '//
X     *               temp(1:max(1,lastnb(temp)))
X     *               //' not in dictionary!')
X280      call excat(temp,ctemp,lctemp)
X         if (ctemp.eq.' '.or.'_'//ctemp.eq.temp) then
X           ctemp = '(none)'
X           lctemp= 6
X           if (ndcname.ne.0.and.vcheck.eq.'yes')
X     *       call warn(' No category defined for '
X     *       //temp)
X         else
X           call hash_find(ctemp,
X     *       dcname,dcchain,NUMDICT,ndcname,dchash,NUMHASH,j)
X           if(j.ne.0) then
X             cindex(nname) = j
X           else
X             ipj=ncname
X             call hash_store(ctemp(1:lctemp),
X     *         cname,cchain,NUMBLOCK,ncname,chash,NUMHASH,j)
X             if (j.eq.0)
X     *         call err(' Number of categories > NUMBLOCK ')
X             cindex(nname) = -j
X             if (ndcname.gt.0.and.j.eq.ipj+1.and.vcheck.eq.'yes')
X     *         call warn(' Category '//
X     *         ctemp(1:lctemp)//' first implicitly defined in cif ')
X           endif
X         endif
XC
X290      lloop(nname)=0
X         nloop(nname)=0
X         iloop(nname)=0
X         if (nitem.eq.0) fcatnum=cindex(nname)
X         if(.not.loop_)               goto 200
X         nitem=nitem+1
X         if(nitem.gt.NUMITEM)
X     *     call err(' Items per loop packet > NUMITEM')
X         nloop(nname)=loopct
X         iloop(nname)=nitem
X         if (fcatnum.ne.cindex(nname)) then
X           temp = '(none)'
X           if (fcatnum.gt.0) temp=dcname(fcatnum)
X           if (fcatnum.lt.0) temp=cname(-fcatnum)
X           if (ctemp(1:lctemp).ne.temp(1:lastnb(temp)))
X     *     call warn (' Heterogeneous categories in loop '//
X     *     ctemp(1:lastnb(ctemp))//' vs '//
X     *     temp(1:lastnb(temp)))
X           fcatnum=cindex(nname)
X         endif
X         goto 200
X300      continue
XC
XC....... Are names checked against dictionary?
XC
X         if(dictfl.eq.'yes')          goto 500
X         if(vcheck.eq.'no '.or.ndict.eq.0) goto 500
X         do 350 i=1,nname
X         if(dtype(i).eq.'test') dtype(i)='numb'
X350      continue
XC
XC....... End of data block; tidy up loop storage
XC
X500      lrecd=irecd-1
X         if(type_.eq.'save'.and.long_.lt.6) then
X           itpos=jchar-long_
X           if(tabx_) then
X           itpos=0
X           do ipp=1,jchar-long_
X             itpos=itpos+1
X             if(buffer(ipp:ipp).eq.tab) itpos=((itpos+7)/8)*8
X           enddo
X           endif
X           posval_=itpos
X         endif
X         irecd=isrecd
X         jchar=isjchr
X         lastch=islast
X         recn_=irecd
X         buffer=' '
X         if(lastch.gt.0)buffer=isbuf(1:lastch)
X         jrecd=irecd
X         loop_=.false.
X         loopct=0
X         if(ndata.ne.nname) call err(' Syntax construction error')
XC
XCdbg     WRITE(6,'(a)')
XCdbg *   ' data name                       type recd char loop leng'
XCdbg     WRITE(6,'(a,1x,a,4i5)') (dname(i),dtype(i),drecd(i),dchar(i),
XCdbg *              nloop(i),iloop(i),i=1,nname)
XCdbg     WRITE(6,'(3i5)') (i,loopni(i),loopnp(i),i=1,loopct)
XC
X         return
X         end
XC
XC
XC
XC
XC
XC
XC >>>>>> Get the attributes of data item associated with data name
XC
X         function test_(temp)
XC
X         logical   test_
X         include   'ciftbx.sys'
X         character  temp*(*),name*(NUMCHAR)
X         character  otestf*3
X         character  locase*(MAXBUF)
XC
X         otestf=testfl
X         testfl='yes'
X         name=locase(temp)
X         test_=.true.   
X         if(otestf.eq.'no ')  goto 100
X         if(name.eq.nametb)   goto 200
X100      call getitm(name)        
X200      list_ =loopnl
X         if(type_.eq.'null') test_=.false.
X         return
X         end
X
XC
XC
XC
XC
XC
XC >>>>>> Set or Reference a bookmark
XC
X         function bkmrk_(mark)
XC
X         logical   bkmrk_
X         include   'ciftbx.sys'
XC
X         integer   mark,ii,nitem
X         character*4 flag
X         bkmrk_=.true.
X         if(mark.eq.0) then
X           do ii=1,MAXBOOK
X             if(ibkmrk(1,ii).lt.0)      goto 100
X           enddo
X           bkmrk_=.false.
X           call warn(' More than MAXBOOK bookmarks requested')
X           return
X100        mark=ii
X           ibkmrk(1,ii)=iname
X           ibkmrk(2,ii)=irecd
X           ibkmrk(3,ii)=jchar
X           if(iname.gt.0) then
X             ibkmrk(2,ii) = trecd(iname)
X             ibkmrk(3,ii) = tchar(iname)
X           endif
X           ibkmrk(4,ii)=0
X           if(iname.gt.0) then
X             if(nloop(iname).ne.0.and.
X     *         loopnl.eq.nloop(iname).and.loopct.ne.0) then
X               nitem=loopni(nloop(iname))
X               ibkmrk(2,ii)=looprd(1)
X               ibkmrk(3,ii)=max(0,loopch(1)-1)
X               ibkmrk(4,ii)=loopct
X             endif
X           endif
X         else
X           if(ibkmrk(1,mark).lt.0) then
X             bkmrk_=.false.
X             return
X           endif
X           iname=ibkmrk(1,mark)
X           irecd=ibkmrk(2,mark)
X           loopct=ibkmrk(4,mark)
X           loop_=.false.
X           text_=.false.
X           loopnl=-1
X           testfl='no '
X           if(iname.gt.0) then
X            if(nloop(iname).ne.0.and.loopct.ne.0) then
X               nitem=loopni(nloop(iname))
X               looprd(nitem+1)=ibkmrk(2,mark)
X               loopch(nitem+1)=ibkmrk(3,mark)
X               do ii = 1,nitem
X                 lloop(ii+iname-iloop(iname))=loopct-1
X               enddo
X               loopct=loopct-1
X               if(lloop(iname).gt.0) then
X                 loop_=.true.
X                 loopnl=nloop(iname)
X               endif
X             endif
X           endif
X           jchar=MAXBUF
X           if(irecd.gt.0) then
X             irecd=irecd-1
X             call getlin(flag)
X             jchar=ibkmrk(3,mark)
X           endif
X           ibkmrk(1,mark)=-1
X           mark=0
X         endif
X         return
X         end
XC
XC
XC
XC
XC
XC
XC >>>>>> Find the location of the requested item in the CIF
XC        The argument "name" may be a data item name, blank
XC        for the next such item.  The argument "type" may be
XC        blank for unrestricted acceptance of any non-comment
XC        string (use cmnt_ to see comments), including loop headers,
XC        "name" to accept only the name itself and "valu"
XC        to accept only the value, or "head" to position to the
XC        head of the CIF.  Except when the "head" is requested,
XC        the position is  left after the data item provided.
XC
X         function find_(name,type,strg)
XC
X         logical   find_
X         include   'ciftbx.sys'
X         character  name*(*),type*(*),strg*(*),flag*4
X         character  jjbuf*(MAXBUF)
X         integer    jjchar,jjrecd,jjlast,jjlrec,jjjrec
XC
X         find_  = .false.
X         strg   = ' '
X         long_  = 0
X         jjchar = jchar
X         jjrecd = lrecd
X         jjlast = lastch
X         jjlrec = lrecd
X         jjjrec = jrecd
X         jjbuf  = ' '
X         if(lastch.gt.0) jjbuf(1:lastch)=buffer(1:lastch)
X         if(type.eq.'head') then
X           lrecd = nrecd
X           irecd=0
X           jchar=MAXBUF+1
X           call getlin(flag)
X           if(flag.eq.'fini')       goto 300
X           find_=.true.
X           lrecd=jjlrec
X           return
X         endif
X         if(name.ne.' ') then
X           testfl='no '
X           call getitm(name)
X           if(iname.eq.0) goto 300
X           if(type.eq.'valu') then
X             list_=loopnl
X             strg=strg_(1:long_)
X             find_=.true.
X             return
X           endif
X           if(type.eq.'name'.or.loopnl.eq.0) then
X             irecd=trecd(iname)-1
X             call getlin(flag)
X             jchar=tchar(iname)
X             posnam_=jchar+1
X             call getstr
X             strg=strg_(1:long_)
X             recn_=irecd
X             find_=.true.
X             return
X           endif
X           if(type.eq.' ') then
X             irecd=loorec(loopnl)-1
X             call getlin(flag)
X             jchar=loopos(loopnl)
X             call getstr
X             posval_=loopos(loopnl)
X             if(tabx_) posval_=loopox(loopnl)
X             strg=strg_(1:long_)
X             recn_=irecd
X             find_=.true.
X             return
X           endif
X           call err(' Call to find_ with invalid arguments')
X         endif
X         if(name.eq.' ') then
X200        call getstr
X           if(type_.eq.'fini')      goto 300
X           if(type.ne.' '.and.
X     *      (type_.eq.'data'.or.type_.eq.'save'))   goto 300
X           if(type.eq.'name'.and.type_.ne.'name')  goto 200
X           if(type.eq.'valu'.and.
X     *       type_.ne.'numb'.and.type_.ne.'text'
X     *      .and.type_.ne.'char'.and.type_.ne.'null') goto 200
X           find_=.true.
X           strg=strg_(1:long_)
X           if(type_.eq.'name') then
X             posnam_=jchar-long_
X           else
X             posval_=jchar-long_
X             if(quote_.ne.' ') posval_=posval_-1
X           endif
X           recn_=irecd
X           return
X         endif
X    
XC
XC        Search failed, restore pointers
XC
X300      irecd  = jjrecd
X         lastch = jjlast
X         lrecd  = jjlrec
X         jchar  = jjchar
X         buffer = ' '
X         if(lastch.gt.0)buffer(1:lastch)=jjbuf(1:lastch)
X         jrecd  = jjjrec
X         if(jrecd.ne.irecd) jrecd=-1
X         recn_  = irecd
XC           
X         return
X         end
XC
XC
XC
XC
XC
XC
XC >>>>>> Get the next data name in the data block
XC
X         function name_(temp)
XC
X         logical    name_
X         include   'ciftbx.sys'
X         character  temp*(*)
XC
X         name_=.false.
X         temp=' '
X         iname=iname+1
X         if(iname.gt.nname)  goto 100
X         name_=.true.
X         temp=dtag(iname)
X         if(ddict(iname).ne.0) temp=dictag(ddict(iname))
X100      return
X         end
XC
XC
XC
XC
XC
XC
XC >>>>>> Extract a number data item and its standard deviation
XC        This version return single precision numbers
XC
X         function numb_(temp,numb,sdev)
XC
X         logical    numb_
X         include   'ciftbx.sys'
X         character  temp*(*),name*(NUMCHAR)
X         character  locase*(MAXBUF)
X         real       numb,sdev
XC
X         name=locase(temp)
X         if(testfl.eq.'no ')  goto 100
X         if(name.eq.nametb)   goto 150
XC
X100      call getitm(name)
XC
X150      numb_=.false.
X         if(type_.ne.'numb') goto 200
X         numb_=.true.
X         numb =numbtb
X         if(sdevtb.ge.0.0) sdev=sdevtb
XC
X200      testfl='no '
X         return
X         end
XC
XC
XC
XC
XC
XC
XC >>>>>> Extract a number data item and its standard deviation
XC        This version returns double precision numbers
XC
X         function numd_(temp,numb,sdev)
XC
X         logical    numd_
X         include   'ciftbx.sys'
X         character  temp*(*),name*(NUMCHAR)
X         character  locase*(MAXBUF)
X         double precision numb,sdev
XC
X         name=locase(temp)
X         if(testfl.eq.'no ')  goto 100
X         if(name.eq.nametb)   goto 150
XC
X100      call getitm(name)
XC
X150      numd_=.false.
X         if(type_.ne.'numb') goto 200
X         numd_=.true.
X         numb =numbtb
X         if(sdevtb.ge.0.0) sdev=sdevtb
XC
X200      testfl='no '
X         return
X         end
XC
XC
XC
XC
XC
XC
XC >>>>>> Extract a character data item.
XC
X         function char_(temp,strg)
XC
X         logical    char_
X         include   'ciftbx.sys'
X         character  temp*(*),name*(NUMCHAR)
X         character  strg*(*),flag*4
X         character  locase*(MAXBUF)
X         integer    icpos,itpos,ixpos,ixtpos,ipp,iepos,ispos
XC
X         name=locase(temp)
X         if(testfl.eq.'yes')    goto 100
X         if(.not.text_)         goto 120
X         if(name.ne.nametb)     goto 120
X         char_=.false.
X         text_=.false.
X         strg=' '
X         long_=0
X         call getlin(flag)
X         if(flag.eq.'fini')    goto 200
X         if(buffer(1:1).eq.';') then
X           jchar=2
X           goto 200
X         endif
X         quote_=' '
X         jchar=lastch+1
X         long_=lastch
X         strg_(1:long_)=buffer(1:long_)
X         goto 150
XC
X100      if(name.eq.nametb)     goto 150
XC
X120      call getitm(name)
X         if(type_.eq.'null') then
X           char_=.false.
X           text_=.false.
X           strg_=' '
X           long_=0
X           goto 200
X         endif
XC
X150      char_=.true.
X         text_=.false.
X         if(tabx_) then
X           call detab
X           icpos=jchar-long_
X           if(quote_.ne.' ') icpos=icpos-1
X           iepos=icpos+long_-1
X           itpos=0
X           do ipp=1,icpos
X             itpos=itpos+1
X             if(buffer(ipp:ipp).eq.tab) itpos=((itpos+7)/8)*8
X           enddo
X           ispos=itpos
X160        ixpos=index(buffer(icpos:iepos),tab)
X           ixtpos=itpos+ixpos-1
X           if(ixpos.gt.0.and.ixtpos.le.MAXBUF) then
X             ixtpos=((ixtpos+7)/8)*8
X             icpos=icpos+ixpos
X             itpos=ixtpos+1
X             if(icpos.le.iepos) goto 160
X           else
X           strg =
X     *       bufntb(ispos:min(MAXBUF,itpos+iepos-icpos))
X           long_=min(MAXBUF,itpos+iepos-icpos)-ispos+1
X           if(ispos.eq.1.and.strg(1:1).eq.';')
X     *       strg(1:1) = ' '
X           endif
X         else
X           strg=strg_(1:long_)
X         endif
X         if(type_.eq.'char')   goto 200
X         char_=.false.
X         if(type_.ne.'text')   goto 200
X         char_=.true.
X         call getlin(flag)
X         jchar=MAXBUF+1
X         if(flag.eq.'fini')    goto 200
X         if(buffer(1:1).eq.';')then
X           jchar=2
X           goto 200
X         endif
X         irecd=irecd-1
X         text_=.true. 
XC
X200      testfl='no '
X         return
X         end
XC
XC
XC
XC
XC
XC
XC >>>>>> Extract a comment field.               
XC
X         function cmnt_(strg)          
XC
X         logical   cmnt_
X         integer   lastnb
X         include  'ciftbx.sys'
X         character strg*(*),flag*4,c*1,
X     *     jjbuf*(MAXBUF)
X         integer   jjchar,jjrecd,jjlast,jjlrec,jjjrec
X         integer   ipp,itpos,ixpos
XC
X         jjchar = jchar
X         jjrecd = irecd
X         jjlast = lastch
X         jjlrec = lrecd
X         jjjrec = jrecd
X         jjbuf=' '
X         if(lastch.gt.0)jjbuf(1:lastch)=buffer(1:lastch)
X         lrecd = nrecd
X         if(bloc_.eq.' ') then
X           if(irecd.eq.0) jchar=MAXBUF
X         endif
X         strg=' '
X         long_=0
X         cmnt_=.false.
X         goto 105
X100      jchar=jchar+1
X105      if(jchar.le.lastch)     goto 140
XC
XC....... Read a new line
XC
X110      call getlin(flag)
X         if(flag.eq.'fini') then
X           strg='fini'
X           jchar=MAXBUF+1
X           long_=4
X           cmnt_=.false.
X           return
X         endif
X         jchar=1
X         strg=char(0)
X         long_=1
X         posnam_=0
X         goto 220
X140      if(lastch.eq.1.and.buffer(1:1).eq.' ') go to 200
XC
XC....... Process this character in the line
XC
X150      c=buffer(jchar:jchar)
X         if(c.eq.' ')       goto 100
X         if(c.eq.tab.and.(.not.tabx_)) goto 190
X         if(c.eq.tab)       goto 100
X         if(c.eq.'#')       goto 200
X         goto 300
XC
XC        For a tab, when not expanding to blanks, accept
XC        that single character as a comment
XC
X190      long_=1
X         strg=tab
X         posnam_=jchar
X         jchar=jchar+1
X         goto 220
XC
XC....... Accept the remainder of the line as a comment 
XC
X200      long_=lastch-jchar
X         itpos=jchar
X         if(tabx_) then
X           itpos=0
X           do ipp=1,jchar
X             itpos=itpos+1
X             if(buffer(ipp:ipp).eq.tab) itpos=((itpos+7)/8)*8
X           enddo
X         endif
X210      posnam_=itpos
X         if(long_.gt.0) then
X           if(tabx_) then
X             call detab
X             ixpos= lastnb(bufntb)
X             strg = bufntb(itpos+1:ixpos)
X           else
X             strg = buffer(jchar+1:lastch)
X           endif
X         endif
X         if(long_.le.0) then
X           strg=' '
X           long_=1
X         endif
X         jchar=MAXBUF+1
X220      lrecd=jjlrec
X         cmnt_=.true.
X         return
XC
XC....... Found a non-comment field, restore pointers
XC
X300      irecd = jjrecd
X         lastch = jjlast
X         lrecd = jjlrec
X         jchar = jjchar
X         buffer=' '
X         if(lastch.gt.0)buffer(1:lastch)=jjbuf(1:lastch)
X         jrecd=jjjrec
X         if(jrecd.ne.irecd) jrecd=-1
X         recn_=irecd
X         return
X         end
XC
XC
XC
XC
XC
XC >>>>> Convert name string to lower case
XC        
X         function locase(name)
XC
X         include     'ciftbx.sys'
X         character    locase*(MAXBUF)
X         character    temp*(MAXBUF),name*(*)
X         character    low*26,cap*26,c*1
X         integer i,j
X         data  cap /'ABCDEFGHIJKLMNOPQRSTUVWXYZ'/
X         data  low /'abcdefghijklmnopqrstuvwxyz'/
XC
X         temp=name
X         do 100 i=1,MAXBUF
X         c=temp(i:i)
X         if(c.eq.' ') goto 200
X         if(c.eq.tab) goto 200
X         j=index(cap,c)
X         if(j.ne.0) temp(i:i)=low(j:j)        
X100      continue
X200      locase=temp
X         return
X         end
XC
XC
XC
XC
XC
XC >>>>>> Get the data item associated with the tag.
XC
X         subroutine getitm(name)
XC
X         include   'ciftbx.sys'
X         SAVE
X         character name*(*)
X         character flag*4
X         integer   iitem,nitem,npakt
X         integer   kchar,loopi,i,j,itpos,ipp
XC
XC....... Find requested dataname in hash list
XC
X         nametb=name
X         posnam_=0
X         posval_=0
X         posdec_=0
X         posend_=0
X         quote_=' '
X         if(name(1:1).eq.'_')       goto 100
X         type_='null'
X         dictype_='null'
X         diccat_='(none)'
X         dicname_=name
X         tagname_=' '
X         strg_=' '
X         long_=1
X         goto 1000
X100      call hash_find(nametb,
X     *     dname,dchain,NUMBLOCK,nname,dhash,NUMHASH,
X     *     iname)
X         if(iname.gt.0)             goto 180
X         if(dictfl.ne.'yes') then
X         call hash_find(nametb,
X     *     dicnam,dicchain,NUMDICT,ndict,dichash,NUMHASH,j)
X         if(j.ne.0) then
X           dictype_=dicxtyp(j)
X           if(dcindex(j).ne.0) diccat_=dcname(dcindex(j))
X           dicname_=nametb
X           if(aroot(j).ne.0) then
X             dicname_=dictag(aroot(j))
X             call hash_find(dicnam(aroot(j)),
X     *         dname,dchain,NUMBLOCK,nname,dhash,NUMHASH,
X     *         iname)
X             if(iname.gt.0)      goto 180
X           endif
X           type_='null'
X           tagname_=' '
X           strg_=' '
X           long_=1
X           go to 1000
X         endif
X         endif
X160      continue
X         type_='null'
X         dictype_='null'
X         diccat_='(none)'
X         dicname_=name
X         long_=1
X         goto 1000
XC
XC
X180      tagname_=dtag(iname)
X         if(ddict(iname).ne.0) tagname_=dictag(ddict(iname))
X         posnam_=tchar(iname)
X         if(tabx_)posnam_=xchar(iname)
X         if(nloop(iname).le.0)      goto 500
XC
XC....... Process loop packet if first item request
XC
X         if(nloop(iname).ne.loopnl) goto 200
X         if(lloop(iname).lt.loopct) goto 300
X         if(loop_)                  goto 230
X200      loop_=.true.
X         loopct=0
X         loopnl=nloop(iname)
X         nitem=loopni(loopnl)
X         npakt=loopnp(loopnl)
X         irecd=drecd(iname)-1
X         call getlin(flag)
X         jchar=max(0,dchar(iname)-1)
XCdbg     if(jchar.lt.0) write(6,'(7H dchar ,i5)') jchar
X         do 220 i=1,nitem
X220      lloop(i+iname-iloop(iname))=0
X         goto 240
XC
XC....... Read a packet of loop items
XC
X230      nitem=loopni(loopnl)
X         npakt=loopnp(loopnl)
X         irecd=looprd(nitem+1)-1
X         call getlin(flag)
X         jchar=loopch(nitem+1)
XCdbg     if(jchar.lt.0) write(6,'(7H loopch,i5)') jchar
X240      iitem=0
X250      iitem=iitem+1
X         if(iitem.le.nitem)     goto 255
X         loopch(iitem)=jchar
X         looprd(iitem)=irecd
X         goto 270
X255      call getstr
X         loopch(iitem)=jchar-long_
X         if(quote_.ne.' ')loopch(iitem)=jchar-long_-1
X         loopln(iitem)=long_
X         looprd(iitem)=irecd
X         if(buffer(1:1).ne.';')     goto 250
X260      call getlin(flag)
X         if(buffer(1:1).ne.';') goto 260
X         jchar=2
X         goto 250
X270      loopct=loopct+1
X         if(loopct.lt.npakt)    goto 300
X         loop_=.false.
XC
XC....... Point to the loop data item
XC
X300      lloop(iname)=lloop(iname)+1
X         loopi=iloop(iname)
X         irecd=looprd(loopi)-1
X         call getlin(flag)
X         long_=loopln(loopi)
X         kchar=loopch(loopi)
X         goto 550
XC
XC....... Point to the non-loop data item
XC
X500      irecd=drecd(iname)-1
X         call getlin(flag)
X         kchar=dchar(iname)+1
X         long_=iloop(iname)
X         loop_=.false.
X         loopct=0
X         loopnl=0
XC
XC....... Place data item into variable string and make number
XC
X550      type_=dtype(iname)
X         dictype_=dxtyp(iname)
X         diccat_='(none)'
X         if(cindex(iname).gt.0) diccat_=dcname(cindex(iname))
X         if(cindex(iname).lt.0) diccat_=cname(-cindex(iname))
X         if(diccat_.eq.' ') diccat_='(none)'
X         dicname_=dtag(iname)
X         if(ddict(iname).ne.0) then
X           if (aroot(ddict(iname)).ne.0) then
X             dicname_=dictag(aroot(ddict(iname)))
X           endif
X         endif
X         strg_(1:long_)=buffer(kchar:kchar+long_-1)
X         itpos=kchar
X         if(tabx_) then
X         itpos=0
X         do ipp=1,kchar
X           itpos=itpos+1
X           if(buffer(ipp:ipp).eq.tab) itpos=((itpos+7)/8)*8
X         enddo
X         endif
X         posval_=itpos
X         posend_=itpos+long_-1
X         jchar=kchar+long_
X         if(jchar.le.MAXBUF) then
X           if(buffer(jchar:jchar).ne.' ' .and.
X     *       buffer(jchar:jchar).ne.tab) jchar=jchar+1
X         endif
X         quote_=' '
X         if(kchar.gt.1) then
X           if(buffer(kchar-1:kchar-1).ne.' ' .and.
X     *        buffer(kchar-1:kchar-1).ne.tab) then
X             quote_=buffer(kchar-1:kchar-1)
X           endif
X         endif
X         if(type_.eq.'char' .and. kchar.eq.1 .and.
X     *     buffer(1:1).eq.';') type_='text'
X         if(type_.eq.'text') then
X           if(buffer(1:1).eq.';') then
X             strg_(1:1)=' '
X           else
X             type_='char'
X           endif
X         endif
X         if(type_.eq.'numb') then
X           call ctonum
X           if(posdec_.gt.0) posdec_=posval_+posdec_-1
X         endif
X         if(quote_.ne.' ') goto 1000
X         if(long_.eq.1.and.strg_(1:1).eq.'?') type_='null'
X         if(long_.eq.1.and.strg_(1:1).eq.'.') type_='null'
XC
X1000     return
X         end
XC
XC
XC
XC
XC
XC
XC
XC >>>>>> Read the next string from the file
XC
X         subroutine getstr
XC
X         include   'ciftbx.sys'
X         integer   i,j,jj(11),im
X         logical   quoted
X         character c*1,num*21,flag*4
X         data num/'0123456789+-.()EDQedq'/
XC
X         quoted=.false.
X         quote_=' '
X         if(irecd.gt.0.and.
X     *     jchar.eq.1.and.lastch.gt.0) goto 140
X100      jchar=jchar+1
X         if(jchar.le.lastch)     goto 150
XC
XC....... Read a new line
XC
X110      call getlin(flag)
X         type_='fini'
X         dictype_=type_
X         diccat_='(none)'
X         dicname_=' '
XCdbg     write(6,'(/5i5,a)') 
XCdbg *              irecd,jrecd,lrecd,nrecd,lastch, buffer(1:lastch)
X         if(flag.eq.'fini')  goto 500
XC
XC....... Test if the new line is the start of a text sequence
XC
X140      if(buffer(1:1).ne.';') goto 150
X         type_='text'
X         jchar=lastch+1
X         long_=lastch
X         strg_(1:long_)=buffer(1:long_)
X         strg_(1:1)=' '
X         goto 500
XC
XC....... Process this character in the line
XC
X150      c=buffer(jchar:jchar)
X         if(c.eq.' ')       goto 100
X         if(c.eq.tab)       goto 100
X         if(c.eq.'#')       goto 110
X         if(c.eq.'''')      goto 300
X         if(c.eq.'"')       goto 300
X         if(c.ne.'_')       goto 200
X         type_='name'
X         goto 210
XC
XC....... Span blank delimited token; test if a number or a character 
XC
X200      type_='numb'
X         im=0
X         do 205 i=1,11
X205      jj(i)=0
X210      do 250 i=jchar,lastch
X         if(buffer(i:i).eq.' ')       goto 400
X         if(buffer(i:i).eq.tab)       goto 400
X         if(type_.ne.'numb')          goto 250
X         j=index(num,buffer(i:i))
X         if(j.eq.0)                 type_='char'
X         if(j.le.10) then
X           im=im+1
X           goto 250
X         endif
X         if(j.gt.13.and.im.eq.0) type_='char'
X         jj(j-10)=jj(j-10)+1
X250      continue
X         i=lastch+1
X         if(type_.ne.'numb') goto 400
X         do 270 j=1,5
X         if((jj(j).gt.1.and.j.gt.2) .or.
X     *     jj(j).gt.2)             type_='char'
X270      continue
X         goto 400
XC
XC....... Span quote delimited token; assume character
XC
X300      type_='char'
X         quoted=.true.
X         jchar=jchar+1
X         do 320 i=jchar,lastch
X         if(buffer(i:i).ne.c)             goto 320
X         if(i+1.ge.lastch)                goto 400
X         if(buffer(i+1:i+1).eq.' ')       goto 400
X         if(buffer(i+1:i+1).eq.tab)       goto 400
X320      continue
XCdbg     write(6,'(a,4i5,a)') 
XCdbg *       '**** ',irecd,lastch,i,jchar,buffer(jchar:i)       
X         call warn(' Quoted string not closed')
XC
XC....... Store the string for the getter
XC
X400      long_=i-jchar
X         strg_(1:long_)=buffer(jchar:i-1)
X         jchar=i
X         quote_=' '
X         if(quoted) then
X           quote_=buffer(jchar:jchar)
X           jchar =jchar+1
X         endif
XCdbg     write(6,'(5x,8i5,5x,a)') 
XCdbg *   irecd,jrecd,lrecd,nrecd,lastch,i,jchar,long_,strg_(1:long_)
X         if(type_.ne.'char'.or.quoted) goto 500
X         if(strg_(1:5).eq.'data_') type_='data'
X         if(strg_(1:5).eq.'loop_') type_='loop'
X         if(long_.eq.1.and.strg_(1:1).eq.'?') type_='null'
X         if(long_.eq.1.and.strg_(1:1).eq.'.') type_='null'
X         if(strg_(1:5).eq.'save_') type_='save'
XC
X500      return
X         end
XC
XC
XC
XC
XC
XC
XC >>>>>> Convert a character string into a number and its esd
XC
XC                                          Q
XC                                          D+
XC                                          E-
XC                                +         +
XC           number string        -xxxx.xxxx-xxx(x)
XC           component count CCNT 11111222223333444
XC           (with at least 1 digit in the mantissa)
XC
X         subroutine ctonum
XC
X         integer   lastnb
X         include  'ciftbx.sys'
X         character test*22,c*1
X         integer*4 m,nchar
X         integer*4 ccnt,expn,msin,esin,ndec,ids,nmd
X         double precision numb,sdev,ntemp,mant
X         data test /'0123456789+.-()EDQedq '/
XC
X         numbtb=0.D0
X         sdevtb=-1.D0
X         numb=1.D0
X         sdev=0.D0
X         ccnt=0
X         mant=0.D0
X         expn=0.
X         msin=+1
X         esin=+1
X         ndec=0
X         ids=0
X         nmd=0
X         type_='char'
X         posdec_=0
X         if(long_.eq.1.and.
X     *     index('0123456789',strg_(1:1)).eq.0) goto 500
XC
XC....... Loop over the string and identify components
XC
XC        The scan works in phases
XC          ccnt = 0   processing looking for first digit
XC          ccnt = 1   processing before decimal point
XC          ccnt = 2   processing after decimal point
XC          ccnt = 3   processing exponent
XC          ccnt = 4   processing standard deviation
XC
X         do 400 nchar=1,long_
XC
X         c=strg_(nchar:nchar)
X         m=index(test,c)
X         if(m.eq.0)     goto 500
X         if(m.gt.10)    goto 300
XC
XC....... Process the digits
XC
X         if(ccnt.eq.0)  ccnt=1
X         if(ccnt.eq.2)  ndec=ndec+1
X         if(ccnt.gt.2)  goto 220
X         ntemp=m-1
X         mant=mant*10.D0+ntemp
X         nmd=nmd+1
X         if(ccnt.eq.1.and.mant.ne.0.D0) ids=ids+1
X         goto 400
X220      if(ccnt.gt.3)  goto 240
X         expn=expn*10+m-1
X         goto 400
X240      ntemp=m-1
X         sdev=sdev*10.D0+ntemp
X         sdevtb=1.D0
X         goto 400
XC
XC....... Process the characters    . + - ( ) E D Q
XC
X300      if(c.ne.'.')  goto 320
X         if(ccnt.gt.1) goto 500
X         posdec_=nchar
X         ccnt=2
X         goto 400
XC
X320      if(nmd.eq.0.and.m.gt.13) goto 500
X         if(c.ne.'(')  goto 340
X         if(posdec_.eq.0) posdec_=nchar
X         ccnt=4
X         goto 400
XC
X340      if(posdec_.eq.0.and.ccnt.gt.0) posdec_=nchar
X         if(c.eq.' ')  goto 400
X         if(m.gt.13) m = 11
X         if(ccnt.eq.3) goto 500
X         if(ccnt.gt.0) goto 360
X         ccnt=1
X         msin=12-m
X         goto 400
X360      ccnt=3
X         esin=12-m
XC
X400      continue
X         if(posdec_.eq.0) posdec_=lastnb(strg_(1:long_))+1
XC
XC....... String parsed; construct the numbers
XC
X         expn=expn*esin-ndec
X         if(expn+ids.gt.-minexp) then
X           call warn(' Exponent overflow in numeric input')
X           expn=-minexp-ids
X         endif
X         if(expn.lt.minexp) then
X           call warn(' Exponent underflow in numeric input')
X           expn=minexp
X         endif
X         if(expn.lt.0) numb=1./10.D0**abs(expn)
X         if(expn.gt.0) numb=10.D0**expn
X         if(sdevtb.gt.0.0) sdevtb=numb*sdev
X         ntemp=msin
X         numbtb=numb*mant*ntemp
X         type_='numb'
XC
X500      return
X         end
XC
XC
XC
XC
XC
XC
XC >>>>>> Read a new line from the direct access file
XC
X         subroutine getlin(flag)
XC
X         integer   lastnb
X         include  'ciftbx.sys'
X         character flag*4
XC
X         irecd=irecd+1
X         jchar=1
X         if(irecd.eq.jrecd)  goto 200
X         if(irecd.le.lrecd)  goto 100
X         buffer=' '
X         lastch=0
X         jchar=MAXBUF+1
X         jrecd=-1
X         flag='fini'
X         goto 200
X100      read(dirdev,'(a)',rec=irecd) buffer
X         recn_=irecd
X         lastch=max(1,lastnb(buffer))
X         jrecd=irecd
X         flag=' '
X200      return
X         end
XC
XC
XC
XC
XC
XC
XC >>>>>> Detab buffer into bufntb
XC
X         subroutine detab
XC
X         include   'ciftbx.sys'
X         integer   icpos,itpos,ixpos,ixtpos
X         if(jrecd.eq.jrect) return
X         icpos=1
X         itpos=1
X         bufntb=' '
X         if(lastch.gt.0) then
X100      ixpos=index(buffer(icpos:lastch),tab)
X         ixtpos=ixpos+itpos-1
X         if(ixpos.gt.0.and.ixtpos.le.MAXBUF) then
X           ixtpos=((ixtpos+7)/8)*8
X           if(ixpos.gt.1) then
X           bufntb(itpos:ixtpos)=
X     *       buffer(icpos:ixpos+icpos-2)
X           else
X           bufntb(itpos:ixtpos)=' '
X           endif
X           itpos=ixtpos+1
X           icpos=ixpos+icpos
X           goto 100
X         else
X           bufntb(itpos:max(MAXBUF,itpos+lastch-icpos))=
X     *       buffer(icpos:lastch)
X         endif
X         endif
X         jrect=jrecd
X         return
X         end
XC
XC
XC
XC
XC
XC
XC >>>>>> Write error message and exit.
XC
X         subroutine err(mess)
X         character*(*) mess
X         call cifmsg('error',mess)
X         stop
X         end
XC
XC
XC
XC
XC
XC
XC >>>>>> Write warning message and continue.
XC
X         subroutine warn(mess)
X         character*(*) mess
X         call cifmsg('warning',mess)
X         return
X         end
XC
XC
XC
XC
XC
XC
XC >>>>>> Write a message to the error device
XC
X         subroutine cifmsg(flag,mess)
XC
X         integer    lastnb
X         include   'ciftbx.sys'
X         character*(*) flag
X         character*(*) mess
X         character*(MAXBUF)  tline
X         character*5   btype
X         integer       ll,ls,ltry,ii,i
XC
X         btype = 'data_'
X         if(save_) btype = 'save_'
X         tline= ' ciftbx '//flag//': '
X     *   //file_(1:longf_)//' '//btype
X     *   //bloc_(1:max(1,lastnb(bloc_)))//' line:'
X         ll = max(1,lastnb(tline))
X         write(errdev,'(a,i7)')tline(1:ll),irecd
X         ll=len(mess)
X         ls=1
X100      if(ll-ls.le.79) then
X           write(errdev,'(1X,a)') mess(ls:ll)
X           return
X         else
X           ltry = min(ll,ls+79)
X           do ii = ls+1,ltry
X           i = ltry-ii+ls+1
X           if(mess(i:i).eq.' ') then
X             write(errdev,'(1X,a)') mess(ls:i-1)
X             ls=i+1
X             if(ls.le.ll) go to 100
X             return
X           endif
X           enddo
X           write(errdev,'(1X,a)') mess(ls:ltry)
X           ls=ltry+1
X           if(ls.le.ll) go to 100
X           return
X         endif  
X         end
XC
XC
XC
XC
XC >>>>>> Create a named file.
XC
X         function pfile_(fname)
XC
X         logical   pfile_
X         include   'ciftbx.sys'
X         logical   test
X         integer   i
X         character fname*(*)
XC
XC....... Test if a file by this name is already open.
XC
X         if(pfilef.eq.'yes') call close_
X         pfilef='no '
X         file_=fname
X         do 120 i=1,MAXBUF
X         if(file_(i:i).eq.' ') goto 140
X120      continue
X140      if (i.gt.1) then
X           inquire(file=file_(1:i-1),exist=test)
X           pfile_=.false.
X           longf_ = i-1
X           if(test)            goto 200
X         else
X           file_ = ' '
X           pfile_ = .true.
X           longf_ = 1
X         endif
XC
XC....... Open up a new CIF
XC
X         if (file_(1:1) .ne. ' ')  then 
X         open(unit=outdev,file=fname,status='NEW',access='SEQUENTIAL',
X     *                    form='FORMATTED')
X         precn_=0
X         endif
X         pfile_=.true.  
X         pfilef='yes'
X         nbloc=0
X         pchar=1+lprefx
X         pcharl=0
X         obuf=prefx
X         obuf(pchar:MAXBUF)=' '
X200      return
X         end
XC
XC
XC
XC
XC
XC >>>>>> Store a data block command in the CIF
XC        Call with blank name to close current block only
XC
X         function pdata_(name) 
XC
X         logical   pdata_
X         include  'ciftbx.sys'
X         character name*(*),temp*(MAXBUF)
X         character dbloc(100)*(NUMCHAR)
X         integer   i
XC
X         pdata_=.true.
X         if(ploopn.ne.0)     call eoloop
X         if(ptextf.eq.'yes') call eotext
X         if(psaveo) then
X           pchar=-1
X           if(pposval_.ne.0) then
X             pchar=lprefx+1
X             call putstr(' ')
X             pchar=lprefx+pposval_
X             pposval_=0
X           endif
X           call putstr('save_')
X           psaveo=.false.
X         endif
XC
XC....... Check for duplicate data name
XC
X         temp=name
X         if(temp.eq.' ')        goto 200
X         if(saveo_)             goto 130
X         pdata_=.false.
X         do 120 i=1,nbloc
X         if(temp.eq.dbloc(i))   goto 200
X120      continue
XC
XC....... Save block name and put data_ statement
XC
X         nbloc=nbloc+1
X         if(nbloc.le.100) dbloc(nbloc)=temp
X130      pchar=-1
X         temp='data_'//name
X         if(saveo_) temp='save_'//name
X         psaveo=saveo_
X         if(pposnam_.gt.0) then
X           pchar=lprefx+1
X           call putstr(' ')
X           pchar=lprefx+pposnam_
X           pposnam_=0
X         endif
X         call putstr(temp)         
X         pchar=lprefx
X         pdata_=.true.
XC
X200      return
X         end
XC
XC
XC
XC
XC
XC
XC >>>>>> Put a number into the CIF, perhaps with an esd appended
XC
X         function pnumb_(name,numb,sdev)
XC
X         logical    pnumb_
X         include   'ciftbx.sys'
X         logical    flag,tflag
X         character  name*(*),temp*(NUMCHAR)
X         real       numb,sdev
X         double precision dnumb,dsdev,dprec
XC
X         pnumb_=.true.
X         flag  =.true.
X         tflag =.true.
X         temp=name
X         if(ptextf.eq.'yes') call eotext
XC
X         if(name(1:1).eq.' ')   goto 120
X         if(vcheck.eq.'no ')    goto 100
X         call dcheck(temp,'numb',flag,tflag)
X         if (aliaso_.and.xdchk.ne.0) then
X           if (aroot(xdchk).ne.0)
X     *       temp=dictag(aroot(xdchk))
X         endif
X         pnumb_=flag
X100      if(ploopn.ne.0)        call eoloop
X         pchar=-1
X         if(pposnam_.ne.0)pchar=pposnam_+lprefx
X         call putstr(temp)
XC
X120      if(ploopf.eq.'yes') ploopc=0
X         ploopf='no '
X         dprec=decprc
X         dnumb=numb
X         dsdev=sdev
X         call putnum(dnumb,dsdev,dprec)
X         if(.not.flag) then
X           if(.not.tabl_) pchar=lprefx+57
X           call putstr('#< not in dictionary')
X         endif
X         if(.not.tflag) then
X           if(.not.tabl_) pchar=lprefx+57
X           call putstr('#< not correct type')
X         endif
XC
X150      pposnam_=0
X         pposval_=0
X         pposdec_=0
X         pposend_=0
X         return
X         end
XC
XC
XC
XC
XC
XC
XC >>>>>> Put a double precision number into the CIF, perhaps 
XC        with an esd appended
XC
X         function pnumd_(name,numb,sdev)
XC
X         logical    pnumd_
X         include   'ciftbx.sys'
X         logical    flag,tflag
X         character  name*(*),temp*(NUMCHAR)
X         double precision numb,sdev
XC
X         pnumd_=.true.
X         flag  =.true.
X         tflag =.true.
X         temp=name
X         if(ptextf.eq.'yes') call eotext
XC
X         if(name(1:1).eq.' ')   goto 120
X         if(vcheck.eq.'no ')    goto 100
X         call dcheck(temp,'numb',flag,tflag)
X         if (aliaso_.and.xdchk.ne.0) then
X           if (aroot(xdchk).ne.0)
X     *       temp=dictag(aroot(xdchk))
X         endif
X         pnumd_=flag
X100      if(ploopn.ne.0)        call eoloop
X         pchar=-1
X         if(pposnam_.ne.0)pchar=pposnam_+lprefx
X         call putstr(temp)
XC
X120      if(ploopf.eq.'yes') ploopc=0
X         ploopf='no '
X         call putnum(numb,sdev,dpprc)
X         if(.not.flag) then
X           if(.not.tabl_) pchar=lprefx+57
X           call putstr('#< not in dictionary')
X         endif
X         if(.not.tflag) then
X           if(.not.tabl_) pchar=lprefx+57
X           call putstr('#< not correct type')
X         endif
XC
X150      pposnam_=0
X         pposval_=0
X         pposdec_=0
X         pposend_=0
X         return
X         end
XC
XC
XC
XC
XC
XC
XC >>>>>> Put a character string into the CIF.
XC
X         function pchar_(name,string)      
XC
X         logical    pchar_
X         include   'ciftbx.sys'
X         logical    flag,tflag
X         character  name*(*),temp*(NUMCHAR),string*(*)
X         character  line*(MAXBUF),strg*(MAXBUF)
X         integer    i,j
XC
X         pchar_=.true.
X         flag  =.true.
X         tflag =.true.
X         temp  =name
X         if(ptextf.eq.'yes') call eotext
XC
X         if(name(1:1).eq.' ')   goto 110
X         if(vcheck.eq.'no ')    goto 100
X         call dcheck(temp,'char',flag,tflag)
X         if (aliaso_.and.xdchk.ne.0) then
X           if (aroot(xdchk).ne.0)
X     *       temp=dictag(aroot(xdchk))
X         endif
X         pchar_=flag
X100      if(ploopn.ne.0)        call eoloop
X         pchar=-1
X         if(pposnam_.gt.0) pchar=posnam_+lprefx
X         call putstr(temp)
XC
X110      if(ploopf.eq.'yes') ploopc=0
X         ploopf='no '
X         line=string
X         do 120 i=MAXBUF,2,-1
X         if(line(i:i).ne.' ') goto 130
X120      continue
X130      if(pposval_.ne.0.and.pposend_.ge.pposval_)
X     *      i=max(i,pposend_-pposval_+1)
X         if(pquote_.ne.' ')   goto 150
X         do 140 j=i,1,-1
X         if(line(j:j).eq.' ') goto 150
X140      continue
X         if((line(1:1).eq.'_' 
X     *     .or. line(i:i).eq.'_'
X     *     .or. line(1:1).eq.''''
X     *     .or. line(1:1).eq.'"'
X     *     .or. line(1:1).eq.';')
X     *     .and.line(1:i).ne.'''.'''
X     *     .and.line(1:i).ne.'''?'''
X     *     .and.line(1:i).ne.'"."'
X     *     .and.line(1:i).ne.'"?"') goto 150
X         strg=line(1:i)
X         goto 200
X150      if(pquote_.eq.';')       goto 190
X         if(pquote_.eq.'''')      goto 165
X         if(pquote_.eq.'"')       goto 185
X         do 160 j=1,i
X         if(line(j:j).eq.'''')    goto 170
X160      continue
X165      strg=''''//line(1:i)//''''
X         i=i+2
X         pquote_=''''
X         goto 200
X170      do 180 j=1,i
X         if(line(j:j).eq.'"')     goto 190
X180      continue
X185      strg='"'//line(1:i)//'"'
X         i=i+2
X         pquote_='"'
X         goto 200
X190      pchar=-1
X         strg='; '//line(1:i)
X         i=i+2
X         ptextf='yes'
X         call putstr(strg(1:i))
X         pchar=-1
X         ptextf='no '
X         call putstr(';')
X         pchar=lprefx
X         call putstr(' ')
X         call warn(' Converted pchar_ output to text for: '
X     *     //strg(3:i))
X         goto 210
XC
X200      if(pposval_.ne.0) then
X           pchar=pposval_+lprefx
X           if(pquote_.ne.' ') pchar=pchar-1
X         endif
X         call putstr(strg(1:i))   
X210      if(.not.flag) then
X           if(.not.tabl_) pchar=lprefx+57
X           call putstr('#< not in dictionary')
X         endif
X         if((.not.tflag).and.line(1:i).ne.'.'.and.
X     *     line(1:i).ne.'?'.and.pquote_.eq.' ') then
X           if(.not.tabl_) pchar=lprefx+57
X           call putstr('#< not correct type')
X         endif
X250      pposval_=0
X         pposdec_=0
X         pposnam_=0
X         pposend_=0
X         pquote_=' '
X         return
X         end
XC
XC
XC
XC
XC
XC >>>>>> Put a comment in the output CIF 
XC
X         function pcmnt_(string)     
XC
X         logical    pcmnt_
X         include   'ciftbx.sys'
X         character  string*(*), temp*(MAXBUF)
XC
X         if(ptextf.eq.'yes') call eotext
X         if(pposnam_.ne.0) pchar=pposnam_+lprefx
X         if(string.eq.' '.or.
X     *     (string.eq.char(0)) .or.
X     *     (string.eq.tab.and.(.not.ptabx_))) then
X           if(string.eq.' ') pchar=-1
X           call putstr(string)
X           if(string.eq.' ') call putstr(char(0))
X         else
X           temp='#'//string
X           call putstr(temp)
X           call putstr(char(0))
X         endif
X         pcmnt_=.true.
X         pposnam_=0
X         if(string.ne.tab)pchar=lprefx+1
X         return
X         end
XC
XC
XC
XC
XC
XC
XC
XC >>>>>> Put a text sequence into the CIF.
XC
X         function ptext_(name,string)      
XC
X         logical    ptext_
X         integer    lastnb
X         include   'ciftbx.sys'
X         logical    flag,tflag
X         integer    ll
X         character  name*(*),temp*(NUMCHAR),string*(*),store*(NUMCHAR)
X         character  temp2*(MAXBUF)
X         data store/'                                '/
XC
X         ptext_=.true.
X         flag  =.true.
X         tflag =.true.
X         ll=lastnb(string)
X         if(ploopf.eq.'yes') ploopc=0
X         ploopf='no '
X         temp=name
X         if(ptextf.eq.'no ')    goto 100
X         if(temp.eq.store)      goto 150
X         call eotext
XC
X100      if(name(1:1).ne.' ')   goto 110
X         if(ptextf.eq.'yes')    goto 150
X         goto 130
XC
X110      if(ploopn.ne.0)        call eoloop
X         if(vcheck.eq.'no ')    goto 120
X         call dcheck(name,'char',flag,tflag)
X         if (aliaso_.and.xdchk.ne.0) then
X           if (aroot(xdchk).ne.0)
X     *       temp=dictag(aroot(xdchk))
X         endif
X         ptext_=flag
X120      pchar=-1
X         if(pposnam_.ne.0) pchar=pposnam_+lprefx
X         call putstr(temp)
X         if(.not.flag) then
X           if(.not.tabl_) pchar=lprefx+57
X           call putstr('#< not in dictionary')
X         endif
X         if(.not.tflag) then
X           if(.not.tabl_) pchar=lprefx+57
X           call putstr('#< not correct type')
X         endif
X130      ptextf='yes'
X         store=temp
X         if(string(1:1).eq.' '.and.ll.gt.1) then
X           pchar=-1
X           temp2=';'//string(2:ll)
X           call putstr(temp2)
X           pchar=-1
X           return
X         endif
X         pchar=-1
X         call putstr(';')
X         pchar=-1
X         if(string.eq.' ') return
X150      pchar=-1
X         call putstr(string(1:max(1,ll)))
X         pchar=-1
X         pposnam_=0
X         pposval_=0
X         pposdec_=0
X         pposend_=0
X         return
X         end
XC
XC
XC
XC
XC
XC
XC >>>>>> Put a loop_ data name into the CIF.
XC
X         function ploop_(name)      
XC
X         logical    ploop_
X         include   'ciftbx.sys'
X         logical    flag,tflag
X         character  name*(*),temp*(NUMCHAR)
XC
X         ploop_=.true.
X         flag  =.true.
X         if(ptextf.eq.'yes')    call eotext
X         if(ploopf.eq.'no ')    call eoloop
X         temp=' '
X         if(name(1:1).eq.' ')   goto 100
XC
X         if(tabl_.and.pposnam_.eq.0) then
X           temp='    '//name
X         else
X           temp=name
X         endif
X         if(vcheck.eq.'no ')    goto 100
X         call dcheck(name,'    ',flag,tflag)
X         if (aliaso_.and.xdchk.ne.0) then
X           if (aroot(xdchk).ne.0) then
X             if(tabl_.and.pposnam_.eq.0) then
X               temp='    '//dictag(aroot(xdchk))
X             else
X               temp=dictag(aroot(xdchk))
X             endif
X           endif
X         endif
X         ploop_=flag
X100      if(ploopn.ne.0)        goto 120
X         ploopf='yes'
X         pchar=-1
X         if(pposval_.ne.0) then
X           pchar=lprefx+1
X           call putstr(' ')
X           pchar=pposval_+lprefx
X         else
X           if(pposnam_.ne.0) then
X             pchar=lprefx+1
X             call putstr(' ')
X             pchar=pposnam_+lprefx+1
X           endif
X         endif
X         call putstr('loop_')
X         pchar=-1
X         if(name(1:1).eq.' ') then
X           ploopn=-1
X           return
X         endif
X120      if(pposnam_.ne.0) pchar=pposnam_+lprefx
X         call putstr(temp)
X         if(flag)               goto 130
X         if(.not.tabl_) pchar=lprefx+57
X         call putstr('#< not in dictionary')
X130      pchar=lprefx+1
X         ploopn=max(ploopn,0)+1
XC
X150      return
X         end
XC
XC
XC
XC
XC
XC >>>>>> Create or clear a prefix string
XC        Any change in the length of the prefix string flushes
XC        pending text, if any,  loops and partial output lines
XC
X         function prefx_(strg,lstrg)
XC
X         logical    prefx_
X         include   'ciftbx.sys'
X         character  strg*(*)
X         integer    lstrg,mxline
XC
X         mxline=MAXBUF
X         if(line_.gt.0) mxline=min(line_,MAXBUF)
X         if(lstrg.ne.lprefx.and.pcharl.gt.0) then
X           pchar=-1
X           call putstr(' ')
X         endif
X         if (lstrg.le.0) then
X           prefx=' '
X           if(pchar.ge.lprefx+1)pchar=pchar-lprefx
X           lprefx=0
X         else
X           if(lstrg.gt.mxline) then
X             call warn(' Prefix string truncated')
X           endif
X           prefx=strg
X           if(pchar.ge.lprefx+1)pchar=pchar-lprefx+lstrg
X           obuf(1:min(mxline,lstrg))=prefx
X           lprefx=lstrg
X           if(mxline-lprefx.lt.NUMCHAR) then
X             call warn(' Output prefix may force line overflow')
X           endif
X         endif
X         prefx_=.true.
X         return
X         end
XC
XC
XC
XC
XC
XC
XC >>>>>> Close the CIF
XC
X         subroutine close_
XC
X         include   'ciftbx.sys'
XC
X         if(ptextf.eq.'yes') call eotext
X         if(ploopn.ne.0)     call eoloop
X         if(pcharl.ge.lprefx+1) then
X           pchar=-1
X           call putstr(' ')
X         endif
X         if (file_(1:1) .ne. ' ') then
X           close(outdev)
X           precn_=0
X         endif
X         return
X         end
XC
XC
XC
XC
XC
XC >>>>>> Put the string into the output CIF buffer 
XC
X         subroutine putstr(string)     
XC
X         integer    lastnb
X         include   'ciftbx.sys'
X         SAVE
X         character  string*(*),temp*(MAXBUF),bfill*(MAXBUF)
X         character  temp2*(MAXBUF)
X         integer    i,ii,mxline,ioffst,ifree,icpos,itpos
X         integer    ixpos,ixtpos,it,im,kbin,kpass
X         logical    pflush,waslop
X         data       waslop /.false./
X
XC
X         bfill = ' '
X         mxline=MAXBUF
X         if(line_.gt.0) mxline=min(line_,MAXBUF)
X         temp=string
X         temp2=temp
X         pflush=.false.
X         if(pchar.lt.0) pflush=.true.
XC
X         do 100 i=MAXBUF,1,-1
X         if(temp(i:i).eq.' ')              goto 100
X         if(ptabx_.and.temp(i:i).eq.tab)    goto 100
X         goto 110
X100      continue
X         i=0
X         it=i
XC
XC....... Organise the output of loop_ items
XC
X110      if(i.eq.0)             goto 130
X         if(i.eq.1.and.string.eq.tab) goto 130
X         if(i.eq.1.and.string.eq.char(0)) then
X           pcharl=MAXBUF
X           goto 200
X         endif           
X         if(temp(1:1).eq.'#')   goto 130
X         if(ploopf.eq.'yes')    goto 130
X         if(ptextf.eq.'yes')    goto 130
X         if(ploopn.le.0)        goto 130
X         ploopc=ploopc+1
X         if(align_.or.tabl_) then
X           if(ploopc.gt.ploopn) then
X             if(pcharl.gt.lprefx) pflush=.true.
X             ploopc=1
X             if(pchar.gt.0) pchar=lprefx+1
X           endif
X           if(pchar.lt.0)    goto 130
X           if(tabl_) then
X           kbin=(mxline-lprefx)/8
X           if(ploopn.lt.kbin) then
X             if(kbin/(ploopn+1).gt.1) then
X             pchar=9+lprefx+
X     *         (ploopc-1)*8*(kbin/(ploopn+1))
X             else
X             pchar=1+lprefx+
X     *         (ploopc-1)*8*(kbin/ploopn)
X             endif
X           else
X             if(ploopc.le.kbin) then
X               pchar=1+lprefx+(ploopc-1)*8
X             else
X               kpass=(ploopc-kbin-1)/(kbin-1)+1
X               pchar=2*kpass+1+lprefx+
X     *           mod(ploopc-kbin-1,kbin-1)*8
X             endif
X           endif
X           else
X             if(ptabx_) then
X             icpos=1
X             itpos=1
X120          ixpos=index(temp(icpos:i),tab)
X             ixtpos=(pchar+itpos-1+ixpos)
X             ixtpos=((ixtpos+7)/8)*8
X             if(ixpos.gt.0) then
X               if(ixpos.gt.1) then
X                 temp2(itpos:ixtpos-pchar+1)=temp(icpos:ixpos-1)
X               else
X                 temp2(itpos:ixtpos-pchar+1)=' '
X               endif
X               icpos=ixpos+1
X               itpos=ixtpos+2-pchar
X               if(icpos.le.i) goto 120
X               it=itpos-1
X             else
X               temp2(itpos:itpos+i-icpos)=temp(icpos:i)
X               it=itpos+i-icpos
X             endif
X             endif
X             if((pchar+i).gt.mxline+1.or.
X     *          (ptabx_.and.pchar+it.gt.mxline+1)) then
X               if(pcharl.gt.lprefx)pflush=.true.
X               pchar=lprefx+1
X             endif
X           endif
X         else
X           if(ploopc.le.ploopn)   goto 130
X           ploopc=1
X         endif
XC
XC....... Is the buffer full and needs flushing?
XC
X130      if(i.eq.1.and.string.eq.tab) then
X           if(pcharl.gt.lprefx) then
X             if(obuf(pcharl:pcharl).eq.' ') pcharl=pcharl-1
X           endif
X         endif
X         if(pchar.le.pcharl.and.pcharl.gt.lprefx) pflush=.true.
X         pchar=max(lprefx+1,pchar)
X         if((ploopf.eq.'yes'.or.ploopn.le.0).and.tabl_)
X     *     pchar=((pchar-lprefx+6)/8)*8+1+lprefx
X         if(ptabx_) then
X         icpos=1
X         itpos=1
X135      ixpos=index(temp(icpos:i),tab)
X         ixtpos=(pchar+itpos-1+ixpos)
X         ixtpos=((ixtpos+7)/8)*8
X         if(ixpos.gt.0) then
X           if(ixpos.gt.1) then
X             temp2(itpos:ixtpos-pchar+1)=temp(icpos:ixpos-1)
X           else
X             temp2(itpos:ixtpos-pchar+1)=' '
X           endif
X           icpos=ixpos+1
X           itpos=ixtpos+2-pchar
X           if(icpos.le.i) goto 135
X           it=itpos-1
X         else
X           temp2(itpos:itpos+i-icpos)=temp(icpos:i)
X           it=itpos+i-icpos
X         endif
X         endif
X         if((pchar+i).gt.mxline+1.or.
X     *     (ptabx_.and.pchar+it.gt.mxline+1)) then
X            pflush=.true.
X            pchar=mxline+1-i
X            pchar=max(lprefx+1,pchar)
X         endif
X         if(.not.pflush)  goto 150
X140      if(pcharl.gt.lprefx) then
X           if(waslop.or.(.not.tabl_)) goto 145
X           ioffst=0
X           pcharl=max(lastnb(obuf(1:pcharl)),lprefx+1)
X           ifree=mxline-pcharl
X           if(ifree.gt.0) then
X           im=numtab+2
X           if(numtab.gt.0.and.numtab.le.MAXTAB) then
X             if(obuf(itabp(numtab):itabp(numtab)).eq.'#')
X     *         im=im-1
X           endif
X           if(ifree.ge.16.and.im.lt.4.and.
X     *       (obuf(1+lprefx:1+lprefx).ne.'#'
X     *        .and.obuf(1+lprefx:1+lprefx).ne.';'
X     *        .and.obuf(1+lprefx:1+lprefx).ne.'_'
X     *        .and.obuf(1+lprefx:1+lprefx).ne.' '
X     *        .and.obuf(1+lprefx:5+lprefx).ne.'data_'
X     *        .and.obuf(1+lprefx:5+lprefx).ne.'save_'
X     *        .and.obuf(1+lprefx:5).ne.'loop_')) then
X             temp(1+lprefx:pcharl)=obuf(1+lprefx:pcharl)
X             obuf(1+lprefx:pcharl+8)=
X     *         bfill(1:8)//temp(1+lprefx:pcharl)
X             ioffst = 8
X             ifree=ifree-8
X             pcharl=pcharl+8
X           endif
X           do ii=1,min(MAXTAB,numtab)
X             icpos=itabp(ii)+ioffst
X             if(icpos.gt.pcharl)   goto 145
X             if(im.lt.4) then
X             itpos=(max(icpos-lprefx,
X     *         ii*(mxline-lprefx)/im)+6)/8
X             itpos=itpos*8+1+lprefx
X             else
X             itpos=(max(icpos-lprefx,
X     *         ii*(mxline-lprefx)/im)+4)/6
X             itpos=itpos*6+1+lprefx
X             endif
X             if((obuf(icpos:icpos).eq.''''.or.
X     *          obuf(icpos:icpos).eq.'"').and.
X     *          itpos.gt.icpos) itpos=itpos-1
X             if(itpos-icpos.gt.ifree) itpos=icpos+ifree
X             if(itpos.gt.icpos) then
X               temp(1:pcharl-icpos+1)=
X     *           obuf(icpos:pcharl)
X               if(i.lt.numtab) then
X                 ixpos=itabp(ii+1)+ioffst
X                 if(ixpos.gt.icpos+itpos-icpos+1) then
X                   if(obuf(ixpos-(itpos-icpos+1):ixpos-1).eq.
X     *               bfill(1:itpos-icpos+1)) then
X                     temp(ixpos-itpos+1:pcharl-itpos+1)=
X     *               obuf(ixpos:pcharl)
X                     pcharl=pcharl-(itpos-icpos)
X                   endif
X                 endif
X               endif
X               obuf(icpos:pcharl+itpos-icpos)=
X     *           bfill(1:itpos-icpos)//temp(1:pcharl-icpos+1)
X               ifree=ifree-(itpos-icpos)
X               ioffst=ioffst+itpos-icpos
X               pcharl=pcharl+itpos-icpos
X             endif
X             if(ifree.le.0)      goto 145
X           enddo
X           endif
X145        pcharl=max(1,lastnb(obuf))
X           write(outdev,'(a)') obuf(1:pcharl)
X         else
X           if(precn_.gt.0) then
X           if(lprefx.gt.0) then
X           write(outdev,'(a)') obuf(1:lprefx)
X           else
X           write(outdev,'(a)')
X           endif
X           else
X           precn_=precn_-1
X           endif
X         endif
X         waslop=.false.
X         precn_=precn_+1
X         do ii = 1,MAXTAB
X           itabp(ii)=0
X         enddo
X         numtab=0
X         if(lprefx.gt.0) then
X           obuf=prefx(1:lprefx)
X         else
X           obuf=' '
X         endif
XC
XC....... Load the next item into the buffer
XC
X150      pcharl=pchar+i
X         if(ptabx_) pcharl=pchar+it
X         waslop= ploopf.eq.'no '.and.ploopn.gt.0.and.align_
X         if(i.eq.0) then
X           if(pcharl.eq.lprefx+1.and.
X     *       obuf(lprefx+1:lprefx+1).eq.' ') pcharl=pcharl-1
X             pchar=pcharl+1
X           goto 200
X         endif
X         if(ptabx_) then
X           obuf(pchar:pcharl)=temp2(1:it)
X         else
X           if(string.eq.tab) pcharl=pcharl-1
X           obuf(pchar:pcharl)=string(1:i)
X         endif
X         if(pchar.gt.1+lprefx) then
X           numtab=numtab+1
X           if(numtab.le.MAXTAB) itabp(numtab)=pchar
X         endif
X         pchar=pcharl+1
X         if(pchar.gt.mxline+2) then
X           call warn(' Output CIF line longer than line_')
X         endif
XC
X200      return
X         end
XC
XC
XC
XC
XC
XC >>>>>> Convert the number and esd to string nnnn(m), limited
XC        by relative precision prec
XC
X         subroutine putnum(numb,sdev,prec)  
XC
X         include   'ciftbx.sys'
X         character  string*30,temp*30,c*1,sfmt*8
X         double precision numb,sdev,prec,xxnumb,xsdev,slog
X         integer    i,iexp,ifp,ii,jj,j,jlnz,jn,kexp,m,ixsdev,islog
X         integer    kdecp,ibexp
XC
X         kdecp=0
X         if (sdev.gt.abs(numb)*prec) then
X           if (esdlim_.ne.esdcac) then
XC
XC            determine the number of digits set by esdlim_
XC
X             if (esdlim_.lt.9 .or.esdlim_.gt.99999) then
X               call warn(' Invalid value of esdlim_ reset to 19')
X               esdlim_ = 19
X             endif
XC
XC            determine the number of esd digits
XC
X             esddig = 1.+alog10(float(esdlim_))
X             esdcac = esdlim_
X           endif
XC
XC          determine kexp, the power of 10 necessary
XC          to present sdev as an integer in the range
XC          (esdlim_/10,esdlim_]
XC
X           slog = dlog10(sdev)
X           islog = slog+1000.
X           islog = islog-1000
X           kexp = -islog+esddig
XC
XC          Adjust exponent kexp, so that sdev*10**kexp
XC          is in the interval (esdlim_/10,esdlim_]
XC
X 20        if (kexp.lt.minexp) then
X             call warn(' Underflow of esd')
X             ixsdev = 0
X             go to 30
X           endif
X           if (kexp.gt.-minexp) then
X             call warn(' Overflow of esd')
X             ixsdev = 99999
X             go to 30
X           endif
X           xsdev = sdev*10.D0**kexp
X           ixsdev = xsdev+.5
X           if (ixsdev.gt.esdlim_) then
X             kexp = kexp -1
X             go to 20
X           endif
X           if (ixsdev.lt.(esdlim_+5)/10) then
X             kexp = kexp+1
X             go to 20
X           endif
XC
XC          We need to present the number to the same scaling
XC          at first, but will adjust to avoid Ennn notation
XC          if possible
XC
X 30        xxnumb = dabs(numb)*10.d0**kexp+.5
X           if(xxnumb*prec .gt.1.D0) then
X             call warn(' ESD less than precision of machine')
X             ixsdev=0
X           endif
X           if(numb.lt.0.d0) xxnumb = -xxnumb
X           write(string,ndpfmt)xxnumb
XC
XC          Extract the power of 10
XC
X           iexp = 0
X           ibexp = 0
X           do ii = 0,4
X             i = 30-ii
X             c = string(i:i)
X             m = index('0123456789',c)
X             if (m.gt.0) then
X               iexp = iexp+(m-1)*10**(ii-ibexp)
X             else
X               if (c.eq.' ') then
X                 ibexp = ibexp+1
X               else
X               if (c.eq.'-') iexp=-iexp
X               goto 40
X               endif
X             endif
X           enddo
X           call err(' Internal error in putnum')
XC
XC          Scan the rest of the string shifting the
XC          decimal point to get an integer
XC
X40         ifp = 0
X           j=1
X           do ii = 1,i-1
X           c = string(ii:ii)
X           if (c.ne.' ')then
X             m=index('0123456789+-',c)
X             if(m.ne.0) then
X               temp(j:j)=c
X               if(j.gt.1.or.c.ne.'0')j=j+1
X               if(j.eq.3.and.temp(1:2).eq.'-0')j=j-1
X               if(ifp.ne.0)then
X                 iexp=iexp-1
X                 if(iexp.le.0) goto 50
X               endif
X             else
X               if(c.eq.'.') then
X                 ifp=1
X                 if(iexp.le.0) goto 50
X               endif
X             endif
X           endif
X           enddo
XC
XC          The string from 1 to j-1 has an integer
XC          If iexp < 0, we present a 0.  If iexp > 0
XC          we pad with zeros
XC
X50         if(j.eq.1.or.iexp.lt.0) then
X             temp(1:1)='0'
X             j=2
X             iexp = 0
X           endif
X           if (iexp.gt.0) then
X             do ii = 1,iexp
X             temp(j:j)='0'
X             j=j+1
X             enddo
X             iexp=0
X           endif
X           string=temp(1:j-1)
XC
XC          We have the number for which the presentation
XC          would be nnnnnE-kexp.  If kexp is gt 0, we can
XC          decrease it and introduce a decimal point
XC
X           jj=0
X           if(index('0123456789',temp(1:1)).eq.0) jj=1
X           if(kexp.gt.0.and.kexp.lt.j-jj+8) then
X             if(kexp.lt.j-1) then
X               string=temp(1:j-1-kexp)//'.'//
X     *         temp(j-kexp:j-1)
X               kexp = 0
X               j=j+1
X             else
X               if(jj.ne.0)string(1:1)=temp(1:1)
X               string(1+jj:1+jj)='.'
X               do ii=1,kexp-(j-1-jj)
X                 string(1+jj+ii:1+jj+ii)='0'
X               enddo
X               string(2+jj+(kexp-(j-1-jj)):30)=
X     *           temp(1+jj:j-1)
X               j=j+1+kexp-(j-1-jj)
X               kexp=0
X             endif
X           endif
X           kdecp=index(string(1:j-1),'.')
X           if(kdecp.eq.0) kdecp=j
X           if(kexp.ne.0) then
X             write(temp(1:5),'(i5)') -kexp
X             string(j:j)='E'
X             j=j+1
X             do ii=1,5
X               c=temp(ii:ii)
X               if(c.ne.' ') then
X                 string(j:j)=c
X                 j=j+1
X               endif
X             enddo
X           endif
XC
XC          if there is a standard deviation
XC          append it in parentheses
XC
X           if(ixsdev.ne.0) then
X             write(temp(1:5),'(i5)') ixsdev
X             string(j:j)='('
X             j=j+1
X             do ii=1,5
X               c=temp(ii:ii)
X               if(c.ne.' ') then
X                 string(j:j)=c
X                 j=j+1
X               endif
X             enddo
X             string(j:j)=')'
X             j=j+1
X           endif
X         else
XC
XC          There is no standard deviation, just write numb
XC          But limit to the digits implied by prec
XC
X           slog = dlog10(min(.1D0,max(prec,dpprc)))
X           islog = slog+1000.5
X           islog = islog-1000
X           kexp = -islog
X           write(sfmt,'(5h(D30.,i2,1h))') kexp
X           write(temp,sfmt)numb
XC
XC          Now have the number in the form 
XC          [sign][0].nnnnnnnnDeee
XC          which, while sufficient, is not neat
XC          we reformat for the case 0<=eee<=kexp
XC
XC
XC          Extract the power of 10
XC
X           iexp = 0
X           ibexp = 0
X           do ii = 0,4
X             i = 30-ii
X             c = temp(i:i)
X             m = index('0123456789',c)
X             if (m.gt.0) then
X               iexp = iexp+(m-1)*10**(ii-ibexp)
X             else
X               if (c.eq.' ') then
X                 ibexp = ibexp+1
X               else
X               if (c.eq.'-') iexp=-iexp
X               goto 140
X               endif
X             endif
X           enddo
X           call err(' Internal error in putnum')
XC
XC          Scan the rest of the string shifting the
XC          decimal point to get a number with exponent 0,
XC          if possible
XC
X140        ifp = 0
X           j=1
X           do ii = 1,i-1
X           jn=ii
X           c = temp(ii:ii)
X           if (c.ne.' ')then
X             m=index('0123456789+-',c)
X             if(m.ne.0) then
X               string(j:j)=c
X               if(j.gt.1.or.c.ne.'0')j=j+1
X               if(j.eq.3.and.string(1:2).eq.'-0')j=j-1
X               if(ifp.ne.0)then
X                 iexp=iexp-1
X                 if(iexp.le.0) goto 150
X               endif
X             else
X               if(c.eq.'.') then
X                 ifp = -1
X                 if(iexp.le.0) goto 150
X               endif
X             endif
X           endif
X           enddo
X150        string(j:j)='.'
X           ifp = j
X           j = j+1
X           jlnz = j-1
X155        do ii = jn+1,i-1
X             c = temp(ii:ii)
X             if (c.ne.' ')then
X               m=index('0123456789',c)
X               if(m.ne.0) then
X                 string(j:j)=c
X                 j=j+1
X                 if(m.ne.1)jlnz=j
X                 if(m.eq.1.and.ifp.ge.1.and.
X     *             pposdec_.ne.0.and.pposend_.ne.0) then
X                   if(j-1-ifp-min(iexp,0).le.pposend_-pposdec_)
X     *               jlnz=j
X                 endif
X               else
X                 goto 160
X               endif
X             endif
X           enddo
X160        j=jlnz
X           if(j.eq.1) then
X            string(1:1)='0'
X            j=2
X           endif
X           if(iexp.lt.0.and.iexp.gt.-7.and.ifp.lt.j-1.and.
X     *       ifp.ne.0.and.j-ifp-iexp.le.kexp) then
X             temp(1:ifp)=string(1:ifp)
X             do ii = 1,-iexp
X               temp(ifp+ii:ifp+ii) = '0'
X             enddo
X             temp(ifp-iexp+1:j-iexp-1) = string(ifp+1:j-1)
X             j = j-iexp
X             iexp=0
X             string(1:j-1) = temp(1:j-1)
X           endif
X           kdecp=index(string(1:j-1),'.')
X           if(kdecp.eq.0) kdecp=j
X           if(iexp.ne.0) then
X             write(temp(1:5),'(i5)')iexp
X             string(j:j)='E'
X             j=j+1
X             do ii=1,5
X               c=temp(ii:ii)
X               if(c.ne.' ') then
X                 string(j:j)=c
X                 j=j+1
X               endif
X             enddo
X           endif
X         endif
XC
X         if(j.lt.1) then
X           string(1:1)='0'
X           j=2
X         endif
X         if(kdecp.lt.1)kdecp=j
X         if(pposdec_.ne.0) then
X           pchar=lprefx+pposdec_-kdecp+1
X         else
X           if(pposval_.ne.0)pchar=lprefx+pposval_
X         endif
X         call putstr(string(1:j-1))
X         return
X         end
XC
XC
XC
XC
XC
XC >>>>>> Check dictionary for data name validation    
XC
X         subroutine dcheck(name,type,flag,tflag)
XC
X         include   'ciftbx.sys'
X         logical    flag,tflag
X         character  name*(*),temp*(NUMCHAR),
X     *              locase*(MAXBUF),type*4
XC
X         flag=.true.
X         tflag=.true.
X         temp=locase(name)
X         call hash_find(temp,
X     *     dicnam,dicchain,NUMDICT,ndict,dichash,NUMHASH,xdchk)
X         if(xdchk.eq.0) goto 150
X         if(tcheck.eq.'no ')          goto 200
X         if(type.eq.dictyp(xdchk))    goto 200
X         if(type.eq.'    ')           goto 200
X         if(dictyp(xdchk).eq.'text' .and. type.eq.'char') goto 200
X         tflag=.false.
X         goto 200
X150      flag=.false.
X200      continue
X         return
X         end
XC
XC
XC
XC
XC
XC >>>>>> End of text string
XC
X         subroutine eotext
XC
X         include   'ciftbx.sys'
XC
X         if(ptextf.ne.'yes') then
X           call warn(' Out-of-sequence call to end text block')
X           return
X         endif
X         ptextf='no '
X         pchar=-1
X         call putstr(';')
X         call putstr(char(0))
X         return
X         end
XC
XC
XC
XC
XC
XC >>>>>> End of loop detected; check integrity and tidy up pointers
XC
X         subroutine eoloop
XC
X         include   'ciftbx.sys'
X         integer   i
XC
X         if(ploopn.eq.0)          goto 200
X         if(ploopn.eq.-1) then
X           call putstr('_DUMMY')
X           ploopn=1
X           ploopc=0
X           call warn(
X     *       ' Missing: missing loop_ name set as _DUMMY')
X         endif
X         if(ploopn.eq.ploopc)     goto 200
X         do 150 i=ploopc+1,ploopn
X150      call putstr('DUMMY')
X         call warn(    
X     *         ' Missing: missing loop_ items set as DUMMY')
XC
X200      ploopc=0
X         ploopn=0
X         return
X         end
XC
XC
XC
XC
XC
XC
XC >>>>>> Set common default values
XC
X         block data
XC
X         include   'ciftbx.sys'
X         data cifdev     /1/
X         data outdev     /2/
X         data dirdev     /3/
X         data errdev     /6/
X         data loopct     /0/
X         data nhash      /0/
X         data ndict      /0/
X         data nname      /0/
X         data nbloc      /0/
X         data ploopn     /0/
X         data ploopc     /0/
X         data ploopf     /'no '/
X         data ptextf     /'no '/
X         data pfilef     /'no '/
X         data testfl     /'no '/
X         data vcheck     /'no '/
X         data tcheck     /'no '/
X         data align_     /.true./
X         data tabl_      /.true./
X         data tabx_      /.true./
X         data ptabx_     /.true./ 
X         data text_      /.false./
X         data loop_      /.false./
X         data ndcname    /0/
X         data ncname     /0/
X         data save_      /.false./
X         data saveo_     /.false./
X         data alias_     /.true./
X         data aliaso_    /.false./
X         data dchash     /NUMHASH*0/
X         data dichash    /NUMHASH*0/
X         data dhash      /NUMHASH*0/
X         data dcchain    /NUMDICT*0/
X         data aroot      /NUMDICT*0/
X         data cindex     /NUMBLOCK*0/
X         data line_      /80/
X         data lastch     /0/
X         data dictype_   /' '/
X         data dicname_   /' '/
X         data diccat_    /' '/
X         data tagname_   /' '/
X         data prefx      /' '/
X         data lprefx     /0/
X         data esdlim_    /19/
X         data esdcac     /19/
X         data esddig     /2/
X         data esdfmt     /'(e12.2)'/
X         data edpfmt     /'(d12.2)'/
X         data ndpfmt     /'(d30.14)'/
X         data decprc     /1.e-6/
X         data dpprc      /1.d-14/
X         data decmin     /1.e-37/
X         data dpmin      /1.d-307/
X         data minexp     /-307/
X         data itabp      /MAXTAB*0/
X         data jrect      /-1/
X         data numtab     /0/
X         data recn_      /0/
X         data precn_     /0/
X         data posnam_    /0/
X         data posval_    /0/
X         data posdec_    /0/
X         data posend_    /0/
X         data pposnam_   /0/
X         data pposval_   /0/
X         data pposdec_   /0/
X         data pposend_   /0/
X         data quote_     /' '/
X         data pquote_    /' '/
X         data ibkmrk     /MAXBOOK*-1,MAXBOOK*-1,
X     *                    MAXBOOK*-1,MAXBOOK*-1/
X
X         end
XC
XC
XC       change the following include to include 'clearfp_sun.f'
XC       for use on a SUN
XC
X        include 'clearfp.f'
END_OF_FILE
if test 125819 -ne `wc -c <'ciftbx.f'`; then
    echo shar: \"'ciftbx.f'\" unpacked with wrong size!
fi
# end of 'ciftbx.f'
fi
if test -f 'ciftbx.sys' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ciftbx.sys'\"
else
echo shar: Extracting \"'ciftbx.sys'\" \(12073 characters\)
sed "s/^X//" >'ciftbx.sys' <<'END_OF_FILE'
XC
XC
XC >>>>>> Common declararations 'ciftbx.sys'
XC               
XC        For inclusion in 'ciftbx.f'
XC
XC        Include all user common definitions, but not functions
X         include 'ciftbx.cmv'
XC
XC        Define parameters controlling the sizes of things
XC
X         integer NUMDICT,NUMHASH,NUMBLOCK,NUMLOOP,NUMITEM,NUMIP1,MAXTAB,
X     *     MAXBOOK
XC
XC                                 Number of entries in dictionary tables
X         PARAMETER (NUMDICT=2500)
XC                                 Number of hash table entries (a modest prime)
X         PARAMETER (NUMHASH=53)
XC                                 Number of entries in data block tables
X         PARAMETER (NUMBLOCK=500)
XC                                 Number of loops in a data block
X         PARAMETER (NUMLOOP=50)
XC                                 Number of items in a loop
X         PARAMETER (NUMITEM=50)
XC                                 Maximum number of tabs in output cif line
X         PARAMETER (MAXTAB=10)
XC                                 Maximum number of simultaneous bookmarks
X         PARAMETER (MAXBOOK=1000)
XC
XC                                 Derived value for loop arrays
X         PARAMETER (NUMIP1=NUMITEM+1)
XC
XC                                 Flag if test_ last called (yes/no )
X         character testfl*3
XC                                 Name of current data item
X         character nametb*(NUMCHAR)
XC                                 Tab character for this machine
X         character tab*1
XC                                 Character buffer for reading lines
X         character buffer*(MAXBUF)
XC                                 Character buffer for tab-expanded lines
X         character bufntb*(MAXBUF)
XC                                 Dictionary validation check
X         character vcheck*3
XC                                 Dictionary data type check
X         character tcheck*3
XC                                 Dictionary flag             
X         character dictfl*3
XC                                 Dictionary names
X         character dicnam(NUMDICT)*(NUMCHAR)
XC                                 Dictionary names with upper/lower case
X         character dictag(NUMDICT)*(NUMCHAR)
XC                                 Dictionary data types
X         character dictyp(NUMDICT)*4
XC                                 Data names in data block
X         character dname(NUMBLOCK)*(NUMCHAR)
XC                                 Data names in data block with u/l case
X         character dtag(NUMBLOCK)*(NUMCHAR)
XC                                 Data type of data item 
X         character dtype(NUMBLOCK)*4
XC                                 Flag signalling output CIF open
X         character pfilef*3
XC                                 Flag signalling loop_ being loaded
X         character ploopf*3
XC                                 Flag signalling text being loaded
X         character ptextf*3
XC                                 Output string buffer
X         character obuf*(MAXBUF)
XC                                 Output prefix string
X         character prefx*(MAXBUF)
XC                                 Dictionary category names
X         character dcname(NUMDICT)*(NUMCHAR)
XC                                 Category names in use
X         character cname(NUMBLOCK)*(NUMCHAR)
XC                                 Dictionary extended types
X         character dicxtyp(NUMDICT)*(NUMCHAR)
XC                                 Datablock extended types
X         character dxtyp(NUMBLOCK)*(NUMCHAR)
XC                                 Format for single precision esd's
X         character*13 esdfmt
XC                                 Format for double precision esd's
X         character*13 edpfmt
XC                                 Format for writing double precision numbers
X         character*8 ndpfmt       
XC                                 Record number containing data item
X         integer   drecd(NUMBLOCK)
XC                                 Character position of item in record
X         integer   dchar(NUMBLOCK)
XC                                 Record number containing tag of item
X         integer   trecd(NUMBLOCK)
XC                                 Character position of tag of item in record
X         integer   tchar(NUMBLOCK)
XC                                 Character position of tag of item in record
XC                                 tab-expanded
X         integer   xchar(NUMBLOCK)
XC                                 Loop block number (0 for non-loop)
X         integer   nloop(NUMBLOCK)
XC                                 Item count in loop packet
X         integer   iloop(NUMBLOCK)
XC                                 Loop line counter; initially zero
X         integer   lloop(NUMBLOCK)
XC                                 Number of items per packet in each loop
X         integer   loopni(NUMLOOP)
XC                                 Number of packets per loop    
X         integer   loopnp(NUMLOOP)
XC                                 Record number of loop header    
X         integer   loorec(NUMLOOP)
XC                                 Character position of loop header    
X         integer   loopos(NUMLOOP)
XC                                 Character position of loop header
XC                                 tab-expanded    
X         integer   loopox(NUMLOOP)
XC                                 Number of last non-blank chars in input 
X         integer   lastch
XC                                 Number of items in current loop packet
X         integer   ploopc
XC                                 Number of items in output loop packet
X         integer   ploopn
XC                                 Number of current loop block
X         integer   loopnl
XC                                 Count of packets in current loop
X         integer   loopct
XC                                 Number of data names in hash table 
X         integer   nhash 
XC                                 Number of data names in data block
X         integer   nname
XC                                 Current number of data name in block
X         integer   iname
XC                                 Number of dictionary names
X         integer   ndict 
XC                                 Number of records in CIF
X         integer   nrecd
XC                                 Record number of requested line
X         integer   irecd
XC                                 Record number of current line
X         integer   jrecd
XC                                 Record number of tab-expanded line
X         integer   jrect
XC                                 Last record number of current block
X         integer   lrecd
XC                                 Character pointer of current input line
X         integer   jchar
XC                                 Character pointer of output CIF line
XC                                 next location to store
X         integer   pchar
XC                                 Character pointer of output CIF line
XC                                 last location stored
X         integer   pcharl
XC                                 Number of data block names stored
X         integer   nbloc
XC                                 Device number of input CIF 
X         integer   cifdev
XC                                 Device number of direct access file
X         integer   dirdev
XC                                 Device number of error message file
X         integer   errdev
XC                                 Device number of output CIF
X         integer   outdev
XC                                 Cached copy of esdlim_
X         integer   esdcac
XC                                 Cached esd digits
X         integer   esddig
XC                                 Number of Dictionary Category names stored
X         integer   ndcname
XC                                 Bookmark data
X         integer   ibkmrk(4,MAXBOOK)
XC                                 Indices of Dictionary Category 
XC                                 names for items
X         integer   dcindex(NUMDICT)
XC                                 Hash Table for Dic. Category names
X         integer   dchash(NUMHASH)
XC                                 Chain pointers for hash searches
XC                                 of Dictionary Category names
X         integer   dcchain(NUMDICT)
XC                                 Hash table for Dictionary name
X         integer   dichash(NUMHASH)
XC                                 Chain pointers for hash search of
XC                                 Dictionary names
X         integer   dicchain(NUMDICT)
XC                                 Block hash table
X         integer   dhash(NUMHASH)
XC                                 Category hash table
X         integer   chash(NUMHASH)
XC                                 Chain pointers for hash search of
XC                                 block names
X         integer   dchain(NUMBLOCK)
XC                                 Chain pointers for hash search of
XC                                 categories
X         integer   cchain(NUMBLOCK)
XC                                 Number of Category names stored
X         integer   ncname
XC                                 Character starting position of loop items
X         integer   loopch(NUMIP1)
XC                                 String length of loop items
X         integer   loopln(NUMIP1)
XC                                 Record number of loop items
X         integer   looprd(NUMIP1)
XC                                 Indices of Category 
XC                                 names for items
X         integer   cindex(NUMBLOCK)
XC                                 Dictionary pointer from data block
X         integer   ddict(NUMBLOCK)
XC                                 Alias links, 0 for no alias or index
XC                                 of item name in dicnam which
XC                                 is the root of its definitions
X         integer   aroot(NUMDICT)
XC                                 Alias links, 0 for no next alias or
XC                                 index of next alias in dicnam
X         integer   alias(NUMDICT)
XC                                 dcheck result from dicnam
X         integer   xdchk
XC                                 minimum exponent for DP calculations
X         integer   minexp
XC                                 length of output prefix string
X         integer   lprefx
XC                                 Potential tabs in output line
X         integer   itabp(MAXTAB)
XC                                 Count of potential tabs
X         integer   numtab
XC                                 Returned number
X         double precision numbtb
XC                                 Returned standard deviation
X         double precision sdevtb
XC                                 Decimal double precision precision
X         double precision dpprc
XC                                 Decimal double precision minimum power of 10
X         double precision dpmin
XC                                 Decimal single precision precision
X         real      decprc
XC                                 Decimal single precision minimum power of 10
X         real      decmin
XC                                 Internal save of saveo_
X         logical   psaveo
XC
X         common/tbxc/ buffer,dname,dtype,tab,dicnam,dictag,dictyp,
X     *                dictfl,dtag,nametb,testfl,vcheck,tcheck,pfilef,
X     *                ploopf,ptextf,dcname,cname,dicxtyp,dxtyp,esdfmt,
X     *                edpfmt,ndpfmt,prefx,obuf,bufntb
XC
X         common/tbxi/ nrecd,drecd,trecd,irecd,lrecd,dchar,tchar,xchar,
X     *                ndict,outdev,nloop,iloop,lloop,loopct,loopni,
X     *                loopnp,loopnl,nname,nhash,cifdev,dirdev,errdev,
X     *                jchar,pchar,iname,ploopn,ploopc,nbloc,jrecd,
X     *                lastch,esdcac,esddig,ndcname,dcindex,ncname,
X     *                cindex,aroot,alias,dchash,dcchain,dichash,
X     *                dicchain,dhash,dchain,ddict,xdchk,loopch,loopln,
X     *                looprd,minexp,lprefx,itabp,numtab,pcharl,loopos,
X     *                loopox,loorec,jrect,ibkmrk,chash,cchain
X
XC
X         common/tbxdp/numbtb,sdevtb,dpprc,dpmin
XC
X         common/tbxr/ decprc,decmin
XC
X         common/tbxl/ psaveo
XC
END_OF_FILE
if test 12073 -ne `wc -c <'ciftbx.sys'`; then
    echo shar: \"'ciftbx.sys'\" unpacked with wrong size!
fi
# end of 'ciftbx.sys'
fi
if test -f 'clearfp.f' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'clearfp.f'\"
else
echo shar: Extracting \"'clearfp.f'\" \(383 characters\)
sed "s/^X//" >'clearfp.f' <<'END_OF_FILE'
X      subroutine clearfp
XC
XC     This is a null version of a
XC     subroutine to clear IEEE floating point exceptions
XC     for inexact and underflow under SUN OS 4 f77
XC     For most other systems, no action is needed.
XC
XC     character*1 out
XC     ii = ieee_flags('clear','exception','underflow',out)
XC     ii = ieee_flags('clear','execption','inexact',out)
X      return
X      end
END_OF_FILE
if test 383 -ne `wc -c <'clearfp.f'`; then
    echo shar: \"'clearfp.f'\" unpacked with wrong size!
fi
# end of 'clearfp.f'
fi
if test -f 'clearfp_sun.f' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'clearfp_sun.f'\"
else
echo shar: Extracting \"'clearfp_sun.f'\" \(298 characters\)
sed "s/^X//" >'clearfp_sun.f' <<'END_OF_FILE'
X      subroutine clearfp
XC
XC     subroutine to clear IEEE floating point exceptions
XC     for inexact and underflow under SUN OS 4 f77
XC
X      character*1 out
X      ii = ieee_flags('clear','exception','underflow',out)
X      ii = ieee_flags('clear','execption','inexact',out)
X      return
X      end
END_OF_FILE
if test 298 -ne `wc -c <'clearfp_sun.f'`; then
    echo shar: \"'clearfp_sun.f'\" unpacked with wrong size!
fi
# end of 'clearfp_sun.f'
fi
if test -f 'cryst1-2-cif.awk' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cryst1-2-cif.awk'\"
else
echo shar: Extracting \"'cryst1-2-cif.awk'\" \(1788 characters\)
sed "s/^X//" >'cryst1-2-cif.awk' <<'END_OF_FILE'
X#
X#  cryst1-2-cif.awk
X#
X#  simple awk script to convert a file with PDB CRYST1 records
X#  to a CIF for input to iterate.  Extracted from pdb2cif
X#  by Bourne, Bernstein and Bernstein.  See
X#     http://ndbserver.rutgers.edu/software/pdb2cif
X#
X#  Warning -- this script assumes the entry id is in columns 73-76
X#  If this is not true, then you make get a blank entry_id
X#
XBEGIN {
X  printf ("\n data_cells\n\n loop_\n")
X  printf ("_cell.entry_id\n")
X  printf ("_cell.length_a\n")
X  printf ("_cell.length_b\n")
X  printf ("_cell.length_c\n")
X  printf ("_cell.angle_alpha\n")
X  printf ("_cell.angle_beta\n")
X  printf ("_cell.angle_gamma\n")
X  printf ("_cell.volume\n")
X  printf ("_cell.Z_PDB\n")
X  printf ("_cell.space_group_name_H-M  # not defined in dictionary\n\n\n")
X}
X#==========================================================================
X#  keyword CRYST1
X#
X#
X{
X  if ($1 == "CRYST1") {
X  #
X  #  Contains a b c alpha beta gamma SG Z
X  #
X
X  # calculate cell volume
X
X  {
X    ca = cos(substr( ($0),34, 7) * 0.0174532)
X    cb = cos(substr( ($0),41, 7) * 0.0174532)
X    cc = cos(substr( ($0),48, 7) * 0.0174532)
X    cz = (1.0 - (ca*ca - cb*cb - cc*cc) + (2.0*ca*cb*cc))
X    vol = (substr( ($0), 7, 9) *\
X           substr( ($0),16, 9) *\
X           substr( ($0),25, 9) * (sqrt(cz)))
X  }
X  # localize space group and Z
X
X  {
X    sg = substr( ($0), 56, 11)
X    Z  = substr( ($0), 67, 4 )
X  }
X  if (vol-1 > .01) {
X  printf (" %s",substr( ($0), 73, 4))
X  printf (" %9.3f", substr( ($0), 7, 9))
X  printf (" %9.3f", substr( ($0),16, 9))
X  printf (" %9.3f", substr( ($0),25, 9))
X  printf (" %7.2f", substr( ($0),34, 7))
X  printf (" %7.2f", substr( ($0),41, 7))
X  printf (" %7.2f\n", substr( ($0),48, 7))
X  printf (" %10.1f", vol)
X  printf (" %3d ", Z)
X  printf (" '%11s'\n", sg)
X  }
X  }
X}
XEND {}
END_OF_FILE
if test 1788 -ne `wc -c <'cryst1-2-cif.awk'`; then
    echo shar: \"'cryst1-2-cif.awk'\" unpacked with wrong size!
fi
# end of 'cryst1-2-cif.awk'
fi
if test -f 'hash_funcs.f' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hash_funcs.f'\"
else
echo shar: Extracting \"'hash_funcs.f'\" \(7064 characters\)
sed "s/^X//" >'hash_funcs.f' <<'END_OF_FILE'
XC
XC       hash_funcs.f -- a library of hash table management routines
XC
XC                                      by
XC
XC                              Herbert J. Bernstein
XC                                Bernstein + Sons
XC                    P.O. Box 177, Bellport, NY 11713-0177, USA
XC                             Phone/Fax 1-516-286-1999
XC                               email: yaya@aip.org
XC
XC       work on these routines done in part at Brookhaven National
XC       Laboratory, under contract to the U.S. Department of Energy
XC
XC-------------------------------------------------------------------------------
XC
XC       Routines
XC
XC       hash_init          Initializes a hash table controlled list
XC                          call hash_init(data_structure_args)
XC
XC       hash_find          Searches for a string in a list
XC                          call hash_find(name,data_structure_args,ifind)
XC
XC       hash_store         Inserts as new string in a list
XC                          call hash_store(name,data_structure_args,ifind)
XC
XC       hash_value         Integer function returns index into hash_list
XC                          ih = hash_value(name,hash_length)
XC
XC       The necessary data_structure_args for these routines are
XC          name_list   -- an array of character strings
XC                         character*(*) name_list(list_length)
XC          chain_list  -- chain pointers for searches
XC                         integer chain_list(list_length)
XC          list_length -- the size of the list arrays
XC                         integer list_length
XC          num_list    -- number of entries in the list
XC                         integer num_list
XC          hash_table  -- the initial hashed pointers
XC                         integer hash_table
XC          hash_length -- the size of the hash table
XC                         integer hash_length
XC
XC
XC       The two remaining arguments are
XC          name        -- string to search for
XC                         character*(*) name
XC          ifind       -- return value, 0 for not found (hash_find)
XC                         or list full (hash_store), otherwise
XC                         the index in name_list of the entry
XC
XC       The relationship among the arrays used is:
XC
XC       hash_table is an array (preferably of a modest prime
XC       dimension) which starts containing all zeros, which are
XC       replaced by pointers to entries in name_list, based
XC       values returned by hash_value ranging from 1 to hash_length.
XC       Each name is placed in name_list.  A initial zero is placed
XC       in the matching entry in chain_list, when the first entry
XC       is made.  When a new entry with the same hash_value must be
XC       placed a pointer is inserted into chain_list to hook the
XC       values together.
XC
X        subroutine hash_init(name_list,chain_list,list_length,num_list,
X     *                       hash_table,hash_length)
XC
XC       initialization routine for a hash table controlled list
XC          name_list   -- a list of character strings
XC          chain_list  -- chain pointers for searches
XC          list_length -- the size of the list arrays
XC          num_list    -- number of entries in the list
XC          hash_table  -- the initial hashed pointers
XC          hash_length -- the size of the hash table
XC
X           character*(*) name_list(list_length)
X           integer hash_length,list_length,num_list,i
X           integer chain_list(list_length)
X           integer hash_table(hash_length)
X           num_list=0
X           do i = 1,hash_length
X           hash_table(i)=0
X           enddo
X           return
X           end          
X        subroutine
X     *  hash_find(name,name_list,chain_list,list_length,num_list,
X     *                       hash_table,hash_length,ifind)
XC
XC       search routine for a hash table controlled list
XC          name        -- string to find
XC          name_list   -- a list of character strings
XC          chain_list  -- chain pointers for searches
XC          list_length -- the size of the list arrays
XC          num_list    -- number of entries in the list
XC          hash_table  -- the initial hashed pointers
XC          hash_length -- the size of the hash table
XC          ifind       -- returned index or 0
XC
X           character*(*) name
X           integer hash_length
X           character*(*) name_list(list_length)
X           integer chain_list(list_length)
X           integer hash_table(hash_length)
X           integer hash_value
X           integer ifind,list_length,num_list,ih,ip
X           ifind=0
X           ih=hash_value(name,hash_length)
X           ip=hash_table(ih)
X 100       if (ip.eq.0) return
X           if (name_list(ip).eq.name) then
X             ifind=ip
X             return
X           else
X             ip=chain_list(ip)
X             go to 100
X           endif
X           end
X        subroutine
X     *  hash_store(name,name_list,chain_list,list_length,num_list,
X     *                       hash_table,hash_length,ifind)
XC
XC       store routine for a hash table controlled list
XC          name        -- string to find
XC          name_list   -- a list of character strings
XC          chain_list  -- chain pointers for searches
XC          list_length -- the size of the list arrays
XC          num_list    -- number of entries in list
XC          hash_table  -- the initial hashed pointers
XC          hash_length -- the size of the hash table
XC          ifind       -- index of entry or 0 (table full)
XC
X           character*(*) name
X           character*(*) name_list(list_length)
X           integer hash_length
X           integer chain_list(list_length)
X           integer hash_table(hash_length)
X           integer hash_value
X           integer ifind,list_length,num_list,ih,ip,iq
X           ifind=0
X           ih = hash_value(name,hash_length)
X           ip=hash_table(ih)
X           iq=0
X 100       if (ip.eq.0) go to 200
X           if (name_list(ip).eq.name) then
X             ifind=ip
X             return
X           else
X             iq=ip
X             ip=chain_list(ip)
X             go to 100
X           endif
X 200       if (num_list.lt.list_length) then
X             num_list=num_list+1
X             name_list(num_list)=name
X             chain_list(num_list)=0
X             if (iq.eq.0) then
X               hash_table(ih)=num_list
X             else
X               chain_list(iq)=num_list
X             endif
X             ifind=num_list
X             return
X           else
X             ifind = 0
X             return
X           endif
X           end
X      integer function hash_value(name,hash_length)
XC
XC     function to return a hash value of string name to fit
XC     a hash table of length hash_length
X      character*(*) name
X      integer hash_length,id,ii,i,ic,lenn
X      lenn = len(name)
X      hash_value=1
X      id = 0
X      do ii = 1,lenn
X        i = 1+lenn-ii
X        ic = ichar(name(i:i))
X        if (ic.ge.65) then
X          hash_value=mod(hash_value*(ic-64),hash_length)+1
X          id = id+1
X          if (id.gt.3) return
X        endif
X      enddo
X      return
X      end
X        
END_OF_FILE
if test 7064 -ne `wc -c <'hash_funcs.f'`; then
    echo shar: \"'hash_funcs.f'\" unpacked with wrong size!
fi
# end of 'hash_funcs.f'
fi
if test -f 'iterate.csh.m4' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'iterate.csh.m4'\"
else
echo shar: Extracting \"'iterate.csh.m4'\" \(1292 characters\)
sed "s/^X//" >'iterate.csh.m4' <<'END_OF_FILE'
X#!/bin/csh
X# iterate.csh
X#
X# Herbert J. Bernstein, Bernstein + Sons
X# Lawrence C. Andrews, Thuridion, Inc.
X#
X# 29 September 1996
X#
X# This is a service script for the iterate.html web page
X# It must be placed in an appropriate cgi-bin directory on
X# the server pointed to by iterate.html
X#
X#
X# To operate correctly, the programs tr and sed must be in the
X# default path and the /bin/echo version of echo must follow
X# system V conventions sufficiently to produce an empty line
X# call, below
X#
X/bin/echo "Content-type: text/html"
X/bin/echo 
Xecho "<HEAD>"
Xecho "<TITLE>G6 Lattice Identification"
Xecho "</TITLE>"
Xecho "</HEAD>"
Xecho "<BODY>"
Xtr '\&' '\n'  |sed "s/^./set &/"  > /tmp/outstr$$
X#cat /tmp/outstr$$
Xsource /tmp/outstr$$
Xrm /tmp/outstr$$
Xecho "<H3># G6 Lattice Identification</H3>"
Xecho $Centering > /tmp/instr$$
Xecho "<P>#  Centering: " $Centering 
Xecho $A $B $C $Alpha $Beta $Gamma >>/tmp/instr$$
Xecho "<P># Cell: " $A $B $C $Alpha $Beta $Gamma
Xecho $sigA $sigB $sigC $sigAlpha $sigBeta $sigGamma >>/tmp/instr$$
Xecho "<P># Sigmas: " $sigA $sigB $sigC $sigAlpha $sigBeta $sigGamma
Xecho "<P><H3># Results of ITERATE Run</H3>"
Xsetenv ITERATE_QUERY NO
Xsetenv OUTPUT_STYLE $OutputStyle
Xecho "<PRE>"
XBINPATH() < /tmp/instr$$
Xrm /tmp/instr$$
X#cat /tmp/instr$$ 
Xecho "</PRE>"
Xecho "</BODY>"
END_OF_FILE
if test 1292 -ne `wc -c <'iterate.csh.m4'`; then
    echo shar: \"'iterate.csh.m4'\" unpacked with wrong size!
fi
chmod +x 'iterate.csh.m4'
# end of 'iterate.csh.m4'
fi
if test -f 'iterate.f' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'iterate.f'\"
else
echo shar: Extracting \"'iterate.f'\" \(101777 characters\)
sed "s/^X//" >'iterate.f' <<'END_OF_FILE'
XC     ITERATE -- Program for G6 Bravais Lattice Determination
XC
XC     by
XC
XC     Lawrence C. Andrews, Thuridion, Inc.,
XC     andrews@thuridion.com
XC 
XC     and
XC
XC     Herbert J. Bernstein, Bernstein+Sons,
XC     yaya@bernstein-plus-sons.com
XC
XC     This program finds the cells which are "close" to the cell given, 
XC     in order to help find the Bravais lattice of highest symmetry 
XC     consistent with the cell.
XC     
XC     A central problem in the solution of every crystal structure
XC     is to determine the correct Bravais lattice of the crystal.
XC     The Bravais lattices as they are usually listed are:
XC
XC     aP   triclinic (anorthic) primitive 
XC     mP   monoclinic primitive 
XC     mS   monoclinic side-centered (usually C-centered)
XC     oP   orthorhombic primitive 
XC     oS   orthorhombic side-centered 
XC     oF   orthorhombic face-centered 
XC     oI   orthorhombic body-centered 
XC     hP   hexagonal primitive 
XC     hR   hexagonal rhombohedrally-centered 
XC     tP   tetragonal primitive 
XC     tI   tetragonal body-centered 
XC     cP   cubic primitive 
XC     cF   cubic face-centered 
XC     cI   cubic body-centered 
XC     
XC     
XC     Failure to find the highest correct symmetry has several consequences, 
XC     the worst of which is that the structure may not be solved. The 
XC     least of the consequences is that Richard Marsh may publish a paper 
XC     that points out the error, corrects it, and finds a better solution 
XC     to the structure. Many methods have been described for finding the 
XC     correct Bravais lattice. A summary of the published methods was 
XC     published in the paper that described the G6 formalism (which is used
XC     in this program).
XC     
XC     "Lattices and Reduced Cells as Points in 6-Space and Selection of 
XC     Bravais Lattice Type by Projections", Lawrence C. Andrews and 
XC     Herbert J. Bernstein, Acta Crystallographica, A44, 1009-1018 (1988).
XC
XC     This program accepts cell parameters and esd's and produces a list
XC     of cells "close" to the cell given
XC
XC**********************************************************************C
X      SUBROUTINE BADCAL (A,B)
X      CHARACTER *6 A,B
XC----------------------------------------------------------------------C
X      include 'ITERATE.cmn'
X      WRITE (*,*)  ' '//hm//' BAD SUBROUTINE CALL TO ',B
X      WRITE (*,*)  ' '//hm//' CALLING NAME =',A
X      STOP
X      END
X
X
XCC***********************************************************************
XC      SUBROUTINE CPYVN (N,V1,V2)
XC      REAL V1(N),V2(N)
XC
XC-----------------------------------------------------------------------
XC      DO 1000 I=1,N
XC 1000 V2(I) = V1(I)
XC      END
X
XC***********************************************************************
X      subroutine bldprj (maxprj,nproj,itdesg,chrlat,pjn,prj,test)
X
XC This function builds the projectors of Paciorek and Bonin, J. Appl.
XC Cryst., 25, (5) pp 632-637. Internal checks of the correctness of
XC the projectors are made before it exits.
XC
XC The output values are just transferred from the stored parameters
XC in data statements. Note that if ngtype is negative, then the
XC projector is not output. This is because those are ones that
XC are easy to find later by searching. Either they are cases where
XC two projectors are exactly the same subspace (and therefore the
XC same projector) or else they are just simple exchange of axes
XC (which are dealt with in mkrefl in program iterate). If the routine
XC is extracted for other uses, then it may be correct to set the
XC values all positive.
X
XC   maxprj sets the maximum number of projectors to build
XC   nproj  is the actual number that bldprj constructs
XC   itdesg is the numeric designation of the Niggli type in the
XC          International Tables for Crystallography
XC   chrlat is the returned 2 character designators for the lattice
XC          type (also call Pearson symbols)
XC   pjn    is the normalizer of the projector -- the integer values
XC          stored in the returned matrix need to be divided by the
XC          normalizer to make the actual projector
XC   prj    the integer part of the projector -- divide by the normalizer
XC          (pjn) to get the actual projector
X
X
X      include 'ITERATE.cmn'
X      real pjn(maxprj)
X      real prj(36,MAXPRJ)
X      integer itdesg(maxprj)
X      character *2 chrlat(maxprj)
X      integer ngtype(42)
X      real projct(36,42)
X      real zprj(6,6,42)
X      equivalence (projct,zprj)
X      real pjnorm(42)
X      character *2 lattyp(42)
X      character *6 test
X
X      data ngtype(1) /3/
X      data lattyp(1) /'cP'/
X      data pjnorm(1) /3./
X      data( projct(i,1),i=1,36) /
X     1  1,1,1,0,0,0,
X     2  1,1,1,0,0,0,
X     3  1,1,1,0,0,0,
X     4  0,0,0,0,0,0,
X     5  0,0,0,0,0,0,
X     6  0,0,0,0,0,0 /
X
X
X      data ngtype(2) /5/
X      data lattyp(2) /'cI'/
X      data pjnorm(2) /39./
X      data (projct(i,2),i=1,36) /
X     1   9, 9, 9,-6,-6,-6,
X     2   9, 9, 9,-6,-6,-6,
X     3   9, 9, 9,-6,-6,-6,
X     4  -6,-6,-6, 4, 4, 4,
X     5  -6,-6,-6, 4, 4, 4,
X     6  -6,-6,-6, 4, 4, 4 /
X
X
X      data ngtype(3) /1/
X      data lattyp(3) /'cF'/
X      data pjnorm(3) /6./
X      data (projct(i,3),i=1,36) /
X     1  1,1,1,1,1,1,
X     2  1,1,1,1,1,1,
X     3  1,1,1,1,1,1,
X     4  1,1,1,1,1,1,
X     5  1,1,1,1,1,1,
X     6  1,1,1,1,1,1 /
X
X
X
X      data ngtype(4) /11/
X      data lattyp(4) /'tP'/
X      data pjnorm(4) /2./
X      data (projct(i,4),i=1,36) /
X     1  1,1,0,0,0,0,
X     2  1,1,0,0,0,0,
X     3  0,0,2,0,0,0,
X     4  0,0,0,0,0,0,
X     5  0,0,0,0,0,0,
X     6  0,0,0,0,0,0 /
X
X
X      data ngtype(5) /-21/
X      data lattyp(5) /'tP'/
X      data pjnorm(5) /2./
X      data (projct(i,5),i=1,36) /
X     1  2,0,0,0,0,0,
X     2  0,1,1,0,0,0,
X     3  0,1,1,0,0,0,
X     4  0,0,0,0,0,0,
X     5  0,0,0,0,0,0,
X     6  0,0,0,0,0,0 /
X
X
X      data ngtype(6) /15/
X      data lattyp(6) /'tI'/
X      data pjnorm(6) /4./
X      data (projct(i,6),i=1,36) /
X     1  1, 1, 0,-1,-1, 0,
X     2  1, 1, 0,-1,-1, 0,
X     3  0, 0, 4, 0, 0, 0,
X     4 -1,-1, 0, 1, 1, 0,
X     5 -1,-1, 0, 1, 1, 0,
X     6  0, 0, 0, 0, 0, 0 /
X
X
X      data ngtype(7) /6/
X      data lattyp(7) /'tI'/
X      data pjnorm(7) /26./
X      data (projct(i,7),i=1,36) /
X     1  6, 6, 6,-4,-4,-4,
X     2  6, 6, 6,-4,-4,-4,
X     3  6, 6, 6,-4,-4,-4,
X     4 -4,-4,-4, 7, 7,-6,
X     5 -4,-4,-4, 7, 7,-6,
X     6 -4,-4,-4,-6,-6,20 /
X
X
X      data ngtype(8) /-7/
X      data lattyp(8) /'tI'/
X      data pjnorm(8) /26./
X      data (projct(i,8),i=1,36) /
X     1  6, 6, 6,-4,-4,-4,
X     2  6, 6, 6,-4,-4,-4,
X     3  6, 6, 6,-4,-4,-4,
X     4 -4,-4,-4,20,-6,-6,
X     5 -4,-4,-4,-6, 7, 7,
X     6 -4,-4,-4,-6, 7, 7 /
X
X
X      data ngtype(9) /18/
X      data lattyp(9) /'tI'/
X      data pjnorm(9) /26./
X      data (projct(i,9),i=1,36) /
X     1  8, 0, 0, 4, 8, 8,
X     2  0,13,13, 0, 0, 0,
X     3  0,13,13, 0, 0, 0,
X     4  4, 0, 0, 2, 4, 4,
X     5  8, 0, 0, 4, 8, 8,
X     6  8, 0, 0, 4, 8, 8 /
X
X
X      data ngtype(10) /12/
X      data lattyp(10) /'hP'/
X      data pjnorm(10) /3./
X      data (projct(i,10),i=1,36) /
X     1  1, 1, 0, 0, 0,-1,
X     2  1, 1, 0, 0, 0,-1,
X     3  0, 0, 3, 0, 0, 0,
X     4  0, 0, 0, 0, 0, 0,
X     5  0, 0, 0, 0, 0, 0,
X     6 -1,-1, 0, 0, 0, 1 /
X
X
X      data ngtype(11) /-22/
X      data lattyp(11) /'hP'/
X      data pjnorm(11) /3./
X      data (projct(i,11),i=1,36) /
X     1  3, 0, 0, 0, 0, 0,
X     2  0, 1, 1,-1, 0, 0,
X     3  0, 1, 1,-1, 0, 0,
X     4  0,-1,-1, 1, 0, 0,
X     5  0, 0, 0, 0, 0, 0,
X     6  0, 0, 0, 0, 0, 0 /
X
X
X      data ngtype(12) /9/
X      data lattyp(12) /'hR'/
X      data pjnorm(12) /5./
X      data (projct(i,12),i=1,36) /
X     1  1,1,0,1,1,1,
X     2  1,1,0,1,1,1,
X     3  0,0,5,0,0,0,
X     4  1,1,0,1,1,1,
X     5  1,1,0,1,1,1,
X     6  1,1,0,1,1,1  /
X
X
X      data ngtype(13) /2/
X      data lattyp(13) /'hR'/
X      data pjnorm(13) /3./
X      data (projct(i,13),i=1,36) /
X     1  1,1,1,0,0,0,
X     2  1,1,1,0,0,0,
X     3  1,1,1,0,0,0,
X     4  0,0,0,1,1,1,
X     5  0,0,0,1,1,1,
X     6  0,0,0,1,1,1 /
X
X
X      data ngtype(14) /-4/
X      data lattyp(14) /'hR'/
X      data pjnorm(14) /3./
X      data (projct(i,14),i=1,36) /
X     1  1,1,1,0,0,0,
X     2  1,1,1,0,0,0,
X     3  1,1,1,0,0,0,
X     4  0,0,0,1,1,1,
X     5  0,0,0,1,1,1,
X     6  0,0,0,1,1,1 /
X
X
X      data ngtype(15) /24/
X      data lattyp(15) /'hR'/
X      data pjnorm(15) /53./
X      data (projct(i,15),i=1,36) /
X     1  27,  3,  3,  6,-18,-18,
X     2   3, 18, 18,-17, -2, -2,
X     3   3, 18, 18,-17, -2, -2,
X     4   6,-17,-17, 19, -4, -4,
X     5 -18, -2, -2, -4, 12, 12,
X     6 -18, -2, -2, -4, 12, 12 /
X
X
X      data ngtype(16) /32/
X      data lattyp(16) /'oP'/
X      data pjnorm(16) /1./
X      data (projct(i,16),i=1,36) /
X     1  1,0,0,0,0,0,
X     2  0,1,0,0,0,0,
X     3  0,0,1,0,0,0,
X     4  0,0,0,0,0,0,
X     5  0,0,0,0,0,0,
X     6  0,0,0,0,0,0 /
X
X
X      data ngtype(17) /36/
X      data lattyp(17) /'oS'/
X      data pjnorm(17) /2./
X      data (projct(i,17),i=1,36) /
X     1  1, 0, 0, 0,-1, 0,
X     2  0, 2, 0, 0, 0, 0,
X     3  0, 0, 2, 0, 0, 0,
X     4  0, 0, 0, 0, 0, 0,
X     5 -1, 0, 0, 0, 1, 0,
X     6  0, 0, 0, 0, 0, 0 /
X
X
X      data ngtype(18) /-38/
X      data lattyp(18) /'oS'/
X      data pjnorm(18) /2./
X      data (projct(i,18),i=1,36) /
X     1  1, 0, 0, 0, 0,-1,
X     2  0, 2, 0, 0, 0, 0,
X     3  0, 0, 2, 0, 0, 0,
X     4  0, 0, 0, 0, 0, 0,
X     5  0, 0, 0, 0, 0, 0,
X     6 -1, 0, 0, 0, 0, 1 /
X
X
X      data ngtype(19) /13/
X      data lattyp(19) /'oS'/
X      data pjnorm(19) /2./
X      data (projct(i,19),i=1,36) /
X     1  1,1,0,0,0,0,
X     2  1,1,0,0,0,0,
X     3  0,0,2,0,0,0,
X     4  0,0,0,0,0,0,
X     5  0,0,0,0,0,0,
X     6  0,0,0,0,0,2 /
X
X
X      data ngtype(20) /-23/
X      data lattyp(20) /'oS'/
X      data pjnorm(20) /2./
X      data (projct(i,20),i=1,36) /
X     1  2,0,0,0,0,0,
X     2  0,1,1,0,0,0,
X     3  0,1,1,0,0,0,
X     4  0,0,0,2,0,0,
X     5  0,0,0,0,0,0,
X     6  0,0,0,0,0,0 /
X
X
X      data ngtype(21) /-40/
X      data lattyp(21) /'oS'/
X      data pjnorm(21) /2./
X      data (projct(i,21),i=1,36) /
X     1  2, 0, 0, 0, 0, 0,
X     2  0, 1, 0,-1, 0, 0,
X     3  0, 0, 2, 0, 0, 0,
X     4  0,-1, 0, 1, 0, 0,
X     5  0, 0, 0, 0, 0, 0,
X     6  0, 0, 0, 0, 0, 0  /
X
X
X      data ngtype(22) /16/
X      data lattyp(22) /'oF'/
X      data pjnorm(22) /10./
X      data (projct(i,22),i=1,36) /
X     1  3, 3, 0,-2,-2,-2,
X     2  3, 3, 0,-2,-2,-2,
X     3  0, 0,10, 0, 0, 0,
X     4 -2,-2, 0, 3, 3,-2,
X     5 -2,-2, 0, 3, 3,-2,
X     6 -2,-2, 0,-2,-2, 8  /
X
X
X      data ngtype(23) /26/
X      data lattyp(23) /'oF'/
X      data pjnorm(23) /13./
X      data (projct(i,23),i=1,36) /
X     1  4, 0, 0, 2, 4, 4,
X     2  0,13, 0, 0, 0, 0,
X     3  0, 0,13, 0, 0, 0,
X     4  2, 0, 0, 1, 2, 2,
X     5  4, 0, 0, 2, 4, 4,
X     6  4, 0, 0, 2, 4, 4  /
X
X
X      data ngtype(24) /8/
X      data lattyp(24) /'oI'/
X      data pjnorm(24) /13./
X      data (projct(i,24),i=1,36) /
X     1  3, 3, 3,-2,-2,-2,
X     2  3, 3, 3,-2,-2,-2,
X     3  3, 3, 3,-2,-2,-2,
X     4 -2,-2,-2,10,-3,-3,
X     5 -2,-2,-2,-3,10,-3,
X     6 -2,-2,-2,-3,-3,10  /
X
X
X      data ngtype(25) /19/
X      data lattyp(25) /'oI'/
X      data pjnorm(25) /6./
X      data (projct(i,25),i=1,36) /
X     1  2,0,0,0,2,2,
X     2  0,3,3,0,0,0,
X     3  0,3,3,0,0,0,
X     4  0,0,0,6,0,0,
X     5  2,0,0,0,2,2,
X     6  2,0,0,0,2,2  /
X
X
X      data ngtype(26) /42/
X      data lattyp(26) /'oI'/
X      data pjnorm(26) /2./
X      data (projct(i,26),i=1,36) /
X     1  1, 0, 0, 0,-1, 0,
X     2  0, 1, 0,-1, 0, 0,
X     3  0, 0, 2, 0, 0, 0,
X     4  0,-1, 0, 1, 0, 0,
X     5 -1, 0, 0, 0, 1, 0,
X     6  0, 0, 0, 0, 0, 0  /
X
X
X      data ngtype(27) /33/
X      data lattyp(27) /'mP'/
X      data pjnorm(27) /1./
X      data (projct(i,27),i=1,36) /
X     1  1,0,0,0,0,0,
X     2  0,1,0,0,0,0,
X     3  0,0,1,0,0,0,
X     4  0,0,0,0,0,0,
X     5  0,0,0,0,1,0,
X     6  0,0,0,0,0,0  /
X
X
X      data ngtype(28) /-35/
X      data lattyp(28) /'mP'/
X      data pjnorm(28) /1./
X      data (projct(i,28),i=1,36) /
X     1  1,0,0,0,0,0,
X     2  0,1,0,0,0,0,
X     3  0,0,1,0,0,0,
X     4  0,0,0,1,0,0,
X     5  0,0,0,0,0,0,
X     6  0,0,0,0,0,0  /
X
X
X      data ngtype(29) /-34/
X      data lattyp(29) /'mP'/
X      data pjnorm(29) /1./
X      data (projct(i,29),i=1,36) /
X     1  1,0,0,0,0,0,
X     2  0,1,0,0,0,0,
X     3  0,0,1,0,0,0,
X     4  0,0,0,0,0,0,
X     5  0,0,0,0,0,0,
X     6  0,0,0,0,0,1  /
X
X
X      data ngtype(30) /39/
X      data lattyp(30) /'mS'/
X      data pjnorm(30) /2./
X      data (projct(i,30),i=1,36) /
X     1  1, 0, 0, 0, 0,-1,
X     2  0, 2, 0, 0, 0, 0,
X     3  0, 0, 2, 0, 0, 0,
X     4  0, 0, 0, 2, 0, 0,
X     5  0, 0, 0, 0, 0, 0,
X     6 -1, 0, 0, 0, 0, 1  /
X
X
X      data ngtype(31) /-41/
X      data lattyp(31) /'mS'/
X      data pjnorm(31) /2./
X      data (projct(i,31),i=1,36) /
X     1  2, 0, 0, 0, 0, 0,
X     2  0, 1, 0,-1, 0, 0,
X     3  0, 0, 2, 0, 0, 0,
X     4  0,-1, 0, 1, 0, 0,
X     5  0, 0, 0, 0, 2, 0,
X     6  0, 0, 0, 0, 0, 0  /
X
X
X      data ngtype(32) /-37/
X      data lattyp(32) /'mS'/
X      data pjnorm(32) /2./
X      data (projct(i,32),i=1,36) /
X     1  1, 0, 0, 0,-1, 0,
X     2  0, 2, 0, 0, 0, 0,
X     3  0, 0, 2, 0, 0, 0,
X     4  0, 0, 0, 2, 0, 0,
X     5 -1, 0, 0, 0, 1, 0,
X     6  0, 0, 0, 0, 0, 0  /
X
X
X      data ngtype(33) /10/
X      data lattyp(33) /'mS'/
X      data pjnorm(33) /2./
X      data (projct(i,33),i=1,36) /
X     1  1,1,0,0,0,0,
X     2  1,1,0,0,0,0,
X     3  0,0,2,0,0,0,
X     4  0,0,0,1,1,0,
X     5  0,0,0,1,1,0,
X     6  0,0,0,0,0,2  /
X
X
X      data ngtype(34) /-14/
X      data lattyp(34) /'mS'/
X      data pjnorm(34) /2./
X      data (projct(i,34),i=1,36) /
X     1  1,1,0,0,0,0,
X     2  1,1,0,0,0,0,
X     3  0,0,2,0,0,0,
X     4  0,0,0,1,1,0,
X     5  0,0,0,1,1,0,
X     6  0,0,0,0,0,2  /
X
X
X      data ngtype(35) /-20/
X      data lattyp(35) /'mS'/
X      data pjnorm(35) /2./
X      data (projct(i,35),i=1,36) /
X     1  2,0,0,0,0,0,
X     2  0,1,1,0,0,0,
X     3  0,1,1,0,0,0,
X     4  0,0,0,2,0,0,
X     5  0,0,0,0,1,1,
X     6  0,0,0,0,1,1  /
X
X
X      data ngtype(36) /-25/
X      data lattyp(36) /'mS'/
X      data pjnorm(36) /2./
X      data (projct(i,36),i=1,36) /
X     1  2,0,0,0,0,0,
X     2  0,1,1,0,0,0,
X     3  0,1,1,0,0,0,
X     4  0,0,0,2,0,0,
X     5  0,0,0,0,1,1,
X     6  0,0,0,0,1,1  /
X
X
X      data ngtype(37) /28/
X      data lattyp(37) /'mS'/
X      data pjnorm(37) /10./
X      data (projct(i,37),i=1,36) /
X     1  5, 0, 0, 0, 5, 0,
X     2  0,10, 0, 0, 0, 0,
X     3  0, 0,10, 0, 0, 0,
X     4  0, 0, 0, 2, 0, 4,
X     5  5, 0, 0, 0, 5, 0,
X     6  0, 0, 0, 4, 0, 8  /
X
X
X      data ngtype(38) /-30/
X      data lattyp(38) /'mS'/
X      data pjnorm(38) /10./
X      data (projct(i,38),i=1,36) /
X     1  10, 0, 0, 0, 0, 0,
X     2   0, 5, 0, 5, 0, 0,
X     3   0, 0,10, 0, 0, 0,
X     4   0, 5, 0, 5, 0, 0,
X     5   0, 0, 0, 0, 2, 4,
X     6   0, 0, 0, 0, 4, 8  /
X
X
X      data ngtype(39) /-29/
X      data lattyp(39) /'mS'/
X      data pjnorm(39) /10./
X      data (projct(i,39),i=1,36) /
X     1  5, 0, 0, 0, 0, 5,
X     2  0,10, 0, 0, 0, 0,
X     3  0, 0,10, 0, 0, 0,
X     4  0, 0, 0, 2, 4, 0,
X     5  0, 0, 0, 4, 8, 0,
X     6  5, 0, 0, 0, 0, 5  /
X
X
X      data ngtype(40) /43/
X      data lattyp(40) /'mI'/
X      data pjnorm(40) /20./
X      data (projct(i,40),i=1,36) /
X     1  11, 1, 0, 1,-9,-4,
X     2   1,11, 0,-9, 1,-4,
X     3   0, 0,20, 0, 0, 0,
X     4   1,-9, 0,11, 1,-4,
X     5  -9, 1, 0, 1,11,-4,
X     6  -4,-4, 0,-4,-4,16  /
X
X
X      data ngtype(41) /17/
X      data lattyp(41) /'mI'/
X      data pjnorm(41) /10./
X      data (projct(i,41),i=1,36) /
X     1  3, 3, 0,-2,-2,-2,
X     2  3, 3, 0,-2,-2,-2,
X     3  0, 0,10, 0, 0, 0,
X     4 -2,-2, 0, 8,-2,-2,
X     5 -2,-2, 0,-2, 8,-2,
X     6 -2,-2, 0,-2,-2, 8  /
X
X
X      data ngtype(42) /27/
X      data lattyp(42) /'mI'/
X      data pjnorm(42) /3./
X      data (projct(i,42),i=1,36) /
X     1  1,0,0,0,1,1,
X     2  0,3,0,0,0,0,
X     3  0,0,3,0,0,0,
X     4  0,0,0,3,0,0,
X     5  1,0,0,0,1,1,
X     6  1,0,0,0,1,1  /
XC-----------------------------------------------------------------------
X
X      nprob = 0
X      if (test .ne. 'BLDPRJ') then
X         write (*,*)
X     *   ' '//hm//' test string was not BLDPRJ in that routine'
X         stop
X      endif
X
XC check the projectors for internal correctness
X
X      do 4000 iproj=1,42
XC there are only 42 niggli lattice types (ignoring triclinic)
X        if (ngtype(iproj).gt.43) then
X            write (*,*)
X     *      ' '//hm//' bad ngtype ',iproj,ngtype(iproj)
X            nprob = nprob + 1
X        endif
XC check that the lattice type is present
X        if (lattyp(iproj).eq.' ') then
X           write (*,*) ' '//hm//' blank lattyp ',iproj
X           nprob = nprob + 1
X        endif
XC check that the normalizers are in the range in Paciorek and Bonin
X        if (pjnorm(iproj) .le. 0 .or. pjnorm(iproj).gt. 60) then
X           write (*,*) ' '//hm//' bad pjnorm ',iproj,' ',pjnorm(iproj)
X           nprob = nprob + 1
X        endif
XC check that the projectors are symmetrical matrices
X        do 1000 i=1,5
X        do 1000 j=i+1,6
X          if (zprj(j,i,iproj) .ne. zprj(i,j,iproj)) then
X             write (*,*) ' '//hm//' bad projector ',iproj,' ',i,' ',j
X             write (*,*) zprj(j,i,iproj),' ',zprj(i,j,iproj)
X             nprob = nprob + 1
X          endif
X 1000   continue
X        do 2000 i=1,36
XC check that the actual projector has no value greater than 1.0
X          if (abs(projct(i,iproj)/(pjnorm(iproj))).gt. 1.00001) then
X             write (*,*) ' '//hm//' bad projector, value > 1.0 '
X             write (*,*) ' '//hm,iproj,' pjnorm ',pjnorm(iproj),
X     2    ' i ',i,' ',projct(i,iproj)
X             write (*,*)
X             nprob = nprob + 1
X          endif
X 2000    continue
XC check that the projector is positive definite
X        do 3500 i=1,3
X        sum = 0.0
X        do 3000 j=1,6
X          sum = sum + abs(zprj(i,j,iproj))
X 3000   continue
X        if (sum .le. 0) then
X           write (*,*) ' '//hm//' zero xyz row, ',iproj
X           nprob = nprob + 1
X        endif
X 3500   continue
X 4000 continue
X
XC actually output the projectors
X
X      NPROJ = 0
X      do 5100 i=1,MIN(MAXPRJ,42)
X         IF (NGTYPE(I) .GT. 0) THEN
X            NPROJ = NPROJ + 1
X            itdesg(NPROJ) = ngtype(i)
X            chrlat(NPROJ) = lattyp(i)
X            pjn(NPROJ)    = pjnorm(i)
X         do 5000 ii=1,36
X            prj(ii,nproj) = projct(ii,i)
X 5000    continue
X         ENDIF
X 5100 continue
X
X      if (nprob .gt. 0) then
X         write (*,*) ' '//hm//' ',
X     *     nprob,' problems were found with projectors'
X         stop
X      endif
X
X      itemp = projct(1,1)
X      projct(1,1) = itemp
X
X      end
X
XC**********************************************************************C
X      SUBROUTINE BLDTRE (MXTREE,NVEC,X,IDIN,TREE,TEST)
XC  BLDTRE is called once for each point to be loaded into its internal
XC  data structure (TREE).  It builds the tree structure of Kalantari
XC  and McDonald (IEEE Transactions on Software Engineering, v. SE-9,
XC  pp. 631-634,1983) for the extremely fast retrieval of coordinates.
X
X
XC   MXTREE is the largest index that is allowed in the array TREE.
XC   TREE   must be the order of 9-10 times the number of points to be
XC          included.
XC   X      is an input point's coordinates.
XC   IDIN   is an arbitrary integer input, which will often be an array
XC          index to be retrieved later. BLDTRE does not examine IDIN.
XC   TEST   must be the string 'BLDTRE' -- it is used to make sure
XC          that the number of formal parameters is correct.
X
XC  TREE is used by NEARST and by INSPHR to find the nearest neighbor
XC  to a probe point.  To initialize (or reinitialize) a TREE, set
XC  TREE(1) equal to 0.0
X
X
X      include 'ITERATE.cmn'
X      CHARACTER*6 TEST
X      LOGICAL DEBUG
X      REAL TREE(MXTREE)
X      INTEGER RMAX
X      DATA LINK,RMAX,ID,ICHILD  /1,2,3,4/
X      DATA DEBUG /.false./
XC----------------------------------------------------------------------C
X
X      IF (TEST .NE. 'BLDTRE' .AND. TEST .NE. 'bldtre')
X     2     CALL BADCAL (TEST,'BLDTRE')
X
XC   THE NODE SIZE IS 4 PLUS THE SIZE OF THE VECTOR
X      NODSIZ = 4+NVEC
X      IPOINT = 2
X      IF (TREE(1) .GT. 0) THEN
X          IFREE = TREE(1)
X      ELSE
X         IFREE = 2
X      ENDIF
X      tree(ifree) = 0
X 1000 CONTINUE
X      IF (DEBUG) WRITE (*,*)
X     2 ' '//hm//' AFTER 1000 IN BLDTRE, IPOINT,TREE(IPOINT) ',
X     3   IPOINT,TREE(IPOINT)
X      IF (DEBUG) WRITE (*,*) ' '//hm//' IFREE,TREE(1),TREE(2) ',
X     2     IFREE,INT(TREE(1)),INT(TREE(2))
X
X      IF (TREE(IPOINT) .EQ. 0) THEN
X         IF (DEBUG) WRITE (*,*)
X     *   ' '//hm//' A NEW NODE IS BEING ALLOCATED'
X         IPOINT = IFREE
X         TREE(IPOINT) = -1
X         TREE(IPOINT+LINK) = -1
X         TREE(IPOINT+ID) = IDIN
X         CALL CPYVN (NVEC,X,TREE(IPOINT+ICHILD))
X         TREE(1) = IFREE + NODSIZ
X         RETURN
X      ELSEIF (TREE(IPOINT) .EQ. -1) THEN
X         IF (DEBUG) WRITE (*,*)
X     *   ' '//hm//' RIGHT CHILD OF NODE IS BEING FILLED'
X         TREE(IPOINT) = IFREE
X         TREE(IFREE+LINK) = -1
X         TREE (IFREE+RMAX) = -1.0
X         TREE(IFREE+ID) = IDIN
X         CALL CPYVN (NVEC,X,TREE(IFREE+ICHILD))
X         IFREE = IFREE + NODSIZ
X         TREE(1) = IFREE
X         RETURN
X      ELSE
X         IRIGHT = TREE(IPOINT)
X         DL = TREELN (NVEC,X,TREE(IPOINT+ICHILD))
X         DR = TREELN (NVEC,X,TREE(IRIGHT+ICHILD))
X         IF (DEBUG) WRITE (*,*) ' '//hm//' DL,DR ',DL,DR
X         IF (DR .GT. DL) THEN
X             IF (DEBUG) WRITE (*,*)
X     *       ' '//hm//' ',DR,DL,IPOINT,LINK,RMAX
X             IF (TREE(IPOINT+LINK) .LE. 0) THEN
X                TREE(IPOINT+RMAX) = DL
X                TREE(IPOINT+LINK) = IFREE
X                IPOINT = IFREE
X             ELSE
X                TREE(IPOINT+RMAX) =
X     2                 MAX(DL,TREE(IPOINT+RMAX))
X                IPOINT = TREE(IPOINT+LINK)
X             ENDIF
X
X         ELSE
X             IF (TREE(IRIGHT+LINK) .LE. 0) THEN
X                 TREE(IRIGHT+RMAX) = DR
X                 TREE(IRIGHT+LINK) = IFREE
X                 IPOINT = IFREE
X              ELSE
X                 TREE(IRIGHT+RMAX) =
X     2                  MAX(DR,TREE(IRIGHT+RMAX))
X                 IPOINT = TREE(IRIGHT+LINK)
X              ENDIF
X
X         ENDIF
X         GO TO 1000
X      ENDIF
X      END
X
X
XC***********************************************************************
X      SUBROUTINE CHKVEC(V)
XC  Check that a g6 vector represents a valid cell. Currently, it only
XC  checks that the cell edges are real
X
X      include 'ITERATE.cmn'
X      REAL V(6)
XC-----------------------------------------------------------------------
X      NBAD = 0
X      DO 1000 I=1,3
X         IF(V(I).LE. 0.0) THEN
X            WRITE (*,*) ' '//hm//' BAD VECTOR, I=',I,' ',V(I)
X            NBAD = NBAD + 1
X         ENDIF
X 1000 CONTINUE
X      IF (NBAD .GT. 0) STOP
X      END
X
XC**********************************************************************C
X      SUBROUTINE CPYVN (NVEC,X,Y)
XC----COPY A VECTOR X INTO A VECTOR Y
X      DIMENSION X(NVEC), Y(NVEC)
XC----------------------------------------------------------------------C
X      DO 1000 I=1,NVEC
X      Y(I) = X(I)
X 1000 CONTINUE
X      END
X
XC***********************************************************************
X      SUBROUTINE CTOG6 (CV,CVE,G,GE,SIZE,ERRSIZ,RATIO,TEST)
XC  Convert from a unit cell (edge lengths and angles) to a g6 vector,
XC  also computing the errors in the g6 vector. The length of the vector
XC  and the error in the length of the vector is what iterate is really
XC  going to use.
X
X      include 'ITERATE.cmn'
X      CHARACTER *6 TEST
X      REAL COSI(4:6)
X      REAL C(6),CV(6),CE(6),CVE(6),G(6),GE(6)
XC-----------------------------------------------------------------------
X
X      IF (TEST .NE. 'CTOG6 ') THEN
X         WRITE (*,*) ' '//hm//' TEST IS WRONG IN CTOG6'
X         STOP
X      ENDIF
X      RAD = ATAN2(0.0,-1.0) / 180.0
X      DO 1000 I=1,6
X          C(I) = CV(I)
X          CE(I) = CVE(I)
X 1000 CONTINUE
X      DO 1100 I=4,6
X         C(I) = C(I) * RAD
X         CE(I) = CE(I) * RAD
X 1100 CONTINUE
X
X      DO 1500 I=1,3
X         J = I + 3
X         G(I) = C(I)*C(I)
X         COSI(J) = COS(C(J))
X         IF (C(I).NE.0.0) THEN
X            G(J)=2.0*C(1)*C(2)*C(3)*COSI(J)/C(I)
X         ELSE
X            G(J) = 0.0
X         ENDIF
X         GE(I) = 2.*ABS(C(I)*CE(I))
XC         WRITE (*,*) ' '//hm//' GE(I) ',I,' ',GE(I)
X 1500 CONTINUE
X
X      DO 2000 I=1,3
X         J = I + 3
X         IF (J.EQ.4) THEN
X            I1 = 2
X            I2 = 3
X         ELSEIF (J.EQ.5) THEN
X            I1 = 1
X            I2 = 3
X         ELSE
X            I1 = 1
X            I2 = 2
X         ENDIF
X         GE(J) = 2.0*SQRT(G(I1)*(COSI(J)*CE(I2))**2 +
X     2                    G(I2)*(COSI(J)*CE(I1))**2 +
X     3                    G(I1)*G(I2)*(SIN(C(J))*CE(J))**2)
X
XC
XC   NOTE THE UNITS IMBALANCE ABOVE
XC
X
XC      WRITE (*,*) ' '//hm//' GE(J) ',J,' ',GE(J)
X 2000 CONTINUE
X
X      SIZE = 0.0
X      ERRSIZ = 0.0
X      DO 3000 I=1,6
X         SIZE = SIZE + G(I)*G(I)
X         ERRSIZ = ERRSIZ + GE(I)*GE(I)
X 3000 CONTINUE
X
X      SIZE = SQRT(SIZE)
X      ERRSIZ = SQRT(ERRSIZ)
X      RATIO = ERRSIZ / SIZE
X      END
X
XC***********************************************************************
X      FUNCTION DOTVN (N,V1,V2)
XC compute a dot product
X      REAL V1(N),V2(N)
XC-----------------------------------------------------------------------
X      DOTVN = 0.0
X      DO 1000 I=1,N
X         DOTVN = DOTVN + V1(I)*V2(I)
X 1000 CONTINUE
X      END
X
XC***********************************************************************
X      SUBROUTINE DRMV6 (V1,M,V2)
X      REAL V1(6),V2(6)
X      REAL M(36)
X      DOUBLE PRECISION SUM
XC-----------------------------------------------------------------------
X      DO 3000 I=1,6
X      SUM = 0.0D0
X      DO 2000 J=1,6
X         SUM = SUM + DBLE(M(6*(I-1)+J))*DBLE(V1(J))
X 2000 CONTINUE
X      V2(I) = SUM
X 3000 CONTINUE
X      END
X
X
XC***********************************************************************
X      logical function G6TOC (G,C,TEST)
XC compute the normal unit cell parameters from a given g6 vector
X
X      include 'ITERATE.cmn'
X      CHARACTER *6 TEST
X      REAL G(6),C(6)
XC-----------------------------------------------------------------------
X      IF (TEST .NE. 'G6TOC ') THEN
X         WRITE (*,*) ' '//hm//' TEST WAS WRONG IN G6TOC'
X         STOP
X      ENDIF
X      g6toc = .true.
X      DO 900 I=1,3
X         IF (G(I) .LE. 0.0) THEN
X            WRITE (*,*) ' '//hm//' G(I)<=0, I=',I,'  ',G(I)
X            g6toc = .false.
X         ENDIF
X  900 CONTINUE
X
X      DO 1000 I=1,3
X 1000 C(I) = SQRT(G(I))
X      AC = 0.5*G(4)/C(2)/C(3)
X      IF (ABS(AC) .LE. 1.0) THEN
X         C(4) = 57.296*ACOS(AC)
X      ELSE
X         C(4) = 0.0
X         WRITE (*,*) ' '//hm//' ARG>1.0 C(4) ',AC,1.0-ABS(AC)
X            g6toc = .false.
X      ENDIF
X
X      AC = 0.5*G(5)/C(1)/C(3)
X      IF (ABS(AC) .LE. 1.0) THEN
X         C(5) = 57.296*ACOS(AC)
X      ELSE
X         C(5) = 0.0
X         WRITE (*,*) ' '//hm//' ARG>1.0 C(5) ',AC,1.0-ABS(AC)
X            g6toc = .false.
X      ENDIF
X
X      AC = 0.5*G(6)/C(1)/C(2)
X      IF (ABS(AC) .LE. 1.0) THEN
X         C(6) = 57.296*ACOS(AC)
X      ELSE
X         C(6) = 0.0
X         WRITE (*,*) ' '//hm//' ARG>1.0 C(6) ',AC,1.0-ABS(AC)
X            g6toc = .false.
X      ENDIF
X      END
X
XC***********************************************************************
X      subroutine g6tor3 (g6,m3)
XC compute the normal unit cell parameters from a given g6 vector
X
X      include 'ITERATE.cmn'
X      logical pcmnt_
X      integer i,j
X      real g6(6,6),m3(3,3)
XC-----------------------------------------------------------------------
X
X      do 2000 i=1,3
X         do 1000 j=1,3
X            if (g6(i,j) .lt. -1.0e-6) then
X               if (ostyle.ne.'CIF ') then
X                 write (*,*)
X     *           ' '//hm//' negative element in upper left of g6'
X               else
X                 cifres=pcmnt_(' negative square in g6 matrix')
X               endif
X            elseif (g6(i,j) .lt. 1.0e-6) then
X               m3(i,j) = 0.0
X            else
X               m3(i,j) = sqrt(g6(i,j))
X            endif
X 1000 continue
X 2000 continue
X
X
X      do 3000 i=1,3
X      call gtr3sn(m3(i,1),m3(i,2),m3(i,3), g6(i,4),g6(i,5),g6(i,6))
X 3000 continue
X
X      if (abs(g6(5,5)) .gt. 1.0e-6) then
X         if (g6(5,5)*(m3(1,1)*m3(3,3)+m3(1,3)*m3(3,1)) .lt. 0.0) then
X            do 4000 i= 1,3
X               m3(3,i) = -m3(3,i)
X 4000       continue
X         endif
X      elseif (abs(g6(5,4)) .gt. 1.0e-6) then
X         if (g6(5,4)*(m3(1,2)*m3(3,3)+m3(1,3)*m3(3,2)) .lt. 0.0) then
X            do 4100 i= 1,3
X               m3(3,i) = -m3(3,i)
X 4100       continue
X         endif
X      elseif (abs(g6(5,6)) .gt. 1.0e-6) then
X         if (g6(5,6)*(m3(1,1)*m3(3,2)+m3(1,2)*m3(3,1)) .lt. 0.0) then
X            do 4200 i= 1,3
X               m3(3,i) = -m3(3,i)
X 4200       continue
X         endif
X      endif
X
X      if (abs(g6(6,6)) .gt. 1.0e-6) then
X         if (g6(6,6)*(m3(1,1)*m3(2,2)+m3(1,2)*m3(2,1)) .lt. 0.0) then
X            do 5000 i= 1,3
X               m3(2,i) = -m3(2,i)
X 5000       continue
X         endif
X      elseif (abs(g6(6,5)) .gt. 1.0e-6) then
X         if (g6(6,5)*(m3(1,1)*m3(2,3)+m3(1,3)*m3(2,1)) .lt. 0.0) then
X            do 5100 i= 1,3
X               m3(2,i) = -m3(2,i)
X 5100       continue
X         endif
X      elseif (abs(g6(6,4)) .gt. 0.0) then
X         if (g6(6,4)*(m3(1,2)*m3(2,3)+m3(1,3)*m3(2,2)) .lt. 0.0) then
X            do 5200 i= 1,3
X               m3(2,i) = -m3(2,i)
X 5200       continue
X         endif
X      endif
X      end
X
X      subroutine gtr3sn(e1,e2,e3, g4,g5,g6)
X      if (e1 .ne. 0.0) then
X         e2 = unitsn(g6)*e2
X         e3 = unitsn(g5)*e3
X      elseif (e3 .ne. 0.0) then
X         e3 = unitsn(g4)*e3
X      endif
X      end
X
XC***********************************************************************
X      LOGICAL FUNCTION INPCEL (LATSYM,CV,CE,eof)
XC get the input lattice type, cell, and errors in the cell parameters
X
X      include 'ITERATE.cmn'
X      logical char_
X      logical numb_
X      EXTERNAL OKCELL
X      LOGICAL OKCELL
X      CHARACTER *1 LATSYM
X      REAL CV(6),CE(6)
X      logical eof
XC-----------------------------------------------------------------------
X
X      eof = .false.
X      inpcel = .true.
X      cifeid = '.'
X      cifsgs = 'P'
X 1000 CONTINUE
X      IF (querst.ne.'NO')
X     *  WRITE (*,*) ' '//hm//' Input Xtal Lattice Centering '
X      if (istyle.ne.'CIF ') then
X        READ (*,'(A1)',end=9000) LATSYM
X      else
X        cifres = char_('_cell.entry_id',cifeid)
X        if (.not.cifres) cifeid = '.'
X        cifres = char_('_cell.space_group_name_H-M',cifsgs)
X        LATSYM = 'P'
X        if(cifres) LATSYM=cifsgs(1:1)
X        if(cifsgs.eq.' ') cifsgs = 'P'
X      endif
X      IF (LATSYM .GE. 'a' .AND. LATSYM .LE. 'z')
X     2 LATSYM = CHAR(ICHAR(LATSYM)-ICHAR('a')+ICHAR('A'))
X      IF (querst.ne.'NO')
X     *  WRITE (*,*) ' '//hm//' Input Cell Parameters'
X      if (istyle.ne.'CIF ') then
X      READ (*,*,end=9000) CV
X      else
X      do ii = 1,6
X      CE(II) = 0.
X      enddo
X      cifres = numb_('_cell.length_a',cv(1),ce(1))
X      if (.not.cifres) goto 9000
X      cifres = numb_('_cell.length_b',cv(2),ce(2))
X      cifres = numb_('_cell.length_c',cv(3),ce(3))
X      cifres = numb_('_cell.angle_alpha',cv(4),ce(4))
X      cifres = numb_('_cell.angle_beta',cv(5),ce(5))
X      cifres = numb_('_cell.angle_gamma',cv(6),ce(6))
X      endif
X      INPCEL = OKCELL(LATSYM,CV,' TALK')
X      IF (.NOT. INPCEL) GO TO 1000
X
X      IF (querst.ne.'NO')
X     * WRITE (*,*)
X     * ' '//hm//' Input Standard Deviations of Cell Parameters'
X      if (istyle.ne.'CIF ') then
X      READ (*,*,end=9000) CE
X      endif
X      DO II = 1,6
X      CE(II) = MAX(CE(II),ABS(CV(II))*5.E-7,1.E-4)
X      ENDDO
X      return
X 9000 eof=.true.
X      inpcel = .false.
X      END
X
XC**********************************************************************C
X      FUNCTION INSPHR (MXTREE,NVEC,X,RADMAX,TREE,
X     2    MXLIST,NLIST,LIST,IDLIST,TEST)
XC         After the TREE has been constructed using BLDTRE,
XC         INSPHR is used to retrieve all of the points within
XC         RADMAX of the point X.  MXTREE is the maximum size of
XC         TREE.  The indices of the found points are returned in
XC         the array LIST; NLIST are returned, up to a maximum of
XC         MXLIST.  For instance, TREE(LIST(3)) is the vector of
XC         the third point found in the list.  IDLIST contains the
XC         corresponding list of the input ID's.  If no points are
XC         found within RADMAX of X, then INSPHR and NLIST are
XC         returned as 0; otherwise they are returned as the
XC         number of points found.  If more than MXLIST points were
XC         found, then NLIST is returned equal to MXLIST, and
XC         INSPHR is returned equal to -MXLIST.  TEST must be the
XC         string 'INSPHR'.
XC         See also BLDTRE and NEARST.
X      include 'ITERATE.cmn'
X      CHARACTER*6 TEST
X      LOGICAL DEBUG
X      INTEGER ISTAK(1000)
X      REAL TREE(MXTREE)
X      INTEGER LIST(MXLIST),IDLIST(MXLIST)
X      INTEGER RMAX	
X      DATA DEBUG /.FALSE./
X      DATA LINK,RMAX,ID,ICHILD /1,2,3,4/
X      DATA RIGHT,LEFT,END /111,112,113/
XC----------------------------------------------------------------------C
X
X      IF (TEST .NE. 'INSPHR' .AND. TEST .NE. 'insphr')
X     2    CALL BADCAL (TEST,'INSPHR')
X
X      ISTKP = 0
X      NLIST = 0
X      IPOINT = 2
X      CURMIN = RADMAX
X      DIR = LEFT
X      DIRPRV = RIGHT
X      IPREV = IPOINT -1
X      if (tree(1).le.0.0) go to 8000
X 1000 CONTINUE
X      IF (IPREV .EQ. IPOINT .AND. DIRPRV .EQ. DIR) THEN
X         WRITE (*,*) ' '//hm//' INTERNAL ERROR IN INSPHR '
X         WRITE (*,*)
X     *   ' '//hm//' TREE POINTER DIDN''T CHANGE',IPOINT,' ',DIR
X         STOP
X      ELSEIF (IPOINT .EQ. 0) THEN
X         WRITE (*,*)
X     *   ' '//hm//' INTERNAL ERROR IN INSPHR, IPOINT = 0'
X         STOP
X      ENDIF
X      IPREV = IPOINT
X      DIRPRV = DIR
X      IF (DEBUG) WRITE (*,*)  
X     *  ' '//hm//' IN INSPHR 1000, IPOINT = ',IPOINT
X      IF (TREE(IPOINT) .EQ. 0) THEN
X         IF (DEBUG) WRITE (*,*)
X     *  ' '//hm//' AT AN END WITH IPOINT = ',IPOINT
X         DIR = END
X      ELSEIF (DIR .EQ. RIGHT) THEN
X         IRIGHT = TREE(IPOINT)
X         IF (DEBUG) WRITE (*,*)
X     *   ' '//hm//' WENT RIGHT WITH IPOINT ', IPOINT
X         DR = TREELN (NVEC,TREE(IRIGHT+ICHILD),X)
X         IF (DR .LT. CURMIN) THEN
X            NLIST = NLIST + 1
X            IF (NLIST .GT. MXLIST) GO TO 8000
X            LIST(NLIST) = IRIGHT + ICHILD
X            IDLIST(NLIST) = TREE(IRIGHT+ID)
X         ENDIF
X         IF (TREE(IRIGHT+LINK) .LE. 0) THEN
X            IF (DEBUG) WRITE (*,*)
X     *      ' '//hm//' ON RIGHT BRANCH, UNSTACK A POINT'
X            DIR = END
X         ELSEIF (TREE(IRIGHT+RMAX)+CURMIN .GT. DR) THEN
X            IPOINT = TREE(IRIGHT+LINK)
X            DIR = LEFT
X         ELSE
X             DIR = END
X         ENDIF
X      ELSE
X         IF (DEBUG) WRITE (*,*) ' '//hm//' WENT LEFT, IPOINT ',IPOINT
X         DIR = LEFT
X         IF (TREE(IPOINT) .GT. 0) THEN
X            IF (DEBUG) WRITE (*,*) ' '//hm//' STACK ONE '
X            CALL TRSTCK (IPOINT,ISTAK,ISTKP)
X         ENDIF
X         DL = TREELN (NVEC,TREE(IPOINT+ICHILD),X)
X         IF (DL .LT. CURMIN) THEN
X            NLIST = NLIST + 1
X            IF (NLIST .GT. MXLIST) GO TO 8000
X            LIST(NLIST) = IPOINT+ICHILD
X            IDLIST(NLIST) = TREE(IPOINT+ID)
X         ENDIF
X         IF (TREE(IPOINT+LINK) .LE. 0) THEN
X            IF (DEBUG) WRITE (*,*) ' '//hm//' NO LEFT LINK, GO BACK'
X            DIR = END
X         ELSEIF (TREE(IPOINT+RMAX) .LT. 0.0) THEN
X            IF (DEBUG) WRITE (*,*) ' '//hm//' NO DESCENDING LEFT TREE'
X            DIR = END
X         ELSEIF (TREE(IPOINT+RMAX)+CURMIN .GT. DL) THEN
X            IF (DEBUG) WRITE (*,*) ' '//hm//
X     2        ' GOING TO GO DOWN ONE LEVEL ',
X     3         ' IPOINT AND UPDATE ',IPOINT,' ',INT(TREE(IPOINT+LINK))
X            IPOINT = TREE(IPOINT+LINK)
X         ELSE
X           IF (DEBUG) WRITE (*,*) ' '//hm//' NO CLOSER POINTS ON LEFT '
X           IF (DEBUG) WRITE (*,*) ' '//hm//' CURMIN,TREE(IPOINT+RMAX),
X     2     DL ',CURMIN,TREE(IPOINT+RMAX),DL
X           DIR = END
X         ENDIF
X      ENDIF
X      IF (DIR .EQ. END) THEN
X         IF (IUNSTK(IPOINT,ISTAK,ISTKP) .LE. 0) GO TO 8000
X         DIR = RIGHT
X      ENDIF
X      GO TO 1000
X 8000 CONTINUE
X      IF (NLIST .LE. MXLIST) THEN
X         INSPHR = NLIST
X      ELSE
X         INSPHR = -MXLIST
X         NLIST = MXLIST
X      ENDIF
X      END
X
XC**********************************************************************C
X      FUNCTION IUNSTK(NEXT,ISTAK,ISTKP)
XC helper function for INSPHR and NEARST
X      include 'ITERATE.cmn'
X      INTEGER ISTAK(1000)
X      LOGICAL DEBUG
X      DATA DEBUG /.FALSE./
XC----------------------------------------------------------------------C
X      IF (DEBUG) WRITE (*,*) ' '//hm//' IUNSTK,NEXT ',NEXT
X      IF (ISTKP .GT. 0) THEN
X         NEXT = ISTAK(ISTKP)
X         ISTKP = ISTKP-1
X      ELSE
X         NEXT = 0
X      ENDIF
X      IUNSTK = NEXT
X      END
X
XC***********************************************************************
X      SUBROUTINE MKNORM (VI,Mnorm,VOUT,TEST)
XC converts an input g6 vector to "normalized" form (Gruber's
XC terminology) or "standard presentation" (Andrews and Bernstein's
XC terminology)  and the corresponding transformation matrix
X      include 'ITERATE.cmn'
X      CHARACTER *6 TEST
X      REAL VIN(6),VI(6),VOUT(6)
X      real Mnorm(36),MAT(36),M1(36),MAT3(9)
X      LOGICAL AGAIN
XC-----------------------------------------------------------------------
X
X      IF (TEST .NE. 'MKNORM') THEN
X         WRITE (*,*) ' '//hm//' TEST WAS WRONG IN MKNORM'
X         STOP
X      ENDIF
X
X      CALL CPYVN(6,VI,VIN)
X
X      CALL RUNTMN(6,Mnorm)
X      NCYCLE = 0
X 1000 CONTINUE
X      NCYCLE = NCYCLE + 1
X      AGAIN =.FALSE.
X      CALL ZEROS (36,MAT)
X      IF ( (ABS(VIN(1)).GT.ABS(VIN(2))) .OR.
X     2 (VIN(1).EQ.VIN(2) .AND. ABS(VIN(4)).GT.ABS(VIN(5))) ) THEN
X         MAT(2) = 1
X         MAT(7) = 1
X         MAT(15) = 1
X         MAT(23) = 1
X         MAT(28) = 1
X         MAT(36) = 1
X         AGAIN = .TRUE.
X      ELSEIF ( (ABS(VIN(2)).GT.ABS(VIN(3))) .OR.
X     2 (VIN(2).EQ.VIN(3) .AND. ABS(VIN(5)).GT.ABS(VIN(6))) ) THEN
X         MAT(1) = 1
X         MAT(14) = 1
X         MAT(9) = 1
X         MAT(22) = 1
X         MAT(35) = 1
X         MAT(30) = 1
X         AGAIN = .TRUE.
X      ENDIF
X
X      IF (AGAIN) THEN
X         CALL mm6(MAT,Mnorm,M1)
X         CALL CPYVN(36,M1,Mnorm)
X         CALL RMV6(VIN,MAT,VOUT)
X         CALL CPYVN(6,VOUT,VIN)
X      ENDIF
X      IF (AGAIN .AND. NCYCLE.LT.4) GO TO 1000
X
X      NUMNEG = 0
X      DO 2000 I=4,6
X         IF (VIN(I).LT.0.0) NUMNEG = NUMNEG + 1
X 2000 CONTINUE
X      CALL RUNTMN(3,MAT3)
X      DO 4000 I=4,6
X      IF (NUMNEG.EQ.1) THEN
X         IF(VIN(I).GE.0.) MAT(3*(I-4)+I-3) = -1.
XC        MAT(6*(I-1)+I) = -SIGN(1.0,VIN(I))
X      ELSEIF (NUMNEG.EQ.2) THEN
X         IF(VIN(I).LT.0.) MAT(3*(I-4)+I-3) = -1.
XC        MAT(6*(I-1)+I) = SIGN(1.0,VIN(I))
X      ENDIF
X 4000 CONTINUE
X      call r3tog6(MAT3,MAT)
X      CALL mm6(MAT,Mnorm,M1)
X      CALL CPYVN(36,M1,Mnorm)
X      CALL RMV6(VIN,MAT,VOUT)
X      CALL CPYVN(6,VOUT,VIN)
X      END
X
XC***********************************************************************
X      SUBROUTINE MKPRIM (LATSYM,GIN,M,GOUT,TEST)
XC converts and input g6 vector to one corresponding to a primitive
XC lattice and the corresponding transformation matrix
X
X      include 'ITERATE.cmn'
X      CHARACTER *6 TEST
X      CHARACTER LATSYM
X      REAL GIN(6),GOUT(6)
X      REAL M(36)
XC-----------------------------------------------------------------------
X
X      IF (TEST .NE. 'MKPRIM') THEN
X         WRITE (*,*) ' '//hm//' TEST WAS WRONG IN MKPRIM'
X         STOP
X      ENDIF
X      CALL ZEROS (36,M)
X
X      IF (LATSYM .EQ. 'P') THEN
X         CALL RUNTMN(6,M)
X
X      ELSEIF (LATSYM .EQ. 'I') THEN
X         M(1) = 1
X         M(8) = 1
X         DO 1000 I=13,18
X 1000    M(I) = 0.25
X         M(20) = 1
X         M(22) = 0.5
X         M(24) = 0.5
X         M(25) = 1
X         M(29) = 0.5
X         M(30) = 0.5
X         M(36) = 1
X
X      ELSEIF (LATSYM .EQ. 'F') THEN
X         M(1) = 0.25
X         M(2) = 0.25
X         M(6) = 0.25
X         M(7) = 0.25
X         M(9) = 0.25
X         M(11) = 0.25
X         M(14) = 0.25
X         M(15) = 0.25
X         M(16) = 0.25
X         M(21) = 0.5
X         DO 2000 I=22,24
X 2000    M(I)= 0.25
X         M(26) = 0.5
X         DO 2100 I=28,30
X 2100    M(I) = 0.25
X         M(31) = 0.5
X         DO 2200 I=34,36
X 2200    M(I) = 0.25
X      ELSEIF (LATSYM .EQ. 'A') THEN
X         M(1) = 1
X         M(8) = 1
X         M(14) = 0.25
X         M(15) = 0.25
X         M(16) = 0.25
X         M(20) = 1
X         M(22) = 0.5
X         M(29) = 0.5
X         M(30) = 0.5
X         M(36) = 1
X      ELSEIF (LATSYM .EQ. 'B') THEN
X         M(1) = 1
X         M(8) = 1
X         M(13) = 0.25
X         M(15) = 0.25
X         M(17) = 0.25
X         M(22) = 0.5
X         M(24) = 0.5
X         M(25) = 1
X         M(29) = 0.5
X         M(36) = 1
X      ELSEIF (LATSYM .EQ. 'C') THEN
X         M(1) = 1
X         M(7) = 0.25
X         M(8) = 0.25
X         M(12) = 0.25
X         M(15) = 1
X         M(22) = 0.5
X         M(23) = 0.5
X         M(29) = 1
X         M(31) = 1
X         M(36) = 0.5
X      ELSEIF (LATSYM .EQ. 'R') THEN
X         DO 2300 I=1,36
X 2300    M(I) = 1./9.
X         M(1) = 4./9.
X         M(5) = 2./9.
X         M(6) = 2./9.
X         M(11) = -1./9.
X         M(12) = -1./9.
X         M(14) = 4./9.
X         M(16) = -2./9.
X         M(17) = -1./9.
X         M(18) = 2./9.
X         M(19) = 2./9.
X         M(20) = -4./9.
X         M(21) = 2./9.
X         M(22) = -1./9.
X         M(23) = -2./9.
X         M(25) = -4./9.
X         M(26) = -4./9.
X         M(27) = 2./9.
X         M(28) = -1./9.
X         M(30) = -5./9.
X         M(31) = -4./9.
X         M(32) = 2./9.
X         M(33) = 2./9.
X         M(34) = 2./9.
X      ELSE
X         WRITE (*,*) ' '//hm//' DID NOT FIND LATTICE SYMBOL ',LATSYM
X         STOP
X      ENDIF
X      CALL RMV6(GIN,M,GOUT)
X      END
X
X
XC      CALL MKREFL (RATIO,MXTREE,TREE,NVMAX,V,MATREF,NV,GRED,'MKREFL')
X
XC*********************************************************************** SUBROUTINE mm6(M1,M2,M3)
X      SUBROUTINE MKREFL
X     2 (DEBUG,RATIO,MXTREE,TREE,NVMAX,V,MATREF,NV,GRED,TEST)
X
XC MKREFL performs the iterations to search out the various
XC representations of a single lattice by a set of different unit cells.
XC There are many ways to do this iteration, and this one may well
XC not be optimal. It has been found to work well in practice as long
XC as cutoffs are not too strict. It is clear that, in general, it does
XC not find all of the possible unit cells within a particular radius
XC in g6.
X
X      include 'ITERATE.cmn'
X      PARAMETER (MXSWTC=2)
X      CHARACTER *6 TEST
X      REAL TREE(MXTREE), V(6,NVMAX), GRED(6)
X      REAL VT(6),VTT(6)
X      real mt2k(36),mti2k(36),mt1k(36)
X      real REFL(36,24)
X      real SWTCH(36,MXSWTC)
X      real MATREF(36,NVMAX)
X      LOGICAL DEBUG
XC-----------------------------------------------------------------------
X
X      DATA (SWTCH(I,1),I=1,36)/
X     1 1,0,0, 0,0,0,
X     2 0,1,0, 0,0,0,
X     3 1,0,1, 0,1,0,
X     4 0,0,0, 1,0,1,
X     5 2,0,0, 0,1,0,
X     6 0,0,0, 0,0,1 /
X
X      DATA (SWTCH(I,2),I=1,36)/
X     1 1,0,0, 0,0,0,
X     2 0,1,0, 0,0,0,
X     3 1,1,1, 1,1,1,
X     4 0,2,0, 1,0,1,
X     5 2,0,0, 0,1,1,
X     6 0,0,0, 0,0,1 /
X
X
X      DATA (REFL(I,1),I=1,36) /
X     2 1,0,0,0,0,0,
X     3 0,1,0,0,0,0,
X     4 0,0,1,0,0,0,
X     5 0,0,0,1,0,0,
X     6 0,0,0,0,1,0,
X     7 0,0,0,0,0,1 /
X
X      DATA (REFL(I,2),I=1,36) /
X     2 1,0,0,0,0,0,
X     3 0,1,0,0,0,0,
X     4 0,0,1,0,0,0,
X     5 0,0,0,-1,0,0,
X     6 0,0,0,0,-1,0,
X     7 0,0,0,0,0,1 /
X
X      DATA (REFL(I,3),I=1,36) /
X     2 1,0,0,0,0,0,
X     3 0,1,0,0,0,0,
X     4 0,0,1,0,0,0,
X     5 0,0,0,1,0,0,
X     6 0,0,0,0,-1,0,
X     7 0,0,0,0,0,-1 /
X
X      DATA (REFL(I,4),I=1,36) /
X     2 1,0,0,0,0,0,
X     3 0,1,0,0,0,0,
X     4 0,0,1,0,0,0,
X     5 0,0,0,-1,0,0,
X     6 0,0,0,0,1,0,
X     7 0,0,0,0,0,-1 /
X
X
X
X      DATA (REFL(I,5),I=1,36) /
X     2 0,1,0,0,0,0,
X     3 1,0,0,0,0,0,
X     4 0,0,1,0,0,0,
X     5 0,0,0,0,1,0,
X     6 0,0,0,1,0,0,
X     7 0,0,0,0,0,1 /
X
X      DATA (REFL(I,6),I=1,36) /
X     2 0,1,0,0,0,0,
X     3 1,0,0,0,0,0,
X     4 0,0,1,0,0,0,
X     5 0,0,0,0,-1,0,
X     6 0,0,0,-1,0,0,
X     7 0,0,0,0,0,1 /
X
X      DATA (REFL(I,7),I=1,36) /
X     2 0,1,0,0,0,0,
X     3 1,0,0,0,0,0,
X     4 0,0,1,0,0,0,
X     5 0,0,0,0,-1,0,
X     6 0,0,0,1,0,0,
X     7 0,0,0,0,0,-1 /
X
X      DATA (REFL(I,8),I=1,36) /
X     2 0,1,0,0,0,0,
X     3 1,0,0,0,0,0,
X     4 0,0,1,0,0,0,
X     5 0,0,0,0,1,0,
X     6 0,0,0,-1,0,0,
X     7 0,0,0,0,0,-1 /
X
X
X
X      DATA (REFL(I,9),I=1,36) /
X     2 1,0,0,0,0,0,
X     3 0,0,1,0,0,0,
X     4 0,1,0,0,0,0,
X     5 0,0,0,1,0,0,
X     6 0,0,0,0,0,1,
X     7 0,0,0,0,1,0 /
X
X      DATA (REFL(I,10),I=1,36) /
X     2 1,0,0,0,0,0,
X     3 0,0,1,0,0,0,
X     4 0,1,0,0,0,0,
X     5 0,0,0,-1,0,0,
X     6 0,0,0,0,0,-1,
X     7 0,0,0,0,1,0 /
X
X      DATA (REFL(I,11),I=1,36) /
X     2 1,0,0,0,0,0,
X     3 0,0,1,0,0,0,
X     4 0,1,0,0,0,0,
X     5 0,0,0,-1,0,0,
X     6 0,0,0,0,0,1,
X     7 0,0,0,0,-1,0 /
X
X      DATA (REFL(I,12),I=1,36) /
X     2 1,0,0,0,0,0,
X     3 0,0,1,0,0,0,
X     4 0,1,0,0,0,0,
X     5 0,0,0,1,0,0,
X     6 0,0,0,0,0,-1,
X     7 0,0,0,0,-1,0 /
X
X
X
X      DATA (REFL(I,13),I=1,36) /
X     2 0,0,1,0,0,0,
X     3 0,1,0,0,0,0,
X     4 1,0,0,0,0,0,
X     5 0,0,0,0,0,1,
X     6 0,0,0,0,1,0,
X     7 0,0,0,1,0,0 /
X
X      DATA (REFL(I,14),I=1,36) /
X     2 0,0,1,0,0,0,
X     3 0,1,0,0,0,0,
X     4 1,0,0,0,0,0,
X     5 0,0,0,0,0,-1,
X     6 0,0,0,0,-1,0,
X     7 0,0,0,1,0,0 /
X
X      DATA (REFL(I,15),I=1,36) /
X     2 0,0,1,0,0,0,
X     3 0,1,0,0,0,0,
X     4 1,0,0,0,0,0,
X     5 0,0,0,0,0,-1,
X     6 0,0,0,0,1,0,
X     7 0,0,0,-1,0,0 /
X
X      DATA (REFL(I,16),I=1,36) /
X     2 0,0,1,0,0,0,
X     3 0,1,0,0,0,0,
X     4 1,0,0,0,0,0,
X     5 0,0,0,0,0,1,
X     6 0,0,0,0,-1,0,
X     7 0,0,0,-1,0,0 /
X
X
X
X      DATA (REFL(I,17),I=1,36) /
X     2 0,1,0,0,0,0,
X     3 0,0,1,0,0,0,
X     4 1,0,0,0,0,0,
X     5 0,0,0,0,1,0,
X     6 0,0,0,0,0,1,
X     7 0,0,0,1,0,0 /
X
X      DATA (REFL(I,18),I=1,36) /
X     2 0,1,0,0,0,0,
X     3 0,0,1,0,0,0,
X     4 1,0,0,0,0,0,
X     5 0,0,0,0,-1,0,
X     6 0,0,0,0,0,-1,
X     7 0,0,0,1,0,0 /
X
X      DATA (REFL(I,19),I=1,36) /
X     2 0,1,0,0,0,0,
X     3 0,0,1,0,0,0,
X     4 1,0,0,0,0,0,
X     5 0,0,0,0,-1,0,
X     6 0,0,0,0,0,1,
X     7 0,0,0,-1,0,0 /
X
X      DATA (REFL(I,20),I=1,36) /
X     2 0,1,0,0,0,0,
X     3 0,0,1,0,0,0,
X     4 1,0,0,0,0,0,
X     5 0,0,0,0,1,0,
X     6 0,0,0,0,0,-1,
X     7 0,0,0,-1,0,0 /
X
X
X
X      DATA (REFL(I,21),I=1,36) /
X     2 0,0,1,0,0,0,
X     3 1,0,0,0,0,0,
X     4 0,1,0,0,0,0,
X     5 0,0,0,0,0,1,
X     6 0,0,0,1,0,0,
X     7 0,0,0,0,1,0 /
X
X      DATA (REFL(I,22),I=1,36) /
X     2 0,0,1,0,0,0,
X     3 1,0,0,0,0,0,
X     4 0,1,0,0,0,0,
X     5 0,0,0,0,0,-1,
X     6 0,0,0,-1,0,0,
X     7 0,0,0,0,1,0 /
X
X      DATA (REFL(I,23),I=1,36) /
X     2 0,0,1,0,0,0,
X     3 1,0,0,0,0,0,
X     4 0,1,0,0,0,0,
X     5 0,0,0,0,0,-1,
X     6 0,0,0,1,0,0,
X     7 0,0,0,0,-1,0 /
X
X      DATA (REFL(I,24),I=1,36) /
X     2 0,0,1,0,0,0,
X     3 1,0,0,0,0,0,
X     4 0,1,0,0,0,0,
X     5 0,0,0,0,0,1,
X     6 0,0,0,-1,0,0,
X     7 0,0,0,0,-1,0 /
X
X      IF (TEST .NE. 'MKREFL') THEN
X         WRITE (*,*) ' '//hm//' TEST WAS WRONG IN MKREFL'
X         STOP
X      ENDIF
X
X      TREE(1) = 0
X      TREE(2) = 0
X
X      NV = 0
X      DMIN = 0.1*SQRT(DOTVN(6,GRED,GRED))*RATIO
X      GRMIN = GRED(1)**2+GRED(2)**2+GRED(3)**2
X      DO 4000 ICYCLE=1,MXSWTC+1
X      DO 2000 IREFL=1,24
X         CALL RMV6(GRED,REFL(1,IREFL),VT)
XC#
XC#
XC      accumulate matrices starting from the reduced vector
X         call cpyvn (36,refl(1,irefl),mt2k)
XC#
XC#
XC There is a theoretical upper bound on how much the sum of the
XC edge lengths can change (3.0) in a single transformation. So
XC by allowing their square to only change by a factor of 9.0
XC (incremented to allow for error), we can limit the search.
X         IF (VT(1)**2+VT(2)**2+VT(3)**2.GT. 10.0*GRMIN) THEN
X            IF (DEBUG)WRITE (*,*) ' '//hm//' REJECT 1 ',GRMIN,VT
X         ELSEIF (ABS(VT(4)**2/VT(2)/VT(3)) .GT. 1.2 .OR.
X     2           ABS(VT(5)**2/VT(1)/VT(3)) .GT. 1.2 .OR.
X     3           ABS(VT(6)**2/VT(1)/VT(2)) .GT. 1.2 ) THEN
X            IF (DEBUG) WRITE (*,*)
X     *      ' '//hm//' REJECT 2 ',VT(4)**2/VT(2)/VT(3),
X     2                                   VT(5)**2/VT(1)/VT(3),
X     3                                   VT(6)**2/VT(1)/VT(2)
X
X
X
X
X         ELSE
X
XC set things up so that on the first cycle, the original vector
XC is stored, and nothing else happens. after that, the rest of the
XC switch matrices are used (from the 4000 loop).
X            IF (ICYCLE.EQ.1) THEN
X               MXINNR = 1
XC#
XC#
X               call cpyvn (36,mt2k,mti2k)
XC#
XC#
X            ELSE
X               MXINNR = 24
X               CALL RMV6(VT,SWTCH(1,ICYCLE-1),VTT)
XC#
XC#
X               call mm6(swtch(1,icycle-1),mt2k,mti2k)
XC#
XC#
X               CALL CPYVN(6,VTT,VT)
X            ENDIF
X            DO 1000 INNER=1,MXINNR
X               IF (ICYCLE.GT.1) THEN
X                  CALL RMV6(VT,REFL(1,INNER),VTT)
X                  CALL CPYVN(6,VTT,VT)
XC#
XC#
X                  call mm6(refl(1,inner),mti2k,mt1k)
X                  call cpyvn (36,mt1k,mti2k)
XC#
XC#
X               else
X                  call cpyvn (36,mti2k,mt1k)
X               ENDIF
X               NV1 = NV + 1
X               IF (NEARST(DEBUG,
X     2           MXTREE,6,VT,DMIN,TREE,NV1,ID,'NEARST') .EQ. 0)
X     3          THEN
X                  NV = NV + 1
X                  CALL BLDTRE (MXTREE,6,VT,NV,TREE,'BLDTRE')
X                  CALL CPYVN(6,VT,V(1,NV))
XC#
XC#
X                  call cpyvn(36,mt1k,matref(1,nv))
XC#
XC#
X                  IF (NV .EQ. NVMAX) GO TO 8000
X               ENDIF
X 1000       CONTINUE
X         ENDIF
X 2000 CONTINUE
X 4000 CONTINUE
X 8000 CONTINUE
X      if (debug) then
X         WRITE (*,*) ' '//hm//' NV IN MKREFL ',NV
X      endif
X
X      END
X
XC***********************************************************************
X      SUBROUTINE mm6(M1,M2,M3)
XC multiply two matrices (6x6), both in a linear array
X
X      REAL M1(36),M2(36),M3(36)
XC-----------------------------------------------------------------------
X      CALL ZEROS (36,M3)
X      DO 3000 I36=1,36
X      IROW = (I36+5)/6
X      ICOL = MOD(I36-1,6)+1
X      K = ICOL-6
X      DO 2000 J=6*IROW-5,6*IROW
X        K = K + 6
X           M3(I36) = M3(I36) + M1(J)*M2(K)
X 1000   CONTINUE
X 2000 CONTINUE
X 3000 CONTINUE
X      END
X
X
XC***********************************************************************
X      LOGICAL FUNCTION NEARRD (A,R,SIG)
X
XC test whether a cell (really a g6 vector) is nearly Buerger reduced
X
X      include 'ITERATE.cmn'
X      REAL A(6),R(6), B(6)
X      LOGICAL DEBUG
X      DATA DEBUG /.FALSE./
XC R IS THE REDUCED CELL VECTOR
XC check that the vector is near to reduced
XC-----------------------------------------------------------------------
X      DO 1000 I=1,3
X         IF (A(I) .LT. 1.0) THEN
X            NEARRD = .FALSE.
X            RETURN
X         ENDIF
X 1000 CONTINUE
X      DO 2000 I=1,6
X         B(I) = A(I)
X 2000 CONTINUE
X
X      IF (B(1) .GT. B(2)) THEN
X         BT = B(1)
X         B(1) = B(2)
X         B(2) = BT
X         BT = B(4)
X         B(4) = B(5)
X         B(5) = BT
X      ENDIF
X      IF (B(2) .GT. B(3)) THEN
X         BT = B(2)
X         B(2) = B(3)
X         B(3) = BT
X         BT = B(5)
X         B(5) = B(6)
X         B(6) = BT
X      ENDIF
X      IF (B(1) .GT. B(2)) THEN
X         BT = B(1)
X         B(1) = B(2)
X         B(2) = BT
X         BT = B(4)
X         B(4) = B(5)
X         B(5) = BT
X      ENDIF
X
X
X
X      NEARRD = .TRUE.
X      DO 4000 I=1,3
X         IF (B(I)-R(I) .GT. 5.0*SIG) THEN
X            IF (DEBUG) WRITE (*,*) ' '//hm//
X     2        ' NOT NEAR BUERGER ',I,B(I),R(I)
X            NEARRD = .FALSE.
X            RETURN
X         ENDIF
X 4000 CONTINUE
X
X      IF (ABS(B(4))/SQRT(B(2)*B(3)) .GT. 1.0+5.0*SIG) THEN
X         IF (DEBUG) WRITE (*,*)' '//hm//' ALPHA BAD '
X         NEARRD = .FALSE.
X         RETURN
X      ELSEIF (ABS(B(5))/SQRT(B(1)*B(3)) .GT. 1.0+5.0*SIG) THEN
X         IF (DEBUG) WRITE (*,*)' '//hm//' BETA BAD '
X         NEARRD = .FALSE.
X         RETURN
X      ELSEIF (ABS(B(6))/SQRT(B(1)*B(2)) .GT. 1.0+5.0*SIG) THEN
X         IF (DEBUG) WRITE (*,*)' '//hm//' GAMMA BAD '
X         NEARRD = .FALSE.
X         RETURN
X      ENDIF
X
X
X
X      END
X
XC**********************************************************************C
X      FUNCTION NEARST (debug,MXTREE,NVEC,X,RADMAX,TREE,IP,IDOUT,TEST)
XC         The parameters are the same as those of INSPHR, except
XC         that only the nearest point is found.  If no points are
XC         found within RADMAX of X, then IP and NEARST are
XC         returned as 0; otherwise they are returned as the index
XC         in TREE of the coordinates of the vector of the point
XC         closest to X.  TEST must be the string 'NEARST'.  ID is
XC         returned as the ID of the nearest point (if the value
XC         input as IDIN in BLDTRE was the index)
XC         See also BLDTRE and INSPHR
X      include 'ITERATE.cmn'
X      CHARACTER*6 TEST
X      LOGICAL DEBUG
X      parameter (maxstk=1000)
X      INTEGER ISTAK(maxstk)
X      REAL TREE(MXTREE)
XC      DATA DEBUG /.FALSE./
X      DATA LINK,RMAX,ID,ICHILD /1,2,3,4/
X      DATA RIGHT,LEFT,END /111,112,113/
XC----------------------------------------------------------------------C
X
X      IF (TEST .NE. 'NEARST' .AND. TEST .NE. 'nearst')
X     2    CALL BADCAL (TEST,'NEARST')
X
X      ISTKP = 0
X      IP = 0
X      IPOINT = 2
X      CURMIN = RADMAX
X      DIR = LEFT
X      DIRPRV = RIGHT
X      IPREV = IPOINT -1
X      if (tree(1).le.0.0) go to 8000
X 1000 CONTINUE
X      IPREV = IPOINT
X      DIRPRV = DIR
X      IF (DEBUG) WRITE (*,*)  ' '//hm//
X     2   ' IN NEARST 1000, IPOINT = ',IPOINT
X      IF (TREE(IPOINT) .EQ. 0) THEN
X         IF (DEBUG) WRITE (*,*) ' '//hm//
X     2   ' AT AN END WITH IPOINT = ',IPOINT
X         DIR = END
X      ELSEIF (DIR .EQ. RIGHT) THEN
X         IRIGHT = TREE(IPOINT)
X         IF (DEBUG) WRITE (*,*) ' '//hm//
X     2     ' WENT RIGHT WITH IPOINT ', IPOINT
X         DR = TREELN (NVEC,TREE(IRIGHT+ICHILD),X)
X         IF (DR .LT. CURMIN) THEN
X            CURMIN = DR
X            IP = IRIGHT + ICHILD
X            IDOUT = TREE(IRIGHT+ID)
X         ENDIF
X         IF (TREE(IRIGHT+LINK) .LE. 0) THEN
X            IF (DEBUG) WRITE (*,*) ' '//hm//
X     2        ' ON RIGHT BRANCH, UNSTACK A POINT'
X            DIR = END
X         ELSEIF (TREE(IRIGHT+RMAX)+CURMIN .GT. DR) THEN
X            IPOINT = TREE(IRIGHT+LINK)
X            DIR = LEFT
X         ELSE
X             DIR = END
X         ENDIF
X      ELSE
X         IF (DEBUG) WRITE (*,*) ' '//hm//' WENT LEFT, IPOINT ',IPOINT
X         DIR = LEFT
X         IF (TREE(IPOINT) .GT. 0) THEN
X            IF (DEBUG) WRITE (*,*) ' '//hm//' STACK ONE '
X            CALL TRSTCK(IPOINT,ISTAK,ISTKP)
X         ENDIF
X         DL = TREELN (NVEC,TREE(IPOINT+ICHILD),X)
X         IF (DL .LT. CURMIN) THEN
X            CURMIN = DL
X            IP = IPOINT+ICHILD
X            IDOUT = TREE(IPOINT+ID)
X         ENDIF
X         IF (TREE(IPOINT+LINK) .LE. 0) THEN
X            IF (DEBUG) WRITE (*,*) ' '//hm//' NO LEFT LINK, GO BACK'
X            DIR = END
X         ELSEIF (TREE(IPOINT+RMAX) .LT. 0.0) THEN
X            IF (DEBUG) WRITE (*,*) ' '//hm//' NO DESCENDING LEFT TREE'
X            DIR = END
X         ELSEIF (TREE(IPOINT+RMAX)+CURMIN .GT. DL) THEN
X            IF (DEBUG) WRITE (*,*) ' '//hm//
X     2         ' GOING TO GO DOWN ONE LEVEL ',
X     3         ' IPOINT AND UPDATE ',IPOINT,' ',INT(TREE(IPOINT+LINK))
X            IPOINT = TREE(IPOINT+LINK)
X         ELSE
X           IF (DEBUG) WRITE (*,*) ' '//hm//' NO CLOSER POINTS ON LEFT '
X           IF (DEBUG) WRITE (*,*) ' '//hm//' CURMIN,TREE(IPOINT+RMAX),
X     2       DL ',CURMIN,TREE(IPOINT+RMAX),DL
X           DIR = END
X         ENDIF
X      ENDIF
X      IF (DIR .EQ. END) THEN
X         if (debug) write (*,*) ' '//hm//
X     2     ' call unstk ',ipoint,istkp,maxstk
X         IF (IUNSTK(IPOINT,ISTAK,ISTKP) .LE. 0) GO TO 8000
X         DIR = RIGHT
X      ENDIF
X      GO TO 1000
X 8000 CONTINUE
X      NEARST = IP
X      END
X
XC***********************************************************************
X      LOGICAL FUNCTION OKCELL (LATSYM,CV,talk)
XC okcell determines if a particular cell makes sense. The variable
XC talk is used to determine if output is printed.
X
X      include 'ITERATE.cmn'
X      logical pcmnt_
X      PARAMETER (NLATT=16)
X      CHARACTER *1 SYMLST(NLATT)
X      CHARACTER *1 LATSYM
X      REAL CV(6)
X      character *(*) talk
X      DATA SYMLST /'P','A','B','C','I','F','R','H',
X     2             'p','a','b','c','i','f','r','h'/
XC-----------------------------------------------------------------------
X      OKCELL = .TRUE.
X
X
X      IF (CV(4).GT.175.0 .OR. CV(5).GT.175.0 .OR. CV(6).GT.175.0) THEN
X         if (talk .eq. ' TALK')
X     2   WRITE (*,*)
X     *   ' '//hm//' THE LATTICE ANGLES MUST BE LESS THAN 175 DEGREES'
X         OKCELL = .FALSE.
X      ENDIF
X
X      IF (CV(4).LT.5.0 .OR. CV(5).LT.5.0 .OR. CV(6).LT.5.0) THEN
X         if (talk .eq. ' TALK')
X     2   WRITE (*,*)
X     *  ' '//hm//' THE LATTICE ANGLES MUST EXCEED 5.0 DEGREES'
X         OKCELL = .FALSE.
X      ENDIF
X
X      DO 1000 I=1,NLATT
X         IF (LATSYM.EQ.SYMLST(I)) THEN
X            GO TO 1100
X         ENDIF
X 1000 CONTINUE
X         if (talk .eq. ' TALK')
X     2 WRITE (*,*)
X     * ' '//hm//' XTAL CENTERING SYMBOL ',LATSYM,' IS NOT IMPLEMENTED'
X      OKCELL = .FALSE.
X 1100 CONTINUE
X
X      IF (CV(4).GE.CV(5)+CV(6)) THEN
X         if (talk .eq. ' TALK')
X     2      WRITE (*,*)
X     *      ' '//hm//' ERROR, ALPHA EXCEEDS BETA PLUS GAMMA'
X         OKCELL = .FALSE.
X      ENDIF
X
X      IF (CV(5).GE.CV(4)+CV(6)) THEN
X         if (talk .eq. ' TALK')
X     2   WRITE (*,*) ' '//hm//' ERROR, BETA EXCEEDS ALPHA PLUS GAMMA'
X         OKCELL = .FALSE.
X      ENDIF
X
X      IF (CV(6).GE.CV(4)+CV(5)) THEN
X         if (talk .eq. ' TALK')
X     2   WRITE (*,*) ' '//hm//' ERROR, GAMMA EXCEEDS ALPHA PLUS BETA'
X         OKCELL = .FALSE.
X      ENDIF
X
X      IF (CV(4)+CV(5)+CV(6) .GT. 355.0) THEN
X         if (talk .eq. ' TALK') then
X         WRITE (*,*) ' '//hm//
X     2     ' THE SUM OF THE CELL ANGLES MUST BE LESS THAN'
X         WRITE (*,*) ' '//hm//' 355.0 DEGREES'
X         endif
X         OKCELL = .FALSE.
X      ENDIF
X
X      DO 2000 I=1,3
X         IF (CV(I) .LT. 1.0) THEN
X            WRITE (*,*) ' '//hm//' THE AXIAL LENGTHS MUST EXCEED 1.0'
X            OKCELL = .FALSE.
X         ENDIF
X 2000 CONTINUE
X
X      IF (LATSYM .EQ. 'R' .OR. LATSYM .EQ. 'r' .OR.
X     *  LATSYM .EQ. 'H' .OR. LATSYM .EQ. 'h') THEN
X        IF (ABS(CV(4)-90.).GT.1. .OR.
X     *    ABS(CV(5)-90.).GT.1. .OR.
X     *    ABS(CV(6)-120.).GT.1. .OR.
X     *    ABS(CV(1)-CV(2)).GT..5) THEN
X          IF (LATSYM.EQ.'R' .OR. LATSYM.EQ.'r') THEN
X            if (talk .eq. ' TALK') then
X            if (ostyle.ne.'CIF ') then
X            WRITE (*,*) ' '//hm//' RHOMBOHEDRAL CENTERING REQUIRES'
X            WRITE (*,*) ' '//hm//
X     2        ' A HEXAGONAL CELL (A=B, ALPHA=BETA=90,'
X            WRITE (*,*) ' '//hm//' GAMMA =120)'
X            else
X            cifres=pcmnt_(' Non-hexagonal R lattice '//cifeid)
X            endif
X            endif
X            IF (ABS(CV(1)-CV(2)) .LT. .5 .AND.
X     *        ABS(CV(2)-CV(3)) .LT. .5 .AND.
X     *        ABS(CV(1)-CV(3)) .LT. .5 .AND.
X     *        ABS(CV(4)-CV(5)) .LT. 1. .AND.
X     *        ABS(CV(5)-CV(6)) .LT. 1. .AND.
X     *        ABS(CV(4)-CV(6)) .LT. 1.) THEN
X              LATSYM = 'P'
X              if (ostyle.ne.'CIF ') then
X              WRITE (*,*) ' '//hm//
X     2          ' PROCESSING AS PRMITIVE RHOMBOHEDRAL'
X              else
X              cifres=pcmnt_(' Processing as primitve rhombohedral')
X              endif
X            ELSE
X              OKCELL = .FALSE.
X            ENDIF
X          ELSE
X            if (talk .eq. ' TALK') then
X            if (ostyle.ne.'CIF ') then
X            WRITE (*,*) ' '//hm//' A HEXAGONAL CELL REQUIRES'
X            WRITE (*,*) ' '//hm//' A=B, ALPHA=BETA=90,GAMMA =120'
X            else
X            cifres=pcmnt_(' non-hexagonal cell '//cifeid)
X            endif
X            endif
X            OKCELL = .FALSE.
X          ENDIF
X        ENDIF
X        IF (LATSYM .EQ. 'H' .OR. LATSYM .EQ. 'h') THEN
X          WRITE(*,*) ' '//hm//' PROCESSING H AS P'
X          LATSYM = 'P'
X        ENDIF
X      ENDIF
X      RETURN
X      END
X
X
X      subroutine r3tog6(e3,g6)
X
XC give a 3-space transformation matrix, determine the corresponding one
XC in g6
X
X      real e3(9),g6(36)
XC-----------------------------------------------------------------------
XC------------------------
XC   upper left 3x3 block
XC------------------------
X      g6(1)=e3(1)**2
X      g6(2)=e3(2)**2
X      g6(3)=e3(3)**2
X
X      g6(7)=e3(4)**2
X      g6(8)=e3(5)**2
X      g6(9)=e3(6)**2
X
X      g6(13)=e3(7)**2
X      g6(14)=e3(8)**2
X      g6(15)=e3(9)**2
XC------------------------
XC   upper right 3x3 block
XC------------------------
X      g6(4)=e3(2)*e3(3)
X      g6(5)=e3(1)*e3(3)
X      g6(6)=e3(1)*e3(2)
X
X      g6(10)=e3(5)*e3(6)
X      g6(11)=e3(4)*e3(6)
X      g6(12)=e3(4)*e3(5)
X
X      g6(16)=e3(8)*e3(9)
X      g6(17)=e3(7)*e3(9)
X      g6(18)=e3(7)*e3(8)
XC------------------------
XC   lower left 3x3 block
XC------------------------
X      g6(19)=2*e3(4)*e3(7)
X      g6(20)=2*e3(5)*e3(8)
X      g6(21)=2*e3(6)*e3(9)
X
X      g6(25)=2*e3(1)*e3(7)
X      g6(26)=2*e3(2)*e3(8)
X      g6(27)=2*e3(3)*e3(9)
X
X      g6(31)=2*e3(1)*e3(4)
X      g6(32)=2*e3(2)*e3(5)
X      g6(33)=2*e3(3)*e3(6)
XC------------------------
XC   lower right 3x3 block
XC------------------------
X      g6(22)=e3(5)*e3(9) + e3(8)*e3(6)
X      g6(23)=e3(4)*e3(9) + e3(7)*e3(6)
X      g6(24)=e3(4)*e3(8) + e3(4)*e3(5)
X
X      g6(28)=e3(2)*e3(9) + e3(8)*e3(3)
X      g6(29)=e3(1)*e3(9) + e3(7)*e3(3)
X      g6(30)=e3(1)*e3(8) + e3(7)*e3(2)
X
X      g6(34)=e3(2)*e3(6) + e3(5)*e3(3)
X      g6(35)=e3(1)*e3(6) + e3(4)*e3(3)
X      g6(36)=e3(1)*e3(5) + e3(4)*e3(2)
X
X      end
X
X
XC***********************************************************************
X      PROGRAM RED
X
X      include 'ITERATE.cmn'
X      logical init_
X      logical data_
X      logical ocif_
X      logical pdata_
X      logical pfile_
X      logical ploop_
X      logical pnumb_
X      logical pcmnt_
X      logical pchar_
X      INTEGER MAXPRJ
X      PARAMETER (MAXPRJ=42)
X      PARAMETER (NVMAX=1000)
X      PARAMETER (MXTREE=11*NVMAX)
X      INTEGER ITDESG(MAXPRJ)
X      CHARACTER *2 CHRLAT(MAXPRJ)
X      REAL PJNORM(MAXPRJ)
XC      common /cmprjn/ pjnorm
X      real PRJ(36,MAXPRJ)
XC      common /cmprj/ prj
X      REAL P(36),AP(36)
X      REAL CV(6),CE(6),G(6),GE(6),TG(6),AG(6),COUT(6)
X      REAL MPRIM(36)
X      real m3ptrd(9)
X      real MRED(36)
X      REAL GOUT(6),GRED(6),CRED(6)
X      LOGICAL INPCEL
X      LOGICAL NEARRD
X      EXTERNAL INPCEL
X      CHARACTER LATSYM
X
X      REAL TREE(MXTREE)
XC      common /cmtree/ tree
X      REAL V(6,NVMAX)
XC      common /cmv/ v
X      real MATREF(36,NVMAX),m1(36),m2(36)
X      real retcel(6),m3(9),m3t(9),m3ti(9)
X      REAL VBEST(6),AVBEST(6)
X
X      REAL DOTVN
X      EXTERNAL DOTVN
X      INTEGER NPROJ,I,J
X      REAL RATIO,SIZE,ERRSIZ
X      character*8 cellst(6)
X      logical eof,dbgmkr
X      logical g6toc, test
X      logical debug
X      data debug /.FALSE./
X
X
XC-----------------------------------------------------------------------
X      CALL GETENV('ITERATE_QUERY',querst)
X      CALL GETENV('OUTPUT_STYLE',ostyle)
X      CALL GETENV('INPUT_STYLE',istyle)
X      if(istyle.eq.'CIF '.or.ostyle.eq.'CIF ') then
X        cifres = init_(5,6,21,0)
X      endif
X      if(istyle.eq.'CIF ') then
X        querst = 'NO'
X        cifres = ocif_(' ')
X        cifres = data_(' ')
X      endif
X      hm = ' '
X      if (ostyle.eq.'CIF ') then
X        hm = '#'
X        tabl_ = .false.
X        cifres = pfile_(' ')
X        cifres = pdata_('G6_SEARCH')
X        cifres = ploop_('_cell.entry_id')
X        cifres = ploop_('_cell.id')
X        cifres = ploop_('_cell.space_group_name_H-M')
X        cifres = ploop_('_cell.Bravais_lattice_symbol')
X        cifres = ploop_('_cell.length_a')
X        cifres = ploop_('_cell.length_b')
X        cifres = ploop_('_cell.length_c')
X        cifres = ploop_('_cell.angle_alpha')
X        cifres = ploop_('_cell.angle_beta')
X        cifres = ploop_('_cell.angle_gamma')
X        cifres = ploop_('_cell.unreduced_length_a')
X        cifres = ploop_('_cell.unreduced_length_b')
X        cifres = ploop_('_cell.unreduced_length_c')
X        cifres = ploop_('_cell.unreduced_angle_alpha')
X        cifres = ploop_('_cell.unreduced_angle_beta')
X        cifres = ploop_('_cell.unreduced_angle_gamma')
X      endif
X      do 1 i=2,mxtree
X        tree(i) = 2**30
X    1 continue
X      iunt0 = 0
X      iunt1 = 1
X      iunt2 = 2
X      iunt3 = 3
X      iunt10 = 10
X      dbgmkr = .false.
X      IF (querst.ne.'NO') THEN
X        WRITE (*,*) ' '//hm//' BEFORE BLDPRJ'
X      ENDIF
X      CALL BLDPRJ (MAXPRJ,NPROJ,ITDESG,CHRLAT,PJNORM,PRJ,'BLDPRJ')
XC      write (*,*) ' '//hm//' nproj = ',nproj
X
X
XC loop until the input contains no more data
X
X
X 1000 continue
X
X      IF (INPCEL(LATSYM,CV,CE,eof)) THEN
X         CALL CTOG6(CV,CE,G,GE,SIZE,ERRSIZ,RATIO,'CTOG6 ')
X         if (ostyle.ne.'CIF ') then
X           WRITE (*,'(A,A)') '  '//hm//' Input Lattice Symbol  ',
X     2       latsym
X           WRITE (*,*)
X           WRITE (*,'(''  '//hm//' INPUT CELL AND ERRORS   '',
X     2      ''    INPUT VECTOR AND ERRORS'')')
X           WRITE (*,*)
X         else
X           cifres = pchar_(' ',cifeid)
X           cifres = pchar_(' ','.')
X           cifres = pchar_(' ',cifsgs)
X           cifres = pchar_(' ',latsym)
X         endif
X         CALL WRCLV6 (CV,CE,G,GE,'WRCLV6')
X         if (ostyle.ne.'CIF ') then
X           WRITE (*,*)
X         else
X           do ii = 1,6
X           cifres = pchar_(' ','.')
X           enddo
X         endif
X         CALL WRSIZE (SIZE,ERRSIZ,RATIO,'WRSIZE')
X         CALL MKPRIM (LATSYM,G,MPRIM,GOUT,'MKPRIM')
X         call cpyvn (36,mprim,m1)
X         CALL CHKVEC(GOUT)
X         CALL RUNTMN(6,MRED)
X         CALL REDUCE (GOUT,MRED,GRED,'REDUCE')
X         call mm6 (mred,m1,m2)
X         CALL CHKVEC(GRED)
X         test = G6TOC (GRED,CRED,'G6TOC ')
X         SIZE = SQRT(DOTVN(6,GRED,GRED))
X         ERRSIZ = RATIO * SIZE
X         if (ostyle.ne.'CIF ') then
X           WRITE (*,*)
X           WRITE (*,'(''  '//hm//' REDUCED CELL  '')')
X           WRITE (*,'(''  '//hm//' Red. Cell   '',6F10.3)')CRED
X           WRITE (*,'(''  '//hm//' Red. Vector '',6F9.2)') GRED
X         endif
X         CALL MKREFL (dbgmkr,RATIO,MXTREE,TREE,NVMAX,
X     2     V,MATREF,NV,GRED,'MKREFL')
X         if (querst .ne. 'NO') then
X            if(ostyle.ne.'CIF ')write (*,*) ' '//hm//' nv=',nv
X         endif
X         do 1200 iv=1,nv
X            call mm6(matref(1,iv),m2,m1)
X            call cpyvn (36,m1,matref(1,iv))
X 1200    continue
X         if (debug) then
X         do 1300 iv=1,nv
X            write (*,'(1x,a3,i5,6f8.3)')
X     *      ' '//hm//' ',iv,(v(ip,iv),ip=1,6)
X 1300    continue
X         endif
X
X
XC after reducing the input cell and iterating to find various 
XC nearly reduced cells, test the found cells using the projectors
XC of Paciorek and Bonin
X
X         nmatch = 0
X         DO 4000 I=1,NPROJ
X            nrej = 0
X            DBEST = 1.0E20
X            DBESTO = DBEST
X            nbest = 0
XC subtract the projector from the unit matrix (to give the "prep")
XC which when multiplied times a vector gives the vector component
XC not in the subspace defined by the projector
X            DO 3100 J=1,36
X               P(J) = REAL(PRJ(J,I))/PJNORM(I)
X 3100          AP(J) = -P(J)
X            DO 3200 J=1,36,7
X               AP(J) = 1.0 + AP(J)
X 3200       CONTINUE
X            DO 3300  IV=1,NV
X            CALL RMV6 (V(1,IV),AP,AG)
X            CALL RMV6 (V(1,IV),P,TG)
X            DTEST = DOTVN(6,AG,AG)/dotvn(6,tg,tg)
X            IF (DTEST .GE. DBEST) THEN
X
X            ELSEIF (TG(1) .LT. 1.0) THEN
X            ELSEIF (TG(2) .LT. 1.0) THEN
X            ELSEIF (TG(3) .LT. 1.0) THEN
X
X            ELSEIF (TG(1)*TG(2)*TG(3) + 0.125*TG(6)*TG(4)*TG(5)
X     2        + 0.125*TG(5)*TG(6)*TG(4) - 0.25*TG(5)*TG(2)*TG(5)
X     3        - 0.25*TG(1)*TG(4)*TG(4) - 0.25*TG(6)*TG(6)*TG(3)
X     4        .LE. 0.0) THEN
XC           if the metric tensor is negative, the cell is bad
X              NREJ = NREJ + 1
X              IF (DEBUG) WRITE (*,*) ' '//hm//' FAILED METRIC TENSOR'
X
X            ELSEIF (.NOT. NEARRD(V(1,IV),GRED,ERRSIZ)) THEN
X              IF (DEBUG) WRITE (*,*) ' '//hm//' FAILED NEARRD'
X            ELSE
X               DBEST = DTEST
X               CALL CPYVN(6,TG,VBEST)
X               CALL CPYVN(6,AG,AVBEST)
X               NBEST = IV
X               IF (DEBUG) WRITE (*,*) ' '//hm//
X     2           ' NBEST,DBEST ',NBEST,DBEST
X            ENDIF
X 3300       CONTINUE
X 3400       CONTINUE
X
XC output those cases that are acceptable
X
X            cutoff = amax1(10.0,amin1(errsiz,999.0))
X            if (nbest .ne. 0) dbest = sqrt(DOTVN(6,AVBEST,AVBEST))
X            IF (nbest .ne. 0 .and. DBEST .LE. cutoff) THEN
X               nmatch = nmatch + 1
X               if(ostyle.ne.'CIF ') then
X                 WRITE (*,*)
X                 WRITE (*,*)
X                 write (*,'(1x,I3,A,A,A,F7.2,A,A,A,I2,A)')
X     2             i,'   ',chrlat(i),' '//hm//' ',dbest,
X     3             ' = Distance Projected','    ',
X     4             'Internat. Tables#(',itdesg(i),')'
X               else
X                 cifres = pchar_(' ',cifeid)
X                 cifres = pnumb_(' ',float(i),0.)
X                 cifres = pchar_(' ',cifsgs)
X                 cifres = pchar_(' ',chrlat(i))
X               endif
X               if(ostyle.ne.'CIF') then
X                 WRITE (*,'(''  '//hm//'    Vector       '',6F8.1)')
X     2             VBEST
X               endif
X               if (G6TOC (VBEST,COUT,'G6TOC ')) then
X                 if(ostyle.ne.'CIF ') then
X                 WRITE (*,'(2x,'''//hm//
X     2             '    cell'',/12x,2(3F8.2,'' ''))') COUT
X                 else
X                 do ii = 1,6
X                   if(cout(ii).ge.0.)itemp = cout(ii)*100.+.5
X                   if(cout(ii).lt.0.)itemp = cout(ii)*100.-.5
X                   cifres = pnumb_(' ',float(itemp)/100.,0.)
X                 enddo
X                 endif
X                 call g6tor3 (matref(1,nbest),m3t)
X                 call inver (m3t,m3ti)
X                 call unredc (itdesg(i),'   ',vbest,retcel,m3,cellst)
X                 if(ostyle.eq.'CIF ') then
X                   do ii = 1,6
X                     cifres = pchar_(' ',cellst(ii))
X                   enddo
X                 endif
X                 call trnspz (m3,m3t)
X                 call wrcent(chrlat(i),retcel)
X                 if (debug) then
X                    write (*,'(3(1x,'' '//hm//' '',10x,3i3,/))')
X     *              (int(m3(im3)),im3=1,9)
X                    write (*,*)
X                    write (*,*) ' '//hm//' matref ,nbest = ',
X     2                nbest,' of ',nv
X                    write (*,'(6(1x,'' '//hm//
X     2                ' '',3x,3f8.3,2x,3f8.3/))')
X     3                (matref(im,nbest),im=1,36)
X                 endif
X                 call g6tor3 (matref(1,nbest),m3ptrd)
X                 call matmul (m3t,m3ptrd,m3ti)
X                 if(ostyle.ne.'CIF ') then
X                    write (*,*)' '//hm//'    transformation from ',
X     2               '3-space original cell'
X                    if (index('PR',chrlat(i)(2:2)) .ne. 0) then
X                      write (*,*) ' '//hm//'    to final primitive cell'
X                    else
X                      write (*,*) ' '//hm//'    to final centered cell'
X                    endif
X                    write (*,'(3(1x,'' '//hm//' '',8x,3f7.3/))') m3ti
X                 else
X                   cifres= pcmnt_(char(0))
X                 endif
X               endif
X            ENDIF
X 4000    CONTINUE
X      ENDIF
X      if (nmatch .eq. 0) then
X        if(ostyle.ne.'CIF ') then
X            WRITE (*,*) ' '//hm//
X     2        '*****************************************'
X     3        //'*************'
X            write (*,*) ' '//hm//
X     2        ' NO MATCHES WERE FOUND WITH THE SPECIFIED '
X     3        //'UNCERTAINTIES'
X            WRITE (*,*) ' '//hm//
X     2        '*****************************************'
X     3        //'*************'
X        else
X            cifres = pcmnt_(char(0))
X            cifres = pcmnt_(
X     * ' NO MATCHES WERE FOUND WITH THE SPECIFIED UNCERTAINTIES')
X        endif
X      endif
X      IF (querst.ne.'NO') THEN
X        if (.not. eof) THEN
X          if(ostyle.ne.'CIF ') then
X            WRITE (*,*)
X            WRITE (*,*)
X          else
X            cifres = pcmnt_(char(0))
X            cifres = pcmnt_(' ')
X          endif
X          go to 1000
X        endif
X      ENDIF
X      if (istyle.eq.'CIF ') then
X        if(loop_) goto 1000
X      endif
X      if (ostyle.eq.'CIF ' .or. istyle.eq.'CIF ') then
X        call close_
X      endif
X      END
X
XC***********************************************************************
X      SUBROUTINE REDUCE (VI,M,VOUT,TEST)
X
XC for a given input vector, determine the reduced vector and the
XC transformation from one to the other
X
X      include 'ITERATE.cmn'
X      CHARACTER *6 TEST
X
X      REAL VI(6),VIN(6), VOUT(6)
X      LOGICAL AGAIN
X      real M(36),M1(36),M2(36),mnorm(36)
X      REAL ZEROS(6)
X      DATA ZEROS /6*0.0/
XC-----------------------------------------------------------------------
X
X      IF (TEST .NE. 'REDUCE') THEN
X         WRITE (*,*) ' '//hm//' TEST WAS WRONG IN REDUCE'
X         STOP
X      ENDIF
X      CALL CPYVN(6,VI,VIN)
X      NCYCLE = 0
X 1000 CONTINUE
X      LAST = 0
X      CALL MKNORM (VIN,Mnorm,VOUT,'MKNORM')
X      call mm6 (mnorm,m,m2)
X      CALL CPYVN(36,m2,m)
X      CALL CPYVN(6,VOUT,VIN)
X      CALL RUNTMN (6,M1)
X      IF (ABS(VIN(4)) .GT. ABS(VIN(2))) THEN
X          M1(14) = 1.0
X          M1(16) = -SIGN (1.0,VIN(4))
X          M1(20) = -2.0*SIGN(1.0,VIN(4))
X          M1(30) = M1(16)
X          AGAIN = .TRUE.
X         CALL mm6(M1,M,M2)
X         CALL CPYVN (36,M2,M)
X         CALL RMV6(VIN,M1,VOUT)
X          LAST = 5
X      ELSEIF (ABS(VIN(5)) .GT. ABS(VIN(1))) THEN
X         M1(13) = 1
X         M1(17) = -SIGN (1.0,VIN(5))
X         M1(24) = M1(17)
X         M1(25) = 2*M1(17)
X         AGAIN = .TRUE.
X         CALL mm6(M1,M,M2)
X         CALL CPYVN (36,M2,M)
X         CALL RMV6(VIN,M1,VOUT)
X         LAST = 6
X      ELSEIF (ABS(VIN(6)) .GT. ABS(VIN(1))) THEN
X         M1(7) = 1
X         M1(12) = -SIGN(1.0,VIN(6))
X         M1(23) = M1(12)
X         M1(31) = 2*M1(12)
X         AGAIN = .TRUE.
X         CALL mm6(M1,M,M2)
X         CALL CPYVN (36,M2,M)
X         CALL RMV6(VIN,M1,VOUT)
X         LAST = 7
X      ELSEIF (VIN(4)+VIN(5)+VIN(6)+ABS(VIN(1))+ABS(VIN(2)) .LT. 0.0)
X     2   THEN
X         DO 2000 I=13,18
X 2000    M1(I) = 1
X         M1(20) = 2
X         M1(24) = 1
X         M1(25) = 2
X         M1(30) = 1
X         AGAIN = .TRUE.
X         CALL mm6(M1,M,M2)
X         CALL CPYVN (36,M2,M)
X         CALL RMV6(VIN,M1,VOUT)
X         LAST = 8
X      ELSEIF ( (VIN(4).EQ.VIN(2) .AND. 2.0*VIN(5).LT.VIN(6)) .OR.
X     2         (VIN(4).EQ.-ABS(VIN(2)) .AND. VIN(6).LT. 0.0) )
X     3   THEN
X         M1(14) = 1
X         M1(16) = -SIGN(1.0,VIN(4))
X         M1(20) = 2*M1(16)
X         M1(30) = M1(16)
X         AGAIN = .TRUE.
X         CALL mm6(M1,M,M2)
X         CALL CPYVN (36,M2,M)
X         CALL RMV6(VIN,M1,VOUT)
X         LAST = 15
X      ELSEIF ( (VIN(5).EQ.VIN(1) .AND. 2.0*VIN(4).LT.VIN(6)) .OR.
X     2         (VIN(5).EQ.-ABS(VIN(1)) .AND. VIN(6).LT.0.0) )
X     3    THEN
X         M1(13) = 1
X         M1(17) = -SIGN(1.0,VIN(5))
X         M1(24) = M1(17)
X         M1(25) = 2*M1(17)
X         AGAIN = .TRUE.
X         CALL mm6(M1,M,M2)
X         CALL CPYVN (36,M2,M)
X         CALL RMV6(VIN,M1,VOUT)
X         LAST = 16
X      ELSEIF ( (VIN(6).EQ.VIN(1) .AND. 2.0*VIN(4).LT.VIN(5)) .OR.
X     2         (VIN(6).EQ.-VIN(1) .AND. VIN(5).LT.0.0) ) THEN
X         M1(7) = 1
X         M1(12) = -SIGN(1.0,VIN(6))
X         M1(23) = M1(12)
X         M1(31) = 2*M1(12)
X         AGAIN = .TRUE.
X         CALL mm6(M1,M,M2)
X         CALL CPYVN (36,M2,M)
X         CALL RMV6(VIN,M1,VOUT)
X         LAST = 17
X      ELSEIF ( (VIN(4)+VIN(5)+VIN(6)+ABS(VIN(1))+ABS(VIN(2)).EQ.0.0)
X     2 .AND. ( 2.0*(ABS(VIN(1))+VIN(5))+VIN(6).GT.0.0) ) THEN
X         DO 3000 I=13,18
X 3000    M1(I) = 1
X         M1(20) = 2
X         M1(24) = 1
X         M1(25) = 2
X         M1(30) = 1
X         AGAIN = .TRUE.
X         CALL mm6(M1,M,M2)
X         CALL CPYVN (36,M2,M)
X         CALL RMV6(VIN,M1,VOUT)
X         LAST = 18
X      ELSE
X         AGAIN = .FALSE.
X         CALL CPYVN (6,VIN,VOUT)
X         call cpyvn (36,m2,m)
X      ENDIF
X
X      CALL MKNORM (VOUT,Mnorm,VIN,'MKNORM')
X         CALL mm6 (mnorm,m,m2)
X         CALL CPYVN(36,M2,M)
X         CALL CPYVN(6,VIN,VOUT)
X
X      IF (VIN(1).LT. 0.0 .OR. VIN(2).LT.0.0 .OR. VIN(3).LT.0.0) THEN
X         WRITE (*,*) ' '//hm//' NEG. SQ. AXIS ',NCYCLE
X         CALL WRVEC6(VIN,ZEROS,'WRVEC6')
X         CALL WRVEC6(VOUT,ZEROS,'WRVEC6')
X         if (istyle.ne.'CIF ') READ (*,*)
X      ENDIF
X
X      NCYCLE = NCYCLE + 1
X      IF (NCYCLE .LT. 25 .AND. AGAIN) GO TO 1000
X      END
X
XC***********************************************************************
X      SUBROUTINE RMV6 (V1,M,V2)
X      REAL V1(6),V2(6)
X      REAL M(36)
XC-----------------------------------------------------------------------
X      DO 3000 I=1,6
X      SUM = 0.0
X      DO 2000 J=1,6
X         SUM = SUM + M(6*(I-1)+J)*V1(J)
X 2000 CONTINUE
X      V2(I) = SUM
X 3000 CONTINUE
X      END
X
X      function root (a)
X      if (a.ge.0.0) then
X         root = sqrt(a)
X      else
X         root = 0
X      endif
X      end
X
XC***********************************************************************
X      SUBROUTINE RUNTMN (N,M)
X      INTEGER N
X      REAL M(N,N)
XC-----------------------------------------------------------------------
X      DO 1000 I=1,N
X      DO 1000 J=1,N
X 1000 M(I,J) = 0.0
X      DO 2000 I=1,N
X 2000 M(I,I) = 1.0
X      END
X
X
X      function sqr (a)
X      sqr = a*a
X      end
X
XC**********************************************************************C
X      FUNCTION TREELN (NVEC,A,B)
XC-----GET THE SEPARATION BETWEEN THE ENDS OF TWO VECTORS
XC used by bldtre, insphr and nearst
X      DIMENSION A(NVEC),B(NVEC)
XC----------------------------------------------------------------------C
X      SUM = 0.0
X      DO 1000 I=1,NVEC
X         SUM = SUM + (A(I)-B(I))**2
X 1000 CONTINUE
X      TREELN = SQRT(SUM)
X      END
X
XC**********************************************************************C
X      SUBROUTINE TRSTCK (NEXT,ISTAK,ISTKP)
X
XC helper routine for NEARST and INSPHR
X
X      include 'ITERATE.cmn'
X      INTEGER ISTAK(1000)
X      LOGICAL DEBUG
X      DATA DEBUG /.FALSE./
XC----------------------------------------------------------------------C
X      IF (DEBUG) WRITE (*,*) ' '//hm//
X     2    ' IN TRSTCK, STACK POINTER,IPOINT ',
X     3    ISTKP,NEXT
X      ISTKP = ISTKP + 1
X      ISTAK(ISTKP) = NEXT
X      END
X
XC**********************************************************************C
X      subroutine unitmx(n,a)
XC produce a unit matrix of order n
X      real a(n,n)
XC-----------------------------------------------------------------------
X      do 1000 i=1,n
X      do 1000 j=1,n
X 1000 a(i,j) = 0.0
X      do 2000 i=1,n
X 2000 a(i,i) = 1.0
X      end
X
XC**********************************************************************C
X      function unitsn (a)
XC-----------------------------------------------------------------------
X      if (a.ge.0.0) then
X         unitsn = 1
X      else
X         unitsn = -1
X      endif
X      end
X
XC**********************************************************************C
X      subroutine unredc (itcase,rfcase,v,cell,m,cellst)
X
XC given a g6 vector and a particular bravais lattice (designated either
XC by itcase or rfcase, that is by the International tables or by Niggli
XC and Roof's designations), compute the standard (often non-reduced)
XC unit cell
X
X      real m(9),v(6),cell(6)
X      character *3 rfcase
X      character *8 cellst(6),ctemp
X      integer itcase
X      real redv(6),altcel(6),v1(3),v2(3),v3(3),a(3),b(3),c(3),vtemp(3)
XC-----------------------------------------------------------------------
X
X
X      PI = 4.0*ATAN(1.0)
X      MAXINT = 32768.0
X      do 1000 I=1,6
X        Cell(I) = Maxint
X        altcel(i) = maxint
X        cellst(i) = '.'
X 1000 continue
X      do 1100 I = 1,9
X         M(I) = 0.0
X 1100 continue
X      do 1200 I=1,6
X         redv(I) = root(v(I))
X 1200 continue
X      redv(4) = v(4)/(redv(2)*redv(3))
X      redv(5) = v(5)/(redv(1)*redv(3))
X      redv(6) = v(6)/(redv(1)*redv(2))
X      IF (itcase .eq. 3 .or. rfcase .EQ. '44A') THEN
X          Cell(1) = redv(1)
X          CALL UNITMX(3,M)
X
X      ELSEIF (itcase .eq. 5 .or. rfcase .EQ. '44B') THEN
X          Cell(1) = root(4.0/3.0*v(1))
X          CALL UNITMX(3,M)
X          M(7) = 1.0
X          M(2) = 1.0
X          M(6) = 1.0
X
X      ELSEIF (itcase .eq. 1 .or. rfcase .EQ. '44C') THEN
X          Cell(1) = root(2*v(1))
X          do 4400 i = 1,9
X            M(I) = 1.0
X 4400     CONTINUE
X          M(4) = -1.0
X          M(8) = -1.0
X          M(3) = -1.0
X
X      ELSEIF (itcase .eq. 11 .or. rfcase .EQ. '45A') THEN
X         Cell(1) = redv(1)
X         Cell(3) = redv(3)
X         CALL UNITMX(3,M)
X
X      ELSEIF (itcase .eq. 21 .or. rfcase .eq. '45B') THEN
X         Cell(1) = redv(2)
X         Cell(3) = redv(1)
X                          M(4) = 1.0
X                                           M(8) = 1.0
X         M(3) = 1.0
X
X      ELSEIF (itcase .eq. 15 .or. rfcase .eq. '45C') THEN
X         Cell(1) = redv(1)
X         Cell(3) = root(4*v(3)-2*v(1))
X         M(1) = 1.0
X         M(5) = 1.0
X         M(9) = 2.0
X         M(3) = 1.0
X         M(6) = 1.0
X
X      ELSEIF (itcase .eq. 6 .or. rfcase .eq. '45D') THEN
X         Cell(1) = root(2*v(1)+v(6))
X         Cell(3) = root(2*v(1)+v(4))
X         do 4500 I= 1,9
X            M(I) = 1.0
X 4500    CONTINUE
X         do 4510 I = 1,9,4
X            M(I) = 0.0
X 4510    CONTINUE
X
X      ELSEIF (itcase .eq. 7 .or. rfcase .eq. '45d') THEN
X         Cell(1) = root(2*v(1)+v(6))
X         Cell(3) = root(2*v(1)+v(4))
X         do 4550 I=1,9,4
X            M(I) = 1.0
X 4550    CONTINUE
X         M(4) = 0.0
X         M(8) = 0.0
X         M(3) = 0.0
X
X      ELSEIF (itcase .eq. 18 .or. rfcase .eq. '45E') THEN
X         Cell(1) = redv(1)
X         Cell(3) = root( 2*v(3)-0.5*v(1))
X         M(4) = -1.0
X         M(7) = 1.0
X         M(2) = 1.0
X         M(5) = -1.0
X         M(8) = -1.0
X         M(3) = 1.0
X
X      ELSEIF (itcase .eq. 12 .or. rfcase .eq. '48A') THEN
X         Cell(1) = redv(1)
X         Cell(3) = redv(3)
X         CALL UNITMX(3,M)
X
X      ELSEIF (itcase .eq. 22 .or. rfcase .eq. '48B') THEN
X         Cell(1) = redv(3)
X         Cell(3) = redv(1)
X         M(4) = 1.0
X         M(8) = 1.0
X         M(3) = 1.0
X
X      ELSEIF (itcase .eq. 9 .or. rfcase .eq. '49B') THEN
X         Cell(1) = redv(3)
X         Cell(4) = 1-2*Sqr(redv(1)/(2*redv(3)))
X         altcel(1) = redv(1)
X         altcel(3) = root(9*v(3)-3*v(1))
X         M(1) = 1.0
X         M(2) = -1.0
X         M(5) = 1.0
X         M(3) = -1.0
X         M(6) = -1.0
X         M(9) = 3.0
X
X      ELSEIF (itcase .eq. 2 .or. itcase .eq. 4
X     2     .or. rfcase .eq. '49x') THEN
X         Cell(1) = redv(1)
X         Cell(4) = v(4)/(2*v(1))
X         altcel(1) = root(0.5*v(3)-0.25*v(4))
X         altcel(3) = root(9*v(1)-3*Sqr(altcel(1)))
X         M(1) = 1.0
X         M(4) = -1.0
X         M(2) = -1.0
X         M(8) = 1.0
X         do 4900 I= 3,9,3
X            M(I) = -1.0
X 4900    CONTINUE
X
X      ELSEIF (itcase .eq. 24 .or. rfcase .eq. '49E') THEN
X         Cell(1) = redv(3)
X         Cell(4) = v(4)/(2*v(2))
X         altcel(1) = root(0.5*v(3)-0.25*v(4))
X         altcel(3) = redv(1)
X         M(1) = 1.0
X         M(4) = 2.0
X         M(7) = 1.0
X         M(5) = -1.0
X         M(8) = 1.0
X         M(3) = 1.0
X
X      ELSEIF (itcase .eq. 32 .or. rfcase .eq. '50C') THEN
X         do 5000 I=1,3
X            Cell(I) = redv(I)
X 5000    CONTINUE
X         CALL UNITMX(3,M)
X
X      ELSEIF (itcase .eq. 36 .or. rfcase .eq. '50A') THEN
X         Cell(1) = redv(1)
X         Cell(2) = root(4*v(3)-v(1))
X         Cell(3) = redv(2)
X         M(1) = 1.0
X         M(2) = -1.0
X         M(8) = -2.0
X         M(6) = 1.0
X
X      ELSEIF (itcase .eq. 38 .or. rfcase .eq. '50B') THEN
X         Cell(1) = redv(1)
X         Cell(3) = redv(3)
X         Cell(2) = root(4*v(2)-v(1))
X         M(1) = 1.0
X         M(2) = -1.0
X         M(5) = -2.0
X         M(9) = 1.0
X
X      ELSEIF (itcase .eq. 13 .or. rfcase .eq. '50D') THEN
X         Cell(1) = root(2*v(1)+v(6))
X         Cell(2) = root(2*v(1)-v(6))
X         Cell(3) = redv(3)
X         M(1) = 1.0
X         M(4) = 1.0
X         M(2) = -1.0
X         M(5) = 1.0
X         M(9) = 1.0
X
X      ELSEIF (itcase .eq. 23 .or. rfcase .eq. '50E') THEN
X         Cell(1) = root(2*v(3)+v(4))
X         Cell(2) = root(2*v(3)-v(4))
X         Cell(3) = redv(1)
X         M(4) = 1.0
X         M(7) = 1.0
X         M(5) = -1.0
X         M(8) = 1.0
X         M(3) = 1.0
X
X      ELSEIF (itcase .eq. 40 .or. rfcase .eq. '50F') THEN
X         Cell(1) = redv(2)
X         Cell(2) = root(4*v(3)-v(2))
X         Cell(3) = redv(1)
X         M(4) = 1.0
X         M(5) = -1.0
X         M(8) = -2.0
X         M(3) = -1.0
X
X      ELSEIF (itcase .eq. 16 .or. rfcase .eq. '51A') THEN
X         Cell(1) = root(2*v(1)+v(6))
X         Cell(2) = root(2*v(1)-v(6))
X         Cell(3) = root(4*v(3)-Sqr(Cell(1)))
X         M(1) = 1.0
X         M(4) = -1.0
X         M(5) = 1.0
X         M(5) = 1.0
X         M(8) = 2.0
X         M(3) = -1.0
X         M(6) = -1.0
X
X      ELSEIF (itcase .eq. 26 .or. rfcase .eq. '51B') THEN
X         Cell(1) = redv(1)
X         Cell(2) = root(4*v(2)-v(1))
X         Cell(3) = root(4*v(3)-v(1))
X         M(1) = -1.0
X         M(4) = 2.0
X         M(2) = -1.0
X         M(8) = 2.0
X         M(3) = 1.0
X
X      ELSEIF (itcase .eq. 8 .or. rfcase .eq. '52A') THEN
X         Cell(1) = root(2*v(1)+v(6))
X         Cell(2) = root(2*v(1)+v(5))
X         Cell(3) = root(2*v(1)+v(4))
X         M(1) = 1.0
X         M(7) = 1.0
X         M(2) = 1.0
X         M(5) = 1.0
X         M(6) = 1.0
X         M(9) = 1.0
X
X      ELSEIF (itcase .eq. 19 .or. rfcase .eq. '52B') THEN
X         Cell(1) = redv(1)
X         Cell(2) = root(2*v(2)-v(4))
X         Cell(3) = root(2*v(3)+v(4)-v(1))
X         M(1) = -1.0
X         M(2) = -1.0
X         M(5) = 1.0
X         M(8) = 1.0
X         M(6) = -1.0
X         M(9) = 1.0
X
X      ELSEIF (itcase .eq. 42 .or. rfcase .eq. '52C') THEN
X         Cell(1) = redv(1)
X         Cell(2) = redv(2)
X         Cell(3) = root(4*v(3)-v(1)-v(2))
X         M(1) = 1.0
X         M(5) = 1.0
X         M(3) = -1.0
X         M(6) = -1.0
X         M(9) = -2.0
X
X      ELSEIF (itcase .eq. 33 .or. rfcase .eq. '53A') THEN
X         Cell(1) = redv(1)
X         Cell(2) = redv(2)
X         Cell(3) = redv(3)
X         Cell(5) = v(5)/(2*Cell(1)*Cell(3))
X         CALL UNITMX(3,M)
X
X      ELSEIF (itcase .eq. 35 .or. rfcase .eq. '53B') THEN
X         Cell(1) = redv(2)
X         Cell(2) = redv(1)
X         Cell(3) = redv(3)
X         Cell(5) = v(4)/(2*Cell(1)*Cell(3))
X         M(4) = 1.0
X         M(2) = 1.0
X         M(9) = 1.0
X
X      ELSEIF (itcase .eq. 34 .or. rfcase .eq. '53C') THEN
X         Cell(1) = redv(1)
X         Cell(2) = redv(3)
X         Cell(3) = redv(2)
X         Cell(5) = v(6)/(2*Cell(1)*Cell(3))
X         M(1) = 1.0
X         M(8) = 1.0
X         M(6) = 1.0
X
X      ELSEIF (itcase .eq. 39 .or. rfcase .eq. '54A') THEN
X         Cell(1) = root(4*v(2)-v(1))
X         Cell(2) = redv(1)
X         Cell(3) = redv(3)
X         Cell(5) = v(4)/(Cell(1)*Cell(3))
X         M(1) = 1.0
X         M(4) = 2.0
X         M(2) = 1.0
X         M(9) = 1.0
X
X      ELSEIF (itcase .eq. 41 .or. rfcase .eq. '54B') THEN
X         Cell(1) = root(4*v(3)-v(2))
X         Cell(2) = redv(2)
X         Cell(3) = redv(1)
X         Cell(5) = v(5)/(Cell(1)*Cell(3))
X         M(4) = 1.0
X         M(7) = 2.0
X         M(5) = 1.0
X         M(3) = 1.0
X
X      ELSEIF (itcase .eq. 37 .or. rfcase .eq. '54C') THEN
X         Cell(1) = root(4*v(3)-v(1))
X         Cell(2) = redv(1)
X         Cell(3) = redv(2)
X         Cell(5) = v(4)/(Cell(1)*Cell(3))
X         M(1) = 1.0
X         M(7) = 2.0
X         M(2) = 1.0
X         M(6) = 1.0
X
X      ELSEIF (itcase .eq. 10 .or. itcase .eq. 14
X     2     .or. rfcase .eq. '55A') THEN
X       call v2cart(v,v1,v2,v3)
X       call vecsum(v1,v2,A)
X       call vecdif(v2,v1,B)
X       call cpyvec(v3,c)
X       Cell(1) = Sqrt(Dot(A,A))
X       Cell(2) = Sqrt(Dot(B,B))
X       Cell(3) = Sqrt(Dot(C,C))
X       Cell(5) = -ABS(Dot(A,C)/Cell(1)/Cell(3))
X       IF (Cell(1) .EQ. Cell(2)) THEN
X
X          CALL UNITMX(3,M)
X          M(4) = 1.0
X          M(2) = -1.0
X       ELSE
X
X          M(4) = 1.0
X          M(7) = 1.0
X          M(5) = -1.0
X          M(8) = 1.0
X          M(3) = 1.0
X       ENDIF
X
X
X      ELSEIF (itcase .eq. 20 .or. itcase .eq. 25
X     2    .or. rfcase .eq. '55B') THEN
X       call v2cart(v,v1,v2,v3)
X       call vecsum(v3,v2,A)
X       call vecdif(v3,v2,B)
X       call cpyvec (v1,c)
X       Cell(1) = Sqrt(Dot(A,A))
X       Cell(2) = Sqrt(Dot(B,B))
X       Cell(3) = Sqrt(Dot(C,C))
X       Cell(5) = -ABS(Dot(A,C)/Cell(1)/Cell(3))
X       IF ((v(4).LT.0.0) .AND. (v(5).GE.0.0) .AND. (V(6).LT.0.0)) THEN
X
X          M(4) = 1.0
X          M(7) = 1.0
X          M(5) = 1.0
X          M(8) = -1.0
X          M(3) = -1.0
X       ELSE
X
X          M(4) = 1.0
X          M(7) = 1.0
X          M(5) = -1.0
X          M(8) = 1.0
X          M(3) = 1.0
X       ENDIF
X
X      ELSEIF (itcase .eq. 28 .or. rfcase .eq. '56A') THEN
X         call v2cart(v,A,C,v3)
X         do 5600 I=1,3
X            v3(I)=2*v3(I)
X 5600    continue
X         call vecdif(v3,A,B)
X         Cell(1)=Sqrt(Dot(A,A))
X         Cell(2)=Sqrt(Dot(B,B))
X         Cell(3)=Sqrt(Dot(C,C))
X         Cell(5)=-ABS(Dot(A,C)/Cell(1)/Cell(3))
X         M(1) = -1.0
X         M(2) = -1.0
X         M(8) = 2.0
X         M(6) = 1.0
X
X      ELSEIF (itcase .eq. 30 .or. rfcase .eq. '56B') THEN
X         call v2cart (v,C,A,v3)
X         do 5620 I=1,3
X            v3(I)=2*v3(I)
X 5620    continue
X         call vecdif(v3,A,B)
X         Cell(1)=Sqrt(Dot(A,A))
X         Cell(2)=Sqrt(Dot(B,B))
X         Cell(3)=Sqrt(Dot(C,C))
X         Cell(5)=-ABS(Dot(A,C)/Cell(1)/Cell(3))
X         M(4) = -1.0
X         M(5) = -1.0
X         M(8) = 2.0
X         M(3) = 1.0
X
X      ELSEIF (itcase .eq. 29 .or. rfcase .eq. '56C') THEN
X         call v2cart (v,A,v2,C)
X         do 5640 I=1,3
X            v2(I)=2*v2(I)
X 5640    continue
X         call vecdif(v2,A,B)
X         Cell(1)=Sqrt(Dot(A,A))
X         Cell(2)=Sqrt(Dot(B,B))
X         Cell(3)=Sqrt(Dot(C,C))
X         Cell(5)=-ABS(Dot(A,C)/Cell(1)/Cell(3))
X         M(1) = -1.0
X         M(2) = -1.0
X         M(5) = 2.0
X         M(9) = 1.0
X
X      ELSEIF (itcase .eq. 43 .or. rfcase .eq. '57A') THEN
X         call v2cart(v,A,C,v3)
X         do 5700 I=1,3
X            v3(I)=2*v3(I)
X 5700    continue
X         call vecsum(v3,C,v3)
X         call vecsum(v3,A,B)
X         Cell(1)=Sqrt(Dot(A,A))
X         Cell(2)=Sqrt(Dot(B,B))
X         Cell(3)=Sqrt(Dot(C,C))
X         Cell(5)=-ABS(Dot(A,C)/Cell(1)/Cell(3))
X         M(1) = 1.0
X         M(2) = 1.0
X         M(5) = 1.0
X         M(8) = 2.0
X         M(6) = 1.0
X
X      ELSEIF (itcase .eq. 17 .or. rfcase .eq. '57B') THEN
X         call v2cart(v,v1,v2,v3)
X         call vecsum(v1,v2,B)
X         call vecsum(v3,v2,C)
X         call vecsum(v3,v1,A)
X         Cell(1)=Sqrt(Dot(A,A))
X         Cell(2)=Sqrt(Dot(B,B))
X         Cell(3)=Sqrt(Dot(C,C))
X         Cell(5)=-ABS(Dot(A,C)/Cell(1)/Cell(3))
X         M(4) = 1.0
X         M(7) = 1.0
X         M(2) = 1.0
X         M(5) = 1.0
X         M(3) = 1.0
X         M(9) = 1.0
X
X      ELSEIF (itcase .eq. 27 .or. rfcase .eq. '57C') THEN
X         call v2cart(v,B,v2,v3)
X         call vecsum(v2,v3,vtemp)
X         call vecdif(vtemp,B,C)
X         call vecdif(v2,v3,A)
X         Cell(1)=Sqrt(Dot(A,A))
X         Cell(2)=Sqrt(Dot(B,B))
X         Cell(3)=Sqrt(Dot(C,C))
X         Cell(5)=-ABS(Dot(A,C)/Cell(1)/Cell(3))
X         M(4) = 1.0
X         M(7) = -1.0
X         M(2) = 1.0
X         M(3) = -1.0
X         M(6) = 1.0
X         M(9) = 1.0
X      ENDIF
X      do 8000 I = 4,6
X         IF (Cell(I)  .NE.  Maxint) THEN
X            Cell(I) = 180.0/PI*acos(Cell(I))
X            write(cellst(i),'(f8.2)') cell(i)
X         ENDIF
X 8000 CONTINUE
X      do 8100 i = 1,3
X         if(cell(i).ne.Maxint)
X     *     write(cellst(i),'(f8.2)') cell(i)
X 8100 CONTINUE
X      do 8500 I = 4,6
X         IF (altcel(I)  .NE.  Maxint) THEN
X            altcel(I) = 180.0/PI*acos(altcel(I))
X         ENDIF
X 8500 CONTINUE
X      do 8600 I = 1,6
X      do 8700 II = 1,8
X      if (cellst(I)(II:II).ne.' ') goto 8800
X 8700 continue
X      cellst(I)='.'
X      return
X 8800 ctemp = cellst(I)(II:8)
X      cellst(I)=ctemp
X 8600 continue
X      return
X
X      END
X
XC**********************************************************************C
X      subroutine  v2Cart(v ,v1,v2,v3 )
X
XC Compute the 3-space Cartesianizing transformation matrix corresponding
XC to a particular g6 vector. The base vectors of the transformation
XC are returned
X
X      real v(6),v1(3),v2(3),v3(3),cell(6)
X      real mat8
XC-----------------------------------------------------------------------
X      Cell(1) = Root(v(1))
X      Cell(2) = Root(v(2))
X      Cell(3) = Root(v(3))
X      Cell(4) = 0.5*v(4)/(Cell(2)*Cell(3))
X      Cell(5) = 0.5*v(5)/(Cell(1)*Cell(3))
X      Cell(6) = 0.5*v(6)/(Cell(1)*Cell(2))
X      SinAl = Sqrt(1-Sqr(Cell(4)))
X      SinBe = Sqrt(1-Sqr(Cell(5)))
X      SinGa = Sqrt(1-Sqr(Cell(6)))
X
X      v1(1) = Cell(1)
X      v1(2) = 0
X      v1(3) = 0
X
X      v2(1) = Cell(2) * Cell(6)
X      v2(2) = Cell(2) * SinGa
X      v2(3) = 0
X
X      v3(1) = Cell(3) * Cell(5)
X      Mat8 = (Cell(4)-Cell(5)*Cell(6)) / SinGa
X      v3(2) = Mat8 * Cell(3)
X      v3(3) = Cell(3)*Sqrt( Sqr(SinBe)-Sqr(Mat8) )
X      end
X
X
XC***********************************************************************
X      SUBROUTINE WRCELL (C,CE,TEST)
X      include 'ITERATE.cmn'
X      REAL C(6),CE(6)
X      CHARACTER *6 TEST
XC-----------------------------------------------------------------------
X      IF (TEST .NE. 'WRCELL') THEN
X         WRITE (*,*) ' '//hm//' TEST WAS WRONG IN WRCELL'
X         STOP
X      ENDIF
X
X      SUM = 0.0
X      DO 1000 I=1,6
X 1000 SUM = SUM + CE(I)
X      if (ostyle.ne.'CIF ') then
X      IF (SUM .EQ. 0) THEN
X         WRITE (*,'(1x,a3,1X,6F10.3)') ' '//hm//' ',C
X      ELSE
X         DO 3000 I=1,6
X            IF (CE(I) .GT. 0.0) THEN
X               WRITE (*,'(1x,a3,1X,F10.3,3X,F10.3)')
X     *         ' '//hm//' ',C(I),CE(I)
X            ELSE
X               WRITE (*,'(1x,a3,1X,F10.3,3X,F10.3)') ' '//hm//' ',C(I)
X            ENDIF
X 3000    CONTINUE
X      ENDIF
X      WRITE (*,*)
X      endif
X      END
X
X
XC***********************************************************************
X      subroutine wrcent(lat,retcel)
X      include 'ITERATE.cmn'
X      character  *2 lat
X      real retcel(6)
X      character *79 line
XC-----------------------------------------------------------------------
X
X
X      if (lat(2:2) .eq. 'P') then
X         line = ' primitive'
X      elseif (lat(2:2) .eq. 'S') then
X         line = ' side-centered '
X      elseif (lat(2:2) .eq. 'I') then
X         line = ' body-centered '
X      elseif (lat(2:2) .eq. 'F') then
X         line = ' face-centered '
X      elseif (lat(2:2) .eq. 'R') then
X         line = ' as rhomboh. '
X      endif
X
X      write (line(16:),'(f10.3)') retcel(1)
X
X
X
X      if (lat(1:1) .eq. 'm') then
X         write (line(26:),'(f10.3)') retcel(2)
X         write (line(36:),'(f10.3)') retcel(3)
X         write (line(49:),'(a)') 'beta'
X         write (line(56:),'(f10.3)') retcel(5)
X      elseif (lat(1:1) .eq. 'o') then
X         write (line(26:),'(f10.3)') retcel(2)
X         write (line(36:),'(f10.3)') retcel(3)
X      elseif (lat(1:1) .eq. 't') then
X         write (line(26:),'(f10.3)') retcel(3)
X      elseif (lat .eq. 'hR') then
X         write (line(29:),'(a)') 'alpha'
X         write (line(36:),'(f10.3)') retcel(4)
X      elseif (lat(1:1) .eq. 'h') then
X         write (line(26:),'(f10.3)') retcel(3)
X      elseif (lat(1:1) .eq. 'c') then
X      endif
X      if (ostyle.ne.'CIF ') write (*,'(a)') '  '//hm//' '//line
X      end
X
XC***********************************************************************
X      SUBROUTINE WRMATR (N,A)
X      include 'ITERATE.cmn'
X      REAL A(N,N)
XC-----------------------------------------------------------------------
X      DO 1000 I=1,N
X         WRITE (*,*) ' '//hm,(A(J,I),J=1,N)
X 1000 CONTINUE
X      END
X
XC***********************************************************************
X      SUBROUTINE WRSIZE (SIZE,ERRSIZ,RATIO,TEST)
X      include 'ITERATE.cmn'
X      CHARACTER *6 TEST
XC-----------------------------------------------------------------------
X      IF (TEST .NE. 'WRSIZE') THEN
X         WRITE (*,*) ' '//hm//' TEST WAS WRONG IN WRSIZE'
X         STOP
X      ENDIF
X      if (ostyle.ne.'CIF ') WRITE
X     2  (*,'(''  '//hm//
X     3  ' INPUT VECTOR SIZE AND ERROR AND RATIO '',3F10.2)')
X     4  SIZE,ERRSIZ,RATIO
X      END
X
XC***********************************************************************
X      SUBROUTINE WRVEC6(V,VE,TEST)
X      include 'ITERATE.cmn'
X      REAL V(6),VE(6)
X      CHARACTER *6 TEST
XC-----------------------------------------------------------------------
X
X      IF (TEST .NE. 'WRVEC6') THEN
X         WRITE (*,*) ' '//hm//' TEST WAS WRONG IN WRVEC6'
X         STOP
X      ENDIF
X
X      SUM = 0.0
X      DO 1000 I=1,6
X 1000 SUM = SUM + ABS(VE(I))
X      if (ostyle.ne.'CIF ') then
X      IF (SUM .EQ. 0) THEN
X         WRITE (*,'(1x,a3,1X,6F10.2)') ' '//hm//' ',V
X      ELSE
X         DO 3000 I=1,6
X            WRITE (*,'(1x,a3,1X,F10.3,3X,F10.3)') ' '//hm//' '
X     2        ,V(I),VE(I)
X 3000    CONTINUE
X      ENDIF
X      WRITE (*,*)
X      endif
X      END
X
XC**********************************************************************C
X      SUBROUTINE ZEROS (N,V)
X      REAL V(N)
XC----------------------------------------------------------------------C
X      DO 1000 I=1,N
X 1000 V(I) = 0.0
X      END
X
XC**********************************************************************C
X      SUBROUTINE INVER (A,B)
XC----INVERT A THREE BY THREE MATRIX
X      REAL X(9)
X      DIMENSION A(9),B(9)
X      DIMENSION IDATA1(3),IDATA2(3)
X      DATA IDATA1 /4,7,1/
X      DATA IDATA2 /7,1,4/
XC----------------------------------------------------------------------C
X      J = 0
X      DO 1000 I=1,9,3
X      J = J + 1
X      ID1 = IDATA1(J)
X      ID2 = IDATA2(J)
X      CALL CROSS(A(ID1),A(ID2),X(I))
X 1000 CONTINUE
X
X      DETA = DET(A)
X      IF (ABS(DETA) .LE. 1.0E-20) THEN
X         DETA = SIGN(1.0E-20,DETA)
X      ELSE
X         DETA = 1.0 / DETA
X      ENDIF
X
X      CALL CONMAT (X,DETA,X)
X      CALL TRNSPZ(X,B)
X      END
X
XC**********************************************************************C
X      SUBROUTINE VECSUM (X,Y,Z)
XC----ADD TWO VECTORS AND RETURN THE SUM IN Z
X      DIMENSION X(3), Y(3), Z(3)
XC----------------------------------------------------------------------C
X      DO 1000 I=1,3
X      Z(I) = X(I) + Y(I)
X 1000 CONTINUE
X      END
X
XC**********************************************************************C
X      SUBROUTINE VECDIF (X,Y,Z)
XC----SUBTRACT TWO VECTORS AND RETURN THE RESULT IN Z
X      DIMENSION X(3), Y(3), Z(3)
XC----------------------------------------------------------------------C
X      DO 1000 I=1,3
X      Z(I) = X(I) - Y(I)
X 1000 CONTINUE
X      END
X
XC**********************************************************************C
X      SUBROUTINE CPYVEC (X,Y)
XC----COPY A VECTOR X INTO A VECTOR Y
X      DIMENSION X(3), Y(3)
XC----------------------------------------------------------------------C
X      DO 1000 I=1,3
X      Y(I) = X(I)
X 1000 CONTINUE
X      END
X
XC**********************************************************************C
X      FUNCTION DOT (X,Y)
XC----COMPUTE AND RETURN THE DOT PRODUCT OF X AND Y
X      DIMENSION X(3),Y(3)
XC----------------------------------------------------------------------C
X      DOT = 0.0
X      DO 1000 I=1,3
X      DOT = DOT + X(I) * Y(I)
X 1000 CONTINUE
X      END
X
XC**********************************************************************C
X      SUBROUTINE TRNSPZ (A,B)
XC----PUT THE TRANSPOSE OF A INTO B
X      DIMENSION A(9), B(9)
XC----------------------------------------------------------------------C
X      J = 0
X      DO 1000 I=1,9,3
X      J = J + 1
X      CALL UNVEC (A(I),B(J),B(J+3),B(J+6))
X 1000 CONTINUE
X      END
X
XC**********************************************************************C
X      SUBROUTINE MATMUL (A,B,C)
XC----MULTIPLY TWO MATRICIES
X      REAL X(9)
X      DIMENSION A(9), B(9), C(9)
XC----GET THE TRANSPOSE OF B INTO X
XC----------------------------------------------------------------------C
X      CALL TRNSPZ (B,X)
X      IJ = 0
X      DO 2000 I=1,9,3
X      DO 2000 J=1,9,3
X      IJ = IJ + 1
X      C(IJ) = DOT(A(I),X(J))
X 2000 CONTINUE
X      END
X
XC**********************************************************************C
X      SUBROUTINE CROSS (X,Y,Z)
XC----COMPUTE Z = X CROSS Y
X      DIMENSION X(3),Y(3),Z(3)
XC----------------------------------------------------------------------C
X      Z(1) = X(2)*Y(3) - Y(2)*X(3)
X      Z(2) =-X(1)*Y(3) + Y(1)*X(3)
X      Z(3) = X(1)*Y(2) - Y(1)*X(2)
X      END
X
XC**********************************************************************C
X      FUNCTION DET(A)
XC----RETURN THE VALUE OF THE DETERMINANT OF A MATRIX
X      REAL X(3)
X      DIMENSION A(9)
XC----------------------------------------------------------------------C
X      CALL CROSS (A(1),A(4),X)
X      DET = DOT (X,A(7))
X      END
X
XC**********************************************************************C
X      SUBROUTINE CONMAT(AMAT,X,BMAT)
X      DIMENSION AMAT(9),BMAT(9)
XC----------------------------------------------------------------------C
X      DO 1000 I=1,9
X      BMAT(I) = X * AMAT(I)
X 1000 CONTINUE
X      END
X
XC**********************************************************************C
X      SUBROUTINE UNVEC (X,F,G,H)
XC----RETURN THE VECTOR COMPONENTS AS SCALARS
X      DIMENSION X(3)
XC----------------------------------------------------------------------C
X      F = X(1)
X      G = X(2)
X      H = X(3)
X      END
X
XC**********************************************************************C
X      SUBROUTINE WRCLV6 (C,CE,V,VE,TEST)
X      include 'ITERATE.cmn'
X      logical pnumb_
X      CHARACTER *6 TEST
X      REAL C(6),CE(6),V(6),VE(6)
XC----------------------------------------------------------------------C
X      if (test .ne. 'WRCLV6') then
X         write (*,*) ' '//hm//
X     2     ' test string was not WRCLV6 in that routine'
X         stop
X      endif
X      if (ostyle.ne.'CIF ') then
X
X         DO 3000 I=1,6
X            WRITE (*,'(1x,a3,1X,F10.3,3X,F8.3,8X,f10.3,3x,f8.2))')
X     2         ' '//hm//' ',C(I),CE(I),V(I),VE(I)
X 3000    CONTINUE
X
X      WRITE (*,*)
X      else
X      do ii = 1,6
X        cifres = pnumb_(' ',c(ii),0.)
X      enddo
X      endif
X      END
END_OF_FILE
if test 101777 -ne `wc -c <'iterate.f'`; then
    echo shar: \"'iterate.f'\" unpacked with wrong size!
fi
# end of 'iterate.f'
fi
if test -f 'iterate.html.m4' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'iterate.html.m4'\"
else
echo shar: Extracting \"'iterate.html.m4'\" \(8314 characters\)
sed "s/^X//" >'iterate.html.m4' <<'END_OF_FILE'
X<!doctype html public "-//IETF//DTD HTML 2.0//EN">
X<HTML>
X<HEAD>
X<TITLE>
XWWW G6 Bravais Lattice Determination
X</TITLE> 
X</HEAD> 
X<BODY>  
X<H2> G6 Bravais Lattice
XDetermination Interface </H2>
X<P> by
X<P> Lawrence C. Andrews,
X<script language="javascript" type="text/javascript">
X<!-- 
X      var name = "andrewsl";
X      var domain = "ix.netcom";
X      var domext = "com";
X      document.write ("<a href=\"mailto:"+name+"@"+domain+"."+domext+"\">"+name+"<b>at</b>"+domain +"<b>dot</b>"+domext+"</a>");
X// -->
X</script>
X<noscript>
Xandrewsl <b>at</b> ix.netcom <b>dot</b> com
X</noscript>
X<A HREF=mailto:andrews@thuridion.com>andrews@thuridion.com</A> 
Xand
X<BR>Herbert J. Bernstein,
X<script language="javascript" type="text/javascript">
X<!-- 
X      var name = "yaya";
X      var domain = "bernstein+sons";
X      var domext = "com";
X      document.write ("<a href=\"mailto:"+name+"@"+domain+"."+domext+"\">"+name+"<b>at</b>"+domain +"<b>dot</b>"+domext+"</a>");
X// -->
X</script>
X<noscript>
Xyaya <b>at</b> bernstein+sons <b>dot</b> com
X</noscript>
X<FORM method=POST ACTION=FULLHTDOCS()>
X<BR>
X<P>
X<STRONG>
XPlease read the NOTICE below before use of this web page
X</STRONG>
X<P>
X<INPUT type="submit">
X<INPUT type="reset">
X<BR>
XOutput Style: 
X<SELECT name="OutputStyle" size="2">
X<option selected value="TEXT">text
X<option value="CIF">CIF
X</SELECT>
X<H3>Select the crystal lattice centering:</H3> 
X<SELECT name="Centering" size="4"> 
X<option selected value="P">P (primitive)
X<option value="A"> A (a-centered)
X<option value="B"> B (b-centered)
X<option value="C"> C (c-centered)
X<option value="F"> F (all-faces-centered)
X<option value="I"> I (body-centered)
X<option value="R"> R (rhombohedral-obverse)
X<option value="H"> H (hexagonal primitive)
X</SELECT>
X<H3>Specify the cell edge lengths and angles:</H3>
X<BR>
X<table>
X<td>_cell.length_a <td><INPUT TYPE="text" NAME="A" VALUE="10." SIZE="9"> 
X<td>_cell.angle_alpha <td> <INPUT TYPE="text" NAME="Alpha" VALUE="90." SIZE="9"><BR><tr>  
X<td>_cell.length_b <td><INPUT TYPE="text" NAME="B" VALUE="10." SIZE="9"> 
X<td>_cell.angle_beta  <td> <INPUT TYPE="text" NAME="Beta" VALUE="90." SIZE="9"><BR><tr>
X<td>_cell.length_c <td><INPUT TYPE="text" NAME="C" VALUE="10." SIZE="9"> 
X<td>_cell.angle_gamma <td> <INPUT TYPE="text" NAME="Gamma" VALUE="90." SIZE="9"><BR><tr>
X</table>
X
X
X<H3>Specify the cell edge length esd's and angle esd's:</H3>
X<BR>
X<table>
X<td>_cell.length_a_esd <td> <INPUT TYPE="text" NAME="sigA" VALUE=".15" SIZE="9">   
X<td>_cell.angle_alpha_esd  <td> <INPUT TYPE="text" NAME="sigAlpha" VALUE=".2" SIZE="9"><BR><tr>
X<td>_cell.length_b_esd<td> <INPUT TYPE="text" NAME="sigB" VALUE=".15" SIZE="9"> 
X<td>_cell.angle_beta_esd   <td> <INPUT TYPE="text" NAME="sigBeta" VALUE=".2" SIZE="9"><BR><tr> 
X<td>_cell.length_c_esd<td> <INPUT TYPE="text" NAME="sigC" VALUE=".15" SIZE="9">   
X<td>_cell.angle_gamma_esd  <td> <INPUT TYPE="text" NAME="sigGamma" VALUE=".2" SIZE="9"><BR><tr>
X</table>
X<hr>
X<INPUT type="hidden" NAME="Flush" VALUE="DUMMY">
X<INPUT type="submit">
X<INPUT type="reset">
X</Form> <hr>
X
X<H2>NOTICE</H2>
X<P>
X    Copyright &copy; 1988, 1996, 2008   Lawrence C. Andrews and Herbert J. Bernstein
X<P>
X    This software is free software; you can redistribute it and/or
X    modify it under the terms of the GNU Lesser General Public
X    License as published by the Free Software Foundation; either
X    version 2.1 of the License, or (at your option) any later version.
X<P>
X    This software is distributed in the hope that it will be useful,
X    but WITHOUT ANY WARRANTY; without even the implied warranty of
X    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
X    Lesser General Public License for more details.
X<P>
X    You should have received a copy of the <a href=lgpl.txt>GNU Lesser General Public
X    License</a> along with this library; if not, write to the Free Software
X    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
X<P>
X<hr>
X<H2> Access to the source of ITERATE </H2>
X<P>
XThe lastest source code of iterate is available on sourceforge
Xin <a href=http://www.sourceforge.net/projects/iterate>http://www.sourceforge.net/projects/iterate</a>.
XThis program and related scripts are available as
X<A HREF="iterate.shar"> a self-extracting shell-script archive</A> or as
X<A HREF="iterate.cshar"> a self-extracting C-shell-script archive.</A>
X<H2> What Does This Web Page Do? </H2>
X<P>
XIn simple terms, what this page does is to find the cells which are
X&quot;close&quot; to the cell given, in order to help find the
XBravais lattice of highest symmetry consistent with the cell.
X<P>A central problem in the solution of every crystal structure
Xis to determine the correct Bravais lattice of the crystal.
XThe Bravais lattices as they are usually listed
Xare:<P>
X<table>
X<td>aP   <td>triclinic (anorthic) primitive <BR><tr>
X<td>mP   <td>monoclinic primitive <BR><tr>
X<td>mS   <td>monoclinic side-centered (usually C-centered) <BR><tr>
X<td>oP   <td>orthorhombic primitive <BR><tr>
X<td>oS   <td>orthorhombic side-centered <BR><tr>
X<td>oF   <td>orthorhombic face-centered <BR><tr>
X<td>oI   <td>orthorhombic body-centered <BR><tr>
X<td>hP   <td>hexagonal primitive <BR><tr>
X<td>hR   <td>hexagonal rhombohedrally-centered <BR><tr>
X<td>tP   <td>tetragonal primitive <BR><tr>
X<td>tI   <td>tetragonal body-centered <BR><tr>
X<td>cP   <td>cubic primitive <BR><tr>
X<td>cF   <td>cubic face-centered <BR><tr>
X<td>cI   <td>cubic body-centered <BR><tr>
X</table>
X
X<P>Failure to find the highest correct symmetry has several consequences, the
Xworst of which is that the structure may not be solved. The least of the
Xconsequences is that Richard Marsh may 
Xpublish a paper that points out the error,
Xcorrects it, and finds a better solution 
Xto the structure. Many methods have been
Xdescribed for finding the correct Bravais lattice. A summary of the published
Xmethods was published in the paper that 
Xdescribed the G6 formalism (which is used
Xin the program on this web page).
X
X<P>&quot;Lattices and Reduced Cells as 
XPoints in 6-Space and Selection of Bravais
XLattice Type by Projections.&quot; 
XLawrence C. Andrews and Herbert J. Bernstein, Acta
XCrystallographica, A44, 1009-1018 (1988).
X
X<P>The program on this Web page implements a 
Xsearch in G6 for the various Bravais
Xlattices that the user's cell may fit. For each lattice type, the best metric
Xmatch is reported. If the higher symmetry type is actually correct, then that is
Xlikely to be the best cell from which to start further refinement. However, the
Xpossibility exists that one of the rejected cells (which did not match as well)
Xwas actually the correct one to use. The reason for this ambiguity is
Xexperimental error and its propagation in the transformations of the lattices in
Xthe program. Fortunately, the rejected cells are usually quite similar to the
Xaccepted one.
X
X<P>A note on standard deviations: First, even in the best of circumstances,
Xstandard deviations of unit cell dimensions 
Xfrom 4-circle diffractometer data are
Xalways underestimated (by at least a factor 
Xof 2). In addition, the points chosen
Xfor the determination are often not well distributed (for example all in the
Xfirst octant of orthorhombic lattices). These less than optimal choices cause
Xsubstantial systematic error. The experimental errors are amplified in the
Xmathematical conversions between various 
Xlattices that any lattice search program
Xmust perform.  It is not a rare occurrence for angles to be incorrect by 0.5
Xdegrees in initial unit cell determinations.
X<P> <STRONG>Note:</STRONG> Even in most well determined unit
Xcells, the actual errors in the edge lengths is 0.2 to 0.5 parts per thousand.
X(Note that reproducibility of the measurements is substantially better, leading
Xto the illusion that diffractometers 
Xproduce excellent unit cell parameters). Use
Xof standard deviations that are too small is a common reason for failure of
XBravais lattice searches. For small molecules, 0.1 Angstroms is a reasonable
Xerror for the edge lengths, for proteins, 0.4 to 0.5 (or even more for
Xpreliminary measurements). Accurate unit cell parameters must by determined by a
Xnumber of more complex methods and must `include' extrapolation to remove
Xsystematic effects. For an excellent summary, 
Xsee &quot;Xray Structure Determination&quot;,
XG.H.Stout and L.H.Jensen, Wiley, 1989.
X
X</BODY>
X</HTML>
END_OF_FILE
if test 8314 -ne `wc -c <'iterate.html.m4'`; then
    echo shar: \"'iterate.html.m4'\" unpacked with wrong size!
fi
# end of 'iterate.html.m4'
fi
if test -f 'lgpl.txt' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lgpl.txt'\"
else
echo shar: Extracting \"'lgpl.txt'\" \(26432 characters\)
sed "s/^X//" >'lgpl.txt' <<'END_OF_FILE'
X		  GNU LESSER GENERAL PUBLIC LICENSE
X		       Version 2.1, February 1999
X
X Copyright (C) 1991, 1999 Free Software Foundation, Inc.
X     51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
X Everyone is permitted to copy and distribute verbatim copies
X of this license document, but changing it is not allowed.
X
X[This is the first released version of the Lesser GPL.  It also counts
X as the successor of the GNU Library Public License, version 2, hence
X the version number 2.1.]
X
X			    Preamble
X
X  The licenses for most software are designed to take away your
Xfreedom to share and change it.  By contrast, the GNU General Public
XLicenses are intended to guarantee your freedom to share and change
Xfree software--to make sure the software is free for all its users.
X
X  This license, the Lesser General Public License, applies to some
Xspecially designated software packages--typically libraries--of the
XFree Software Foundation and other authors who decide to use it.  You
Xcan use it too, but we suggest you first think carefully about whether
Xthis license or the ordinary General Public License is the better
Xstrategy to use in any particular case, based on the explanations below.
X
X  When we speak of free software, we are referring to freedom of use,
Xnot price.  Our General Public Licenses are designed to make sure that
Xyou have the freedom to distribute copies of free software (and charge
Xfor this service if you wish); that you receive source code or can get
Xit if you want it; that you can change the software and use pieces of
Xit in new free programs; and that you are informed that you can do
Xthese things.
X
X  To protect your rights, we need to make restrictions that forbid
Xdistributors to deny you these rights or to ask you to surrender these
Xrights.  These restrictions translate to certain responsibilities for
Xyou if you distribute copies of the library or if you modify it.
X
X  For example, if you distribute copies of the library, whether gratis
Xor for a fee, you must give the recipients all the rights that we gave
Xyou.  You must make sure that they, too, receive or can get the source
Xcode.  If you link other code with the library, you must provide
Xcomplete object files to the recipients, so that they can relink them
Xwith the library after making changes to the library and recompiling
Xit.  And you must show them these terms so they know their rights.
X
X  We protect your rights with a two-step method: (1) we copyright the
Xlibrary, and (2) we offer you this license, which gives you legal
Xpermission to copy, distribute and/or modify the library.
X
X  To protect each distributor, we want to make it very clear that
Xthere is no warranty for the free library.  Also, if the library is
Xmodified by someone else and passed on, the recipients should know
Xthat what they have is not the original version, so that the original
Xauthor's reputation will not be affected by problems that might be
Xintroduced by others.
X
X  Finally, software patents pose a constant threat to the existence of
Xany free program.  We wish to make sure that a company cannot
Xeffectively restrict the users of a free program by obtaining a
Xrestrictive license from a patent holder.  Therefore, we insist that
Xany patent license obtained for a version of the library must be
Xconsistent with the full freedom of use specified in this license.
X
X  Most GNU software, including some libraries, is covered by the
Xordinary GNU General Public License.  This license, the GNU Lesser
XGeneral Public License, applies to certain designated libraries, and
Xis quite different from the ordinary General Public License.  We use
Xthis license for certain libraries in order to permit linking those
Xlibraries into non-free programs.
X
X  When a program is linked with a library, whether statically or using
Xa shared library, the combination of the two is legally speaking a
Xcombined work, a derivative of the original library.  The ordinary
XGeneral Public License therefore permits such linking only if the
Xentire combination fits its criteria of freedom.  The Lesser General
XPublic License permits more lax criteria for linking other code with
Xthe library.
X
X  We call this license the "Lesser" General Public License because it
Xdoes Less to protect the user's freedom than the ordinary General
XPublic License.  It also provides other free software developers Less
Xof an advantage over competing non-free programs.  These disadvantages
Xare the reason we use the ordinary General Public License for many
Xlibraries.  However, the Lesser license provides advantages in certain
Xspecial circumstances.
X
X  For example, on rare occasions, there may be a special need to
Xencourage the widest possible use of a certain library, so that it becomes
Xa de-facto standard.  To achieve this, non-free programs must be
Xallowed to use the library.  A more frequent case is that a free
Xlibrary does the same job as widely used non-free libraries.  In this
Xcase, there is little to gain by limiting the free library to free
Xsoftware only, so we use the Lesser General Public License.
X
X  In other cases, permission to use a particular library in non-free
Xprograms enables a greater number of people to use a large body of
Xfree software.  For example, permission to use the GNU C Library in
Xnon-free programs enables many more people to use the whole GNU
Xoperating system, as well as its variant, the GNU/Linux operating
Xsystem.
X
X  Although the Lesser General Public License is Less protective of the
Xusers' freedom, it does ensure that the user of a program that is
Xlinked with the Library has the freedom and the wherewithal to run
Xthat program using a modified version of the Library.
X
X  The precise terms and conditions for copying, distribution and
Xmodification follow.  Pay close attention to the difference between a
X"work based on the library" and a "work that uses the library".  The
Xformer contains code derived from the library, whereas the latter must
Xbe combined with the library in order to run.
X
X		  GNU LESSER GENERAL PUBLIC LICENSE
X   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
X
X  0. This License Agreement applies to any software library or other
Xprogram which contains a notice placed by the copyright holder or
Xother authorized party saying it may be distributed under the terms of
Xthis Lesser General Public License (also called "this License").
XEach licensee is addressed as "you".
X
X  A "library" means a collection of software functions and/or data
Xprepared so as to be conveniently linked with application programs
X(which use some of those functions and data) to form executables.
X
X  The "Library", below, refers to any such software library or work
Xwhich has been distributed under these terms.  A "work based on the
XLibrary" means either the Library or any derivative work under
Xcopyright law: that is to say, a work containing the Library or a
Xportion of it, either verbatim or with modifications and/or translated
Xstraightforwardly into another language.  (Hereinafter, translation is
Xincluded without limitation in the term "modification".)
X
X  "Source code" for a work means the preferred form of the work for
Xmaking modifications to it.  For a library, complete source code means
Xall the source code for all modules it contains, plus any associated
Xinterface definition files, plus the scripts used to control compilation
Xand installation of the library.
X
X  Activities other than copying, distribution and modification are not
Xcovered by this License; they are outside its scope.  The act of
Xrunning a program using the Library is not restricted, and output from
Xsuch a program is covered only if its contents constitute a work based
Xon the Library (independent of the use of the Library in a tool for
Xwriting it).  Whether that is true depends on what the Library does
Xand what the program that uses the Library does.
X  
X  1. You may copy and distribute verbatim copies of the Library's
Xcomplete source code as you receive it, in any medium, provided that
Xyou conspicuously and appropriately publish on each copy an
Xappropriate copyright notice and disclaimer of warranty; keep intact
Xall the notices that refer to this License and to the absence of any
Xwarranty; and distribute a copy of this License along with the
XLibrary.
X
X  You may charge a fee for the physical act of transferring a copy,
Xand you may at your option offer warranty protection in exchange for a
Xfee.
X
X  2. You may modify your copy or copies of the Library or any portion
Xof it, thus forming a work based on the Library, and copy and
Xdistribute such modifications or work under the terms of Section 1
Xabove, provided that you also meet all of these conditions:
X
X    a) The modified work must itself be a software library.
X
X    b) You must cause the files modified to carry prominent notices
X    stating that you changed the files and the date of any change.
X
X    c) You must cause the whole of the work to be licensed at no
X    charge to all third parties under the terms of this License.
X
X    d) If a facility in the modified Library refers to a function or a
X    table of data to be supplied by an application program that uses
X    the facility, other than as an argument passed when the facility
X    is invoked, then you must make a good faith effort to ensure that,
X    in the event an application does not supply such function or
X    table, the facility still operates, and performs whatever part of
X    its purpose remains meaningful.
X
X    (For example, a function in a library to compute square roots has
X    a purpose that is entirely well-defined independent of the
X    application.  Therefore, Subsection 2d requires that any
X    application-supplied function or table used by this function must
X    be optional: if the application does not supply it, the square
X    root function must still compute square roots.)
X
XThese requirements apply to the modified work as a whole.  If
Xidentifiable sections of that work are not derived from the Library,
Xand can be reasonably considered independent and separate works in
Xthemselves, then this License, and its terms, do not apply to those
Xsections when you distribute them as separate works.  But when you
Xdistribute the same sections as part of a whole which is a work based
Xon the Library, the distribution of the whole must be on the terms of
Xthis License, whose permissions for other licensees extend to the
Xentire whole, and thus to each and every part regardless of who wrote
Xit.
X
XThus, it is not the intent of this section to claim rights or contest
Xyour rights to work written entirely by you; rather, the intent is to
Xexercise the right to control the distribution of derivative or
Xcollective works based on the Library.
X
XIn addition, mere aggregation of another work not based on the Library
Xwith the Library (or with a work based on the Library) on a volume of
Xa storage or distribution medium does not bring the other work under
Xthe scope of this License.
X
X  3. You may opt to apply the terms of the ordinary GNU General Public
XLicense instead of this License to a given copy of the Library.  To do
Xthis, you must alter all the notices that refer to this License, so
Xthat they refer to the ordinary GNU General Public License, version 2,
Xinstead of to this License.  (If a newer version than version 2 of the
Xordinary GNU General Public License has appeared, then you can specify
Xthat version instead if you wish.)  Do not make any other change in
Xthese notices.
X
X  Once this change is made in a given copy, it is irreversible for
Xthat copy, so the ordinary GNU General Public License applies to all
Xsubsequent copies and derivative works made from that copy.
X
X  This option is useful when you wish to copy part of the code of
Xthe Library into a program that is not a library.
X
X  4. You may copy and distribute the Library (or a portion or
Xderivative of it, under Section 2) in object code or executable form
Xunder the terms of Sections 1 and 2 above provided that you accompany
Xit with the complete corresponding machine-readable source code, which
Xmust be distributed under the terms of Sections 1 and 2 above on a
Xmedium customarily used for software interchange.
X
X  If distribution of object code is made by offering access to copy
Xfrom a designated place, then offering equivalent access to copy the
Xsource code from the same place satisfies the requirement to
Xdistribute the source code, even though third parties are not
Xcompelled to copy the source along with the object code.
X
X  5. A program that contains no derivative of any portion of the
XLibrary, but is designed to work with the Library by being compiled or
Xlinked with it, is called a "work that uses the Library".  Such a
Xwork, in isolation, is not a derivative work of the Library, and
Xtherefore falls outside the scope of this License.
X
X  However, linking a "work that uses the Library" with the Library
Xcreates an executable that is a derivative of the Library (because it
Xcontains portions of the Library), rather than a "work that uses the
Xlibrary".  The executable is therefore covered by this License.
XSection 6 states terms for distribution of such executables.
X
X  When a "work that uses the Library" uses material from a header file
Xthat is part of the Library, the object code for the work may be a
Xderivative work of the Library even though the source code is not.
XWhether this is true is especially significant if the work can be
Xlinked without the Library, or if the work is itself a library.  The
Xthreshold for this to be true is not precisely defined by law.
X
X  If such an object file uses only numerical parameters, data
Xstructure layouts and accessors, and small macros and small inline
Xfunctions (ten lines or less in length), then the use of the object
Xfile is unrestricted, regardless of whether it is legally a derivative
Xwork.  (Executables containing this object code plus portions of the
XLibrary will still fall under Section 6.)
X
X  Otherwise, if the work is a derivative of the Library, you may
Xdistribute the object code for the work under the terms of Section 6.
XAny executables containing that work also fall under Section 6,
Xwhether or not they are linked directly with the Library itself.
X
X  6. As an exception to the Sections above, you may also combine or
Xlink a "work that uses the Library" with the Library to produce a
Xwork containing portions of the Library, and distribute that work
Xunder terms of your choice, provided that the terms permit
Xmodification of the work for the customer's own use and reverse
Xengineering for debugging such modifications.
X
X  You must give prominent notice with each copy of the work that the
XLibrary is used in it and that the Library and its use are covered by
Xthis License.  You must supply a copy of this License.  If the work
Xduring execution displays copyright notices, you must include the
Xcopyright notice for the Library among them, as well as a reference
Xdirecting the user to the copy of this License.  Also, you must do one
Xof these things:
X
X    a) Accompany the work with the complete corresponding
X    machine-readable source code for the Library including whatever
X    changes were used in the work (which must be distributed under
X    Sections 1 and 2 above); and, if the work is an executable linked
X    with the Library, with the complete machine-readable "work that
X    uses the Library", as object code and/or source code, so that the
X    user can modify the Library and then relink to produce a modified
X    executable containing the modified Library.  (It is understood
X    that the user who changes the contents of definitions files in the
X    Library will not necessarily be able to recompile the application
X    to use the modified definitions.)
X
X    b) Use a suitable shared library mechanism for linking with the
X    Library.  A suitable mechanism is one that (1) uses at run time a
X    copy of the library already present on the user's computer system,
X    rather than copying library functions into the executable, and (2)
X    will operate properly with a modified version of the library, if
X    the user installs one, as long as the modified version is
X    interface-compatible with the version that the work was made with.
X
X    c) Accompany the work with a written offer, valid for at
X    least three years, to give the same user the materials
X    specified in Subsection 6a, above, for a charge no more
X    than the cost of performing this distribution.
X
X    d) If distribution of the work is made by offering access to copy
X    from a designated place, offer equivalent access to copy the above
X    specified materials from the same place.
X
X    e) Verify that the user has already received a copy of these
X    materials or that you have already sent this user a copy.
X
X  For an executable, the required form of the "work that uses the
XLibrary" must include any data and utility programs needed for
Xreproducing the executable from it.  However, as a special exception,
Xthe materials to be distributed need not include anything that is
Xnormally distributed (in either source or binary form) with the major
Xcomponents (compiler, kernel, and so on) of the operating system on
Xwhich the executable runs, unless that component itself accompanies
Xthe executable.
X
X  It may happen that this requirement contradicts the license
Xrestrictions of other proprietary libraries that do not normally
Xaccompany the operating system.  Such a contradiction means you cannot
Xuse both them and the Library together in an executable that you
Xdistribute.
X
X  7. You may place library facilities that are a work based on the
XLibrary side-by-side in a single library together with other library
Xfacilities not covered by this License, and distribute such a combined
Xlibrary, provided that the separate distribution of the work based on
Xthe Library and of the other library facilities is otherwise
Xpermitted, and provided that you do these two things:
X
X    a) Accompany the combined library with a copy of the same work
X    based on the Library, uncombined with any other library
X    facilities.  This must be distributed under the terms of the
X    Sections above.
X
X    b) Give prominent notice with the combined library of the fact
X    that part of it is a work based on the Library, and explaining
X    where to find the accompanying uncombined form of the same work.
X
X  8. You may not copy, modify, sublicense, link with, or distribute
Xthe Library except as expressly provided under this License.  Any
Xattempt otherwise to copy, modify, sublicense, link with, or
Xdistribute the Library is void, and will automatically terminate your
Xrights under this License.  However, parties who have received copies,
Xor rights, from you under this License will not have their licenses
Xterminated so long as such parties remain in full compliance.
X
X  9. You are not required to accept this License, since you have not
Xsigned it.  However, nothing else grants you permission to modify or
Xdistribute the Library or its derivative works.  These actions are
Xprohibited by law if you do not accept this License.  Therefore, by
Xmodifying or distributing the Library (or any work based on the
XLibrary), you indicate your acceptance of this License to do so, and
Xall its terms and conditions for copying, distributing or modifying
Xthe Library or works based on it.
X
X  10. Each time you redistribute the Library (or any work based on the
XLibrary), the recipient automatically receives a license from the
Xoriginal licensor to copy, distribute, link with or modify the Library
Xsubject to these terms and conditions.  You may not impose any further
Xrestrictions on the recipients' exercise of the rights granted herein.
XYou are not responsible for enforcing compliance by third parties with
Xthis License.
X
X  11. If, as a consequence of a court judgment or allegation of patent
Xinfringement or for any other reason (not limited to patent issues),
Xconditions are imposed on you (whether by court order, agreement or
Xotherwise) that contradict the conditions of this License, they do not
Xexcuse you from the conditions of this License.  If you cannot
Xdistribute so as to satisfy simultaneously your obligations under this
XLicense and any other pertinent obligations, then as a consequence you
Xmay not distribute the Library at all.  For example, if a patent
Xlicense would not permit royalty-free redistribution of the Library by
Xall those who receive copies directly or indirectly through you, then
Xthe only way you could satisfy both it and this License would be to
Xrefrain entirely from distribution of the Library.
X
XIf any portion of this section is held invalid or unenforceable under any
Xparticular circumstance, the balance of the section is intended to apply,
Xand the section as a whole is intended to apply in other circumstances.
X
XIt is not the purpose of this section to induce you to infringe any
Xpatents or other property right claims or to contest validity of any
Xsuch claims; this section has the sole purpose of protecting the
Xintegrity of the free software distribution system which is
Ximplemented by public license practices.  Many people have made
Xgenerous contributions to the wide range of software distributed
Xthrough that system in reliance on consistent application of that
Xsystem; it is up to the author/donor to decide if he or she is willing
Xto distribute software through any other system and a licensee cannot
Ximpose that choice.
X
XThis section is intended to make thoroughly clear what is believed to
Xbe a consequence of the rest of this License.
X
X  12. If the distribution and/or use of the Library is restricted in
Xcertain countries either by patents or by copyrighted interfaces, the
Xoriginal copyright holder who places the Library under this License may add
Xan explicit geographical distribution limitation excluding those countries,
Xso that distribution is permitted only in or among countries not thus
Xexcluded.  In such case, this License incorporates the limitation as if
Xwritten in the body of this License.
X
X  13. The Free Software Foundation may publish revised and/or new
Xversions of the Lesser General Public License from time to time.
XSuch new versions will be similar in spirit to the present version,
Xbut may differ in detail to address new problems or concerns.
X
XEach version is given a distinguishing version number.  If the Library
Xspecifies a version number of this License which applies to it and
X"any later version", you have the option of following the terms and
Xconditions either of that version or of any later version published by
Xthe Free Software Foundation.  If the Library does not specify a
Xlicense version number, you may choose any version ever published by
Xthe Free Software Foundation.
X
X  14. If you wish to incorporate parts of the Library into other free
Xprograms whose distribution conditions are incompatible with these,
Xwrite to the author to ask for permission.  For software which is
Xcopyrighted by the Free Software Foundation, write to the Free
XSoftware Foundation; we sometimes make exceptions for this.  Our
Xdecision will be guided by the two goals of preserving the free status
Xof all derivatives of our free software and of promoting the sharing
Xand reuse of software generally.
X
X			    NO WARRANTY
X
X  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
XWARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
XEXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
XOTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
XKIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
XIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
XPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
XLIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
XTHE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
X
X  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
XWRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
XAND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
XFOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
XCONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
XLIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
XRENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
XFAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
XSUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
XDAMAGES.
X
X		     END OF TERMS AND CONDITIONS
X
X           How to Apply These Terms to Your New Libraries
X
X  If you develop a new library, and you want it to be of the greatest
Xpossible use to the public, we recommend making it free software that
Xeveryone can redistribute and change.  You can do so by permitting
Xredistribution under these terms (or, alternatively, under the terms of the
Xordinary General Public License).
X
X  To apply these terms, attach the following notices to the library.  It is
Xsafest to attach them to the start of each source file to most effectively
Xconvey the exclusion of warranty; and each file should have at least the
X"copyright" line and a pointer to where the full notice is found.
X
X    <one line to give the library's name and a brief idea of what it does.>
X    Copyright (C) <year>  <name of author>
X
X    This library is free software; you can redistribute it and/or
X    modify it under the terms of the GNU Lesser General Public
X    License as published by the Free Software Foundation; either
X    version 2.1 of the License, or (at your option) any later version.
X
X    This library is distributed in the hope that it will be useful,
X    but WITHOUT ANY WARRANTY; without even the implied warranty of
X    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
X    Lesser General Public License for more details.
X
X    You should have received a copy of the GNU Lesser General Public
X    License along with this library; if not, write to the Free Software
X    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
X
XAlso add information on how to contact you by electronic and paper mail.
X
XYou should also get your employer (if you work as a programmer) or your
Xschool, if any, to sign a "copyright disclaimer" for the library, if
Xnecessary.  Here is a sample; alter the names:
X
X  Yoyodyne, Inc., hereby disclaims all copyright interest in the
X  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
X
X  <signature of Ty Coon>, 1 April 1990
X  Ty Coon, President of Vice
X
XThat's all there is to it!
X
X
END_OF_FILE
if test 26432 -ne `wc -c <'lgpl.txt'`; then
    echo shar: \"'lgpl.txt'\" unpacked with wrong size!
fi
# end of 'lgpl.txt'
fi
echo shar: End of archive 1 \(of 1\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have the archive.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
